## 离散元简介 [to be updated with an English version]

### 离散元方法基本元素：

- 颗粒：
    - 颗粒具有形状、位置、速度、所受到的力等变量或属性
    - 颗粒的运动服从牛顿运动定律
    - 颗粒间相互接触，产生接触力，接触力根据相应的接触模型求得 

- 墙或边界：
    - 边界具有形状、位置、所受到的力等变量或属性
    - 边界一般假设为无质量，所以无需计算牛顿运动，只需根据预设的运动规律更新其位置

- 接触：
    - 颗粒与颗粒、或颗粒与边界之间的接触
    - 具有接触几何特征、接触力等属性
    - 接触模型描述接触力与接触几何特征之间的关系

## 程序的基本计算流程与框架

### 程序目前包含7个模块：

- domain：定义计算域
- evaluator: 定义离散元模型的一些个性化计算，比如添加外力、导出数据等。因为这些个性化计算
    并不是每个计算模型都需要，所以通过这种订阅的方式来自由添加到模型。一般是先定义evaluator，然后
    attach到一个simulation并激活，当离散元计算到某个节点时，就会统一调用已订阅的evaluator。
    目前定义了两种evaluator：pre_evaluator, post_evaluator。pre_evaluator在每个计算周期
    开始时被调用，post_evaluator在每个计算周期结束时被调用。
- input：用来解读输入文件。计划采用json格式作为数据交互格式。每一个json对象都对应一个命令，
    通过命令的执行来构建或修改simulation。计划定义6中命令：create、get、set、fix、unfix、run。
    - create：创建shape, particle, wall, contact model, evaluator等对象
    - get: 获得对象属性
    - set：设置对象属性
    - fix：将定义的evaluator绑定到simulation以激活。
    - unfix：将定义的evalua解绑以使其失效。
    - run：开始离散元计算
- mpi：不同并行计算核之间的数据交互
- scene：场景
    - 包含shape, particle, wall, contact model, evaluator等实例
- solver：离散元求解器
- utils：其他工具函数

### 离散元基本计算流程（DEMSolver计算过程）：

- 遍历本计算域内的所有“颗粒”，将其所受力和转矩清零。
- 执行pre_evaluator，比如重力等作用。
- 遍历本计算域内的所有“颗粒”，判断其轮廓是否接触到其他计算域：如果是，则利用MPI将其数据传递给该计算域，
    并根据该颗粒数据在目标计算域创建一新颗粒，作为该颗粒在目标计算域的一代理，代理颗粒可与其他颗粒发生接触。
    本计算域内的颗粒称其为“待发送的颗粒代理”，目标计算域内的颗粒称为“接收到的颗粒代理”。
- 接收“颗粒代理”数据，并创建颗粒代理实例：
    - 若本计算域已包含该颗粒代理的id，则通过particlem_map找到该颗粒指针，用接收到的
        颗粒代理数据更新该颗粒实例；
    - 若不存在该颗粒代理的id，则新建一“颗粒幻象”（particle_ghost）实例，用接收到的
        颗粒代理数据更新该颗粒实例；
- 遍历“待发送的颗粒代理”，将其对应的“接触数据”也一并发送到目标计算域。
- 接收接触数据，并创建接触实例：
    - 根据颗粒id确定颗粒的指针，根据接触模型id确定接触模型指针
    - 通过颗粒的contact_pp_list判断该接触是否以存在
        - 若存在，则从接收到的接触数据更新该接触实例。
        - 若不存在，则先建接触，并用接收到的颗粒代理数据更新该颗粒实例、
- 遍历所有接触，将其updated设置为false。
- 将计算域划分成网格，遍历本计算域内的所有“颗粒”以及“接收到的颗粒代理”，将其归类到各网格中。归类的准则为：
    若该颗粒或颗粒代理的外接立方体与某网格接触，则将该颗粒或颗粒代理添加到该网格。
- 遍历所有网格：
    - 遍历本网格内的颗粒及颗粒代理，判断其是否接触。若接触：
        - 判断其在上一时间步是否接触
            - 是，则找到该接触实例，更新其接触几何特征与接触力，将接触的updated设置为true
            - 否，则新创建一接触实例，初始化接触几何特征并计算接触力，将接触的updated设置为true
        - 将接触力施加到颗粒及边界
- 遍历“接收到的颗粒代理”：
    - 遍历该颗粒代理的接触，若接触updated状态为true，利用MPI将该接触数据发送回原计算域
    - 接收由其他计算域传回的接触，重建接触实例
        - 若接触已存在，则利用传回数据更新原接触
        - 若接触不存在，则新建接触，重建接触内的颗粒指针
            - 若计算域存在该颗粒，则通过particle_map和颗粒id找到颗粒指针。
            - 若计算域不存在该颗粒，则新建一“颗粒幻象”，将该“颗粒幻象”指针设置给该接触。
    - 将接触力施加到颗粒
- 遍历所有接触
    - 若其updated状态为false，则删除该接触；
- 遍历所有颗粒
    - 根据牛顿运动定律更新其速度、位置等属性
- 将partical_proxy_list添加到particle_ghost_list，并将partical_proxy_list清空
- 根据更新后的颗粒位置，遍历每个颗粒，判断其是否超出本计算域：
    - 若是，则将其数据发送到该颗粒新在的计算域，并将该颗粒移动到particle_ghost_list。
- 接收“颗粒”数据，并创建颗粒实例：
    - 若本计算域已包含该颗粒的id，则通过particlem_map找到该颗粒指针，用接收到的
        颗粒数据更新该颗粒实例；
    - 若不存在该颗粒的id，则新建一颗粒实例，用接收到的颗粒数据更新该颗粒实例；
- 遍历particle_ghost_list
    - 若其不与任何颗粒或边界接触，则删除该"颗粒幻象"
- 执行post_evaluator，比如数据输出等功能。
    




