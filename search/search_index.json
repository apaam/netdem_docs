{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Previous Next NetDEM is a neural network enabled C++ library for discrete element methods. Features It is currently capable of performing basic and general DEM simulations, with following features: Sphere and triangle facets contact solver GJK contact solver for convex particles SDF contact solver for arbitrary (convex and concave) particles Hybrid OpenMP and MPI parallel computing Integrated mlpack machine learning environment The supported particle shapes include sphere, cylinder, poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, triangle mesh, level set, etc. News Date Message Dec 01, 2021 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10, 2021 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15, 2021 Generlized two types of contact solvers, namely GJK and SDF. Mar 15, 2021 Integrated the MLPACK as the machine learning environment. Documentation Building NetDEM \u250a Getting Started \u250a Examples \u250a Code doxygen \u250a Sources We recommend new users to start by examining the example codes . Currently, we use paraview for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . License & citation NetDEM is distributed under the BSD 3-Clause license, see copyright and license for details. See the about page for acknowledgements and citation information.","title":"Home"},{"location":"#features","text":"It is currently capable of performing basic and general DEM simulations, with following features: Sphere and triangle facets contact solver GJK contact solver for convex particles SDF contact solver for arbitrary (convex and concave) particles Hybrid OpenMP and MPI parallel computing Integrated mlpack machine learning environment The supported particle shapes include sphere, cylinder, poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, triangle mesh, level set, etc.","title":"Features"},{"location":"#news","text":"Date Message Dec 01, 2021 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10, 2021 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15, 2021 Generlized two types of contact solvers, namely GJK and SDF. Mar 15, 2021 Integrated the MLPACK as the machine learning environment.","title":"News"},{"location":"#documentation","text":"Building NetDEM \u250a Getting Started \u250a Examples \u250a Code doxygen \u250a Sources We recommend new users to start by examining the example codes . Currently, we use paraview for visualization.","title":"Documentation"},{"location":"#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments .","title":"Contact"},{"location":"#license-citation","text":"NetDEM is distributed under the BSD 3-Clause license, see copyright and license for details. See the about page for acknowledgements and citation information.","title":"License &amp; citation"},{"location":"about/acknowledgement/","text":"How to cite We do not have a paper for this extire library for now. Please cite one of our relevant works with @article{lai2021revisiting, title={Revisiting the GJK and shape erosion method for contact resolution in DEM}, author={Lai, Zhengshou and Zhao, Shiwei and Zhao, Jidong and Huang, Linchong}, journal={Powder Technology}, year={2021}, publisher={Elsevier} } Contributors We would like to thank all the peer researchers that have directly or indrectly made a contribution to this project, by means of submitting commits or pull requests, making suggestions or discussions, finding and resolving bugs or difficulties during usage, etc. We would also like to thank the authors of thrid party software packages (in dependencies ) that are used by this project and have greatly faciliated the development of this project. Fundings This project is under active development. The fundings that have supported the development of this project are acknowledged and will be updated accordingly. 2019-2022: National Natural Science Foundation of China (51909289) 2019-2021: China Postdoctoral Science Foundation (2019M663240) 2020-2022: Hong Kong Scholar program (2020) License & Copyright Copyright (c) 2020-, Sun Yat-sen University and The Hong Kong University of Science and Technology. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Acknowledgements"},{"location":"about/acknowledgement/#_1","text":"","title":""},{"location":"about/acknowledgement/#how-to-cite","text":"We do not have a paper for this extire library for now. Please cite one of our relevant works with @article{lai2021revisiting, title={Revisiting the GJK and shape erosion method for contact resolution in DEM}, author={Lai, Zhengshou and Zhao, Shiwei and Zhao, Jidong and Huang, Linchong}, journal={Powder Technology}, year={2021}, publisher={Elsevier} }","title":"How to cite"},{"location":"about/acknowledgement/#contributors","text":"We would like to thank all the peer researchers that have directly or indrectly made a contribution to this project, by means of submitting commits or pull requests, making suggestions or discussions, finding and resolving bugs or difficulties during usage, etc. We would also like to thank the authors of thrid party software packages (in dependencies ) that are used by this project and have greatly faciliated the development of this project.","title":"Contributors"},{"location":"about/acknowledgement/#fundings","text":"This project is under active development. The fundings that have supported the development of this project are acknowledged and will be updated accordingly. 2019-2022: National Natural Science Foundation of China (51909289) 2019-2021: China Postdoctoral Science Foundation (2019M663240) 2020-2022: Hong Kong Scholar program (2020)","title":"Fundings"},{"location":"about/acknowledgement/#license-copyright","text":"Copyright (c) 2020-, Sun Yat-sen University and The Hong Kong University of Science and Technology. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License &amp; Copyright"},{"location":"about/bugs_%26_feature_requests/","text":"There are varieties of features or functionalities can be implemented into the NetDEM to facilitate its application on scientific research or engineering production. If you have an interest to contribute to any part of this project, please let us know. The users are also cautioned that this code is under active development. If you need help using NetDEM, or have found a bug, please open an issue or submit a pull request . Known issues The compilation of mlpack and its relevant sources in netdem with debug option would consume a lot of memory (~10 G), wihch might cause computers breakdown if compiling with multiple thread. TODOs Servo control of wall does not work properly in MPI. In MPI, it will need the contact information from all domains. Will need to implement that. Implement rigid and soft bonds (i.e., clump vs. cluster) using evaluators. Python interfaces. Input mechanicsms. GPU.","title":"Help"},{"location":"about/bugs_%26_feature_requests/#_1","text":"There are varieties of features or functionalities can be implemented into the NetDEM to facilitate its application on scientific research or engineering production. If you have an interest to contribute to any part of this project, please let us know. The users are also cautioned that this code is under active development. If you need help using NetDEM, or have found a bug, please open an issue or submit a pull request .","title":""},{"location":"about/bugs_%26_feature_requests/#known-issues","text":"The compilation of mlpack and its relevant sources in netdem with debug option would consume a lot of memory (~10 G), wihch might cause computers breakdown if compiling with multiple thread.","title":"Known issues"},{"location":"about/bugs_%26_feature_requests/#todos","text":"Servo control of wall does not work properly in MPI. In MPI, it will need the contact information from all domains. Will need to implement that. Implement rigid and soft bonds (i.e., clump vs. cluster) using evaluators. Python interfaces. Input mechanicsms. GPU.","title":"TODOs"},{"location":"about/publications/","text":"2021 Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371.","title":"Publications"},{"location":"about/publications/#2021","text":"Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371.","title":"2021"},{"location":"documentation/code_algorithms/","text":"Code design General framework The program currently contains 7 modules: domain: Define the computational domain evaluator: Define some personalized calculations of the discrete element model, such as adding external forces, exporting data, etc. Because these personalized calculations are not required for every calculation model, they can be added to the model freely through this subscription method. Generally, the evaluator is defined first, and then attached to a simulation and activated. When the discrete element is calculated to a certain node, the subscribed evaluator will be called uniformly. Currently, two evaluators are defined: pre_evaluator and post_evaluator. pre_evaluator is called at the beginning of each calculation cycle, and post_evaluator is called at the end of each calculation cycle. input: Used to interpret the input file. It is planned to adopt the json format as the data exchange format. Each json object corresponds to a command, and the simulation is constructed or modified through the execution of the command. The commands in plan definition 6: create, get, set, fix, unfix, run. create: create objects such as shape, particle, wall, contact model, evaluator, etc. get: get object properties set: set object properties fix: Bind the defined evaluator to simulation to activate. unfix: Unbind the defined evalua to make it invalid. run: start discrete element calculation mpi: data interaction between different parallel computing cores scene: contains shape tmplates, particle, wall, contact model, evaluator, etc. solver: Discrete element solver utils: other tool functions Basic elements Particles: Particles have variables or attributes such as shape, position, speed, and force The movement of particles obeys Newton's law of motion The particles are in contact with each other to generate contact force, which is calculated according to the corresponding contact model Wall or boundary: The boundary has variables or attributes such as shape, position, and force The boundary is generally assumed to be massless, so there is no need to calculate - Newtonian motion, just update its position according to the preset motion law Contact: particle-to-particle, or particle-to-boundary contact with contact geometric characteristics, contact force and other attributes The contact model describes the relationship between contact force and contact geometric characteristics Calculation procedures The basic calculation process of discrete element (DEMSolver calculation process): Traverse all the \"particles\" in this calculation domain, and clear the force and torque to zero. Perform pre_evaluator, such as gravity. Traverse all the \"particles\" in this computational domain to determine whether its contours touch other computational domains: if so, use MPI to transfer its data to the computational domain, and create a new particle in the target computational domain based on the particle data, as The particle is a proxy in the target computing domain, and the proxy particle can come into contact with other particles. The particles in this computing domain are called \"particle agents to be sent\", and the particles in the target computing domain are called \"received particle agents\". Receive the \"particle agent\" data and create an instance of the particle agent: If this calculation domain already contains the id of the particle agent, find the particle pointer through particlem_map, and update the particle instance with the received particle agent data; If the id of the particle agent does not exist, create a new \"particle_ghost\" instance, and update the particle instance with the received particle agent data; Traverse the \"granular agent to be sent\" and send its corresponding \"contact data\" to the target computing domain. Receive contact data and create contact instances: Determine the pointer of the particle according to the particle id, and determine the pointer of the contact model according to the contact model id Determine whether the contact exists through the contact_pp_list of the particle If it exists, update the contact instance from the received contact data. If it does not exist, establish a contact first, and use the received particle agent data to update the particle instance, Traverse all contacts and set their updated to false. Divide the computational domain into grids, traverse all the \"particles\" and \"received particle agents\" in the computational domain, and classify them into each grid. The classification criteria are: If the circumscribed cube of the particle or particle agent contacts a certain grid, then the particle or particle agent is added to the grid. Traverse all grids: Traverse the particles and particle agents in this grid to determine whether they are in contact. If touched: Determine whether it was in contact at the previous time step If yes, find the contact instance, update its contact geometric features and contact force, and set the updated of the contact to true If not, create a new contact instance, initialize the contact geometric features and calculate the contact force, and set the updated of the contact to true Apply contact force to particles and boundaries Traverse the \"received particle agent\": Traverse the contact of the particle agent, if the updated state of the contact is true, use MPI to send the contact data back to the original computing domain Receive contacts returned from other computing domains and reconstruct contact instances If the contact already exists, use the returned data to update the original contact If the contact does not exist, create a new contact and rebuild the particle pointer in the contact If the particle exists in the computational domain, the particle pointer is found through particle_map and particle id. If the particle does not exist in the computational domain, create a new \"particle illusion\" and set the \"particle illusion\" pointer to the contact. Apply contact force to particles Traverse all contacts If its updated status is false, delete the contact; Traverse all particles - Update its speed, position and other attributes according to Newton's law of motion Add the partial_proxy_list to the particle_ghost_list and clear the partial_proxy_list According to the updated particle position, traverse each particle to determine whether it exceeds the calculation domain: If so, send its data to the new computational domain of the particle, and move the particle to particle_ghost_list. Receive the \"particle\" data and create an instance of the particle: If this calculation domain already contains the id of the particle, find the particle pointer through particlem_map, and update the particle instance with the received particle data; If the id of the particle does not exist, create a new particle instance and update the particle instance with the received particle data; Traverse particle_ghost_list If it is not in contact with any particles or boundaries, delete the \"particle phantom\" Perform post_evaluator, such as data output and other functions.","title":"Code algorithms"},{"location":"documentation/code_algorithms/#code-design","text":"","title":"Code design"},{"location":"documentation/code_algorithms/#general-framework","text":"The program currently contains 7 modules: domain: Define the computational domain evaluator: Define some personalized calculations of the discrete element model, such as adding external forces, exporting data, etc. Because these personalized calculations are not required for every calculation model, they can be added to the model freely through this subscription method. Generally, the evaluator is defined first, and then attached to a simulation and activated. When the discrete element is calculated to a certain node, the subscribed evaluator will be called uniformly. Currently, two evaluators are defined: pre_evaluator and post_evaluator. pre_evaluator is called at the beginning of each calculation cycle, and post_evaluator is called at the end of each calculation cycle. input: Used to interpret the input file. It is planned to adopt the json format as the data exchange format. Each json object corresponds to a command, and the simulation is constructed or modified through the execution of the command. The commands in plan definition 6: create, get, set, fix, unfix, run. create: create objects such as shape, particle, wall, contact model, evaluator, etc. get: get object properties set: set object properties fix: Bind the defined evaluator to simulation to activate. unfix: Unbind the defined evalua to make it invalid. run: start discrete element calculation mpi: data interaction between different parallel computing cores scene: contains shape tmplates, particle, wall, contact model, evaluator, etc. solver: Discrete element solver utils: other tool functions","title":"General framework"},{"location":"documentation/code_algorithms/#basic-elements","text":"Particles: Particles have variables or attributes such as shape, position, speed, and force The movement of particles obeys Newton's law of motion The particles are in contact with each other to generate contact force, which is calculated according to the corresponding contact model Wall or boundary: The boundary has variables or attributes such as shape, position, and force The boundary is generally assumed to be massless, so there is no need to calculate - Newtonian motion, just update its position according to the preset motion law Contact: particle-to-particle, or particle-to-boundary contact with contact geometric characteristics, contact force and other attributes The contact model describes the relationship between contact force and contact geometric characteristics","title":"Basic elements"},{"location":"documentation/code_algorithms/#calculation-procedures","text":"The basic calculation process of discrete element (DEMSolver calculation process): Traverse all the \"particles\" in this calculation domain, and clear the force and torque to zero. Perform pre_evaluator, such as gravity. Traverse all the \"particles\" in this computational domain to determine whether its contours touch other computational domains: if so, use MPI to transfer its data to the computational domain, and create a new particle in the target computational domain based on the particle data, as The particle is a proxy in the target computing domain, and the proxy particle can come into contact with other particles. The particles in this computing domain are called \"particle agents to be sent\", and the particles in the target computing domain are called \"received particle agents\". Receive the \"particle agent\" data and create an instance of the particle agent: If this calculation domain already contains the id of the particle agent, find the particle pointer through particlem_map, and update the particle instance with the received particle agent data; If the id of the particle agent does not exist, create a new \"particle_ghost\" instance, and update the particle instance with the received particle agent data; Traverse the \"granular agent to be sent\" and send its corresponding \"contact data\" to the target computing domain. Receive contact data and create contact instances: Determine the pointer of the particle according to the particle id, and determine the pointer of the contact model according to the contact model id Determine whether the contact exists through the contact_pp_list of the particle If it exists, update the contact instance from the received contact data. If it does not exist, establish a contact first, and use the received particle agent data to update the particle instance, Traverse all contacts and set their updated to false. Divide the computational domain into grids, traverse all the \"particles\" and \"received particle agents\" in the computational domain, and classify them into each grid. The classification criteria are: If the circumscribed cube of the particle or particle agent contacts a certain grid, then the particle or particle agent is added to the grid. Traverse all grids: Traverse the particles and particle agents in this grid to determine whether they are in contact. If touched: Determine whether it was in contact at the previous time step If yes, find the contact instance, update its contact geometric features and contact force, and set the updated of the contact to true If not, create a new contact instance, initialize the contact geometric features and calculate the contact force, and set the updated of the contact to true Apply contact force to particles and boundaries Traverse the \"received particle agent\": Traverse the contact of the particle agent, if the updated state of the contact is true, use MPI to send the contact data back to the original computing domain Receive contacts returned from other computing domains and reconstruct contact instances If the contact already exists, use the returned data to update the original contact If the contact does not exist, create a new contact and rebuild the particle pointer in the contact If the particle exists in the computational domain, the particle pointer is found through particle_map and particle id. If the particle does not exist in the computational domain, create a new \"particle illusion\" and set the \"particle illusion\" pointer to the contact. Apply contact force to particles Traverse all contacts If its updated status is false, delete the contact; Traverse all particles - Update its speed, position and other attributes according to Newton's law of motion Add the partial_proxy_list to the particle_ghost_list and clear the partial_proxy_list According to the updated particle position, traverse each particle to determine whether it exceeds the calculation domain: If so, send its data to the new computational domain of the particle, and move the particle to particle_ghost_list. Receive the \"particle\" data and create an instance of the particle: If this calculation domain already contains the id of the particle, find the particle pointer through particlem_map, and update the particle instance with the received particle data; If the id of the particle does not exist, create a new particle instance and update the particle instance with the received particle data; Traverse particle_ghost_list If it is not in contact with any particles or boundaries, delete the \"particle phantom\" Perform post_evaluator, such as data output and other functions.","title":"Calculation procedures"},{"location":"documentation/dem_manual/","text":"This section presents a brief introduction and review of the discrete element method (DEM). The intention is to introduce the main components and basic computational workflow of a DEM model, providing necessary background information to the research presented in this dissertation. Overview DEM is a particle-based numerical model that is particularly suitable for describing the mechanical behavior of bulk granular materials. It was first proposed by @Cundall.Strack:1979 for the analysis of geotechnical materials. Since then, DEM has been applied to model all kinds of granular materials and to simulate the problems ranging from solids handling to powder flowing in a variety of different engineering branches [@Cleary:2009; @Tijskens.etal:2003; @OSullivan:2011]. In DEM, all individual particles in the bulk granular material are explicitly modeled and a DEM model directly captures the interactions between particles and tracks the motions of each particle. The bulk behavior of a granular material is presented as an assembly of the actions (i.e., the interactions and motions) of all constituent particles. As a particle-based numerical model, DEM exhibits several advantages compared to the classical continuum theory-based numerical models. First, it bypasses the phenomenological constitutive models for describing the bulk behavior of a granular material within a representative volume [@Andrade.Avila:2012; @Andrade.etal:2012; @Guo.Zhao:2016]. Second, it is straightforward for the DEM to simulate the problems involving large deformation or material failure, such as granular flow, penetration, or strain localization [@Chen:2011]. The major drawback of DEM is also obvious. As DEM tracks the interactions and motions of all particles, DEM simulations are quite computationally expensive, which makes it difficult to scale up [@Liu.Hrenya:2014; @Berger.Hrenya:2014]. Nevertheless, with the advent of computer hardware and parallel capabilities, the DEM has become an increasingly powerful numerical tool that can provide valuable information of and shed lights upon the microscopic behavior of granular materials, which is often difficult or impossible to obtain from classical continuum-based numerical models or from physical experiments. Key components of DEM Basic elements In general, there are two types of basic elements in a DEM model: particles and boundaries. The basic elements are assumed to be rigid but can have overlaps with each other. A particle is a body that has a closed surface. It may be represented by a simple geometry (e.g., sphere or ellipsoid) or a composition of several simple geometries that make up the body surface (see further discussions in ). A review on the particle geometric representations can be found in [@Zhong.etal:2016]. Particles have mass and their motion (i.e., position, velocity, and acceleration) is always tracked during a DEM simulation. Boundaries are also referred to as walls in the DEM literature. They may as well be represented by simple geometries (e.g., triangles) or their combinations, but they do not necessarily have closed surfaces. Boundaries do not have mass and their position and velocity are usually prescribed to provide the desired constraints to the particles in the model. Contacts and contact models Contacts describe the interactions between basic elements. Contact occurs when the surfaces of two basic elements overlap with each other (to model collisions), or when the surfaces are within a specified distance (to model long-range bond or cohesion). Detecting the contacts between basic elements is a mathematical geometry problem and is one of the most time-consuming parts of a DEM simulation. One important task associated with contact detection is to characterize the contact geometric features, which are needed by a contact model to calculate the contact forces and moments. The contact features may include the overlapping (or indentation) distance, relative shear displacement, contact point, contact branch vectors, and so on. Contact models are used to calculate the contact forces and moments between the two elements in contact. Commonly used contact models include the linear elastic model [@Cundall.Strack:1979], the rolling resistance model [@Jiang.etal:2005], the Hertz-Mindlin model [@Hertz:1882; @Mindlin:1953; @Renzo.Maio:2005], and the linear parallel bond model [@Potyondy.Cundall:2004]. The formulation of these contact models will be presented in . Newton-Euler equations of motion In DEM, the motion of a particle can be described by the Newton-Euler equations of motion. For any arbitrarily-shaped particle, the Newton-Euler equations of motion are written as \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M}\\end{aligned} \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M}\\end{aligned} where m m is the mass of the particle; \\boldsymbol{I} \\boldsymbol{I} is the inertia tensor of the particle; \\boldsymbol{a} \\boldsymbol{a} and \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} are the translational and rotational acceleration; \\boldsymbol{F} \\boldsymbol{F} and \\boldsymbol{M} \\boldsymbol{M} are the overall external forces and moments acting on the particle; \\boldsymbol{\\omega} \\boldsymbol{\\omega} is the vector of the angular velocities about the principal axes. Herein, the variable in bold-symbol indicates a vector or a tensor. For spherical particles, the Newton-Euler equations of motion reduce to \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M}\\end{aligned} \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M}\\end{aligned} In order to resolve the motion of each particle, all the forces and moments acting on the particle need to be evaluated and summed, which may include gravity, damping, contact forces and moments, and prescribed external forces and moments. Herein, the damping refers to the global damping, which is sometimes (artificially) introduced in a DEM model to facilitate energy dissipation and enhance a quasi-static simulation [@Chung:2006; @PFC:2014]. There is another type of damping called local damping, which is usually incorporated into a contact model as dash-pot forces to account for the realistic energy dissipation due to particle interactions. Time integration To fully resolve the particle motion (e.g., the position and velocity) governed by and involves the time integration scheme, where the second-order Velocity Verlet algorithm [@Verlet:1967] is commonly adopted. For spherical particles, suppose that the current state is indexed by time t t and the time increment to the next state is \\Delta t \\Delta t , Velocity Verlet algorithm first calculates the particle velocities at time t t + \\Delta t/2 \\Delta t/2 by \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2\\end{aligned} \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2\\end{aligned} where \\boldsymbol{v} \\boldsymbol{v} and \\boldsymbol{\\omega} \\boldsymbol{\\omega} are translational and angular velocities, respectively. The superscripts (e.g., t t and \\Delta t/2 \\Delta t/2 ) indicate the time indexes. Then, the position and orientation of the particle at time t t + \\Delta t \\Delta t are calculated as \\begin{aligned} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{aligned} \\begin{aligned} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{aligned} where \\boldsymbol{x} \\boldsymbol{x} is the vector of position and \\boldsymbol{\\theta} \\boldsymbol{\\theta} is the vector of orientation. Correspondingly, the translational velocity and angular velocity at time t+\\Delta t t+\\Delta t are updated by \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{aligned} \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{aligned} For non-spherical particles, the original Newton-Euler equations of motion cannot be simplified, and the calculation of the orientations and angular velocity will be much more complicated. A more detailed discussion on the time integration for non-spherical particles will not be included here but can be found in the work of @Chung:2006 and the PFC user manual [@PFC:2014]. Critical timestep The time integration based on the second-order Velocity Verlet algorithm is numerically stable only when the time increment being used is less than a threshold value, i.e. the critical timestep [@Otsubo.etal:2017]. If a time increment greater than the critical timestep is used, particles may move too much in one increment, which will result in spuriously infinite overlapping (i.e., abnormally large contact forces). A summary and empirical assessment of different approaches to estimate the critical timestep for DEM simulations can be found in @Otsubo.etal:2017. Basically, there are two categories of approaches to estimate the critical timestep: the oscillation period of a single degree of freedom system (SDOF) based approaches [@Cundall.Strack:1979; @Hart.etal:1988], and the Rayleigh wave speed based approaches [@Thornton:2000; @Li.etal:2005]. The former approaches consider the DEM system to be consist of rigid bodies connected by springs, while the latter ones consider the particles themselves to be springs. In the category of the SDOF-based approaches, @Cundall.Strack:1979 proposed the following expression to estimate the critical timestep \\Delta t_\\text{crit} \\Delta t_\\text{crit} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) where m m is the mass of the particle; I_i I_i is the moment of inertia of the particle; k^\\text{tran} k^\\text{tran} and k_i^\\text{rot} k_i^\\text{rot} represent the translational and rotational stiffness, and the subscript i i indicates the index of principal components. In the category of the Rayleigh wave speed based approaches, @Li.etal:2005 proposed that \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} where R R is the average particle radius; \\rho \\rho is the particle density; G G the particle shear modulus; and \\nu \\nu the Poisson's ratio of the particle. Computational workflow DEM-based numerical simulations require cyclic calculations. shows the workflow and calculations that are involved in one typical cycle of a DEM simulation. The workflow and calculations for one DEM cycle can be summarized as follows: At the current state, the positions and velocities of all particles are known: based on the geometries of all particles, identify the inter-particle contacts and evaluate contact features; Calculate the external forces and moments of all particles, while the contact forces and moments are calculated based on selected contact models and the corresponding contact features; Calculate the motion (i.e., the accelerations) of all particles; Update the positions and velocities of all particles following the selected time integration scheme. Particle representation There are basically two groups of methods to represent an irregular particle in DEM [@Zhong.etal:2016]: single-particle method and composite-particle method. Single-particle method The single-particle method utilizes closed geometries to represent particle shapes. Many single-particle-based DEM models have been proposed and developed with the adoption of some specific closed geometries, such as cylinder [@Feng.etal:2017], polyhedron (or polygon in 2D) [@Nassauer.etal:2013; @Daddetta.etal:2002], ellipsoid (or ellipse in 2D) [@Lin.Ng:1997; @Ting.etal:1993], superquadrics [@Williams.Pentland:1992; @Podlozhnyuk.etal:2017], Non-Uniform Rational Basis Spline (NURBS) [@Andrade.etal:2012], as well as their combinations (e.g., poly-ellipsoid [@Peters.etal:2009; @Zhang.etal:2017]). Each of these methods has its own advantages and limitations. The application of the cylinder-based or ellipsoid-based DEM models is limited, due to the particular particle shapes they can represent. The superquadric can be considered as an extension of the ellipsoid and can be used for modeling of spheres, ellipsoids, cylinder-like and box(dice)-like particles by varying the shape parameters. It is more flexible by being able to model larger variations of particle shapes, but also more computationally expensive than the ellipsoid-based DEM models. The polyhedron- (or polygon in 2D) based DEM model is able to replicate arbitrary particle shapes. The accuracy of the shape represented by polyhedron depends on the number of faces in a polyhedron, whereas a large number of faces would hinder the computational efficiency. Moreover, polyhedron can rarely replicate a smooth particle shape. The NURBS based granular element method, developed by @Andrade.etal:2012, is advantageous to replicate general and smooth particle shapes, whereas it is computationally expensive compared to the polyhedron-based DEM. Recently, @Kawamoto.etal:2016 developed another novel type of single-particle-based DEM, which utilizes the level set (LS) method to represent particles. The LS-DEM seamlessly utilizes the level set data of realistic particle shapes characterized from X-ray computational tomography and is computationally efficient. One issue with the LS-DEM is high memory consumption, which somewhat limits its application on large particulate systems. Composite-particle method In a composite-particle method, a particle is represented by compositions of simple geometries (usually spheres in 3D or circles in 2D [@Das:2007; @Shi.etal:2015]). This group of methods is advantageous to implementation for that the contact detection and resolution algorithms for the simple geometries can be effortlessly exploited. It should be noted that the accuracy of particle shape represented by compositions of simple geometries depends on the amount of the simple geometries, and a large number of simple geometries would lead to great computational expense though. Nonetheless, the composite-particle method (especially with spheres as the base elements) is currently the most prevalent method to model irregular particles and is supported in most commercial or open-source DEM packages such as PFC [@PFC:2014] and LIGGGHTS [@Kloss.etal:2012]. There are three options to represent a composite particle [@Shi.etal:2015]: the domain overlapping filling method, the domain non-overlapping filling method, and the boundary filling method, as shown in with discs being used as the base elements, for instance. The composite particle generated by domain overlapping filling requires the least number of particles and is, therefore, the most computationally efficient. The domain non-overlapping filling method can be promoted to model physics-based particle deformation (e.g., compression, deflection or distortion) or breakage. The boundary filling method, depending on the size of filling elements, could provide a better representation of surface roughness. A schematic illustration of the three options to represent a composite particle with discs (modified after [@Shi.etal:2015]) Contact models A DEM contact model is normally comprised of springs, dash-pots, and sliders to describe the force-displacement behavior at the contact, where the springs account for normal and tangential forces, the dash-pots account for local damping, and the sliders account for shear failure. The formulation of contact models that will be used in this dissertation is presented in this section. Linear elastic model A linear elastic model generally consists of two elastic springs, two dash-pots, and a slider, as shown schematically in the following. The contact forces \\boldsymbol{F} \\boldsymbol{F} are calculated from two parts: the normal force \\boldsymbol{F}_n \\boldsymbol{F}_n and the shear (or tangential) force \\boldsymbol{F}_s \\boldsymbol{F}_s \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s where \\boldsymbol{n}_n \\boldsymbol{n}_n and \\boldsymbol{n}_s \\boldsymbol{n}_s are the unit vectors denoting the direction of the normal and the shear force, respectively; F_n F_n and F_s F_s are the magnitudes of corresponding contact forces. Assuming the relative displacement increment at the contact during a timestep \\Delta t \\Delta t is given by its components \\Delta \\delta_n \\Delta \\delta_n (compression as a positive) and \\Delta \\delta_s \\Delta \\delta_s , the contact law for a simple linear model with local damping updates the contact forces through [@Cundall.Strack:1979; @PFC:2014] \\begin{aligned}F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n)\\end{aligned} \\begin{aligned}F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n)\\end{aligned} where F_n^0 F_n^0 and F_s^0 F_s^0 are the normal and the shear forces at the beginning of the current timestep, respectively; k_n k_n and k_s k_s are the corresponding stiffness; \\eta_n \\eta_n and \\eta_s \\eta_s are the corresponding damping coefficients; \\dot{\\delta}_n \\dot{\\delta}_n and \\dot{\\delta}_s \\dot{\\delta}_s are the relative normal and shear velocity; \\mu_c \\mu_c is the contact friction coefficient; and \\bar{m} = m_im_j/(m_i+m_j) \\bar{m} = m_im_j/(m_i+m_j) is the effective mass of particles i i and j j associated with the contact, while \\bar{m} = m_i \\bar{m} = m_i for the case of particle-boundary contact. Rolling resistance model The rolling resistance model is built upon the linear elastic model by adding a term of rolling resistance moment to the contact moment. The formulation to calculate the additional rolling resistance moment can be written as [@Iwashita.Oda:1998; @Jiang.etal:2005; @PFC:2014] M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) where M^0 M^0 is the contact moment at the beginning of the current timestep; \\Delta\\theta_b \\Delta\\theta_b is the relative bending-rotation increment; \\mu_r \\mu_r is the rolling resistance coefficient; k_r k_r is the rolling resistance stiffness defined as: k_r = k_s\\bar{R}^2 k_r = k_s\\bar{R}^2 where \\bar{R} \\bar{R} is the contact effective radius defined as \\bar{R}=R_iR_j/(R_i+R_j) \\bar{R}=R_iR_j/(R_i+R_j) , in which R_i R_i and R_j R_j are the radii of the contact particles. If one side of the contact is a wall, the corresponding radius R_j \\rightarrow \\infty R_j \\rightarrow \\infty . This model uses a simplified formulation for the rolling kinematics, and the particle size effects on the rolling resistance are implicitly incorporated in the rolling stiffness term. The interested reader is referred to [@Luding:2008; @Wang.etal:2015] for examples of improved and more advanced rolling resistance models. Hertz-Mindlin model The Hertz-Mindlin model is a complete frictional contact model based upon the Hertz theory [@Hertz:1882] for contact normal forces and the Mindlin theory [@Mindlin:1953] for contact tangential forces. It takes into account the stiffness variation due to the change of contact areas during the collision of two elastic spheres. Similar to the linear elastic model, the Hertz-Mindlin model also consists of two springs, two dash-pots, and a slider. There are, however, two major differences. First, the normal and shear stiffness in the Hertz-Mindlin model are functions of the contact overlapping distance. Second, the normal contact force in the Hertz-Mindlin model is calculated via the cumulative overlapping distance, while the linear elastic model uses either the cumulative or incremental overlapping distance. To update the contact forces, the Hertz-Mindlin model follows \\begin{aligned} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{aligned} \\begin{aligned} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{aligned} where \\delta_n \\delta_n is the cumulative overlapping distance, while k_n k_n and k_s k_s are calculated as [@Renzo.Maio:2005]: \\begin{aligned} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{aligned} \\begin{aligned} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{aligned} in which \\begin{aligned} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{aligned} \\begin{aligned} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{aligned} where \\bar{E} \\bar{E} and \\bar{G} \\bar{G} are the effective Young's modulus and shear modulus of the particles in contact; E_i E_i is the Young's modulus and \\nu_i \\nu_i is the Poisson's ratio of the i i th particle. Linear parallel bond model The linear parallel bond model describes the contact behavior of two bonded particles, as shown schematically in the following. In the linear parallel bond model, the bond between two spheres is assumed to be a cylinder of finite radius and thickness. Each point in the bond is imposed by two linear elastic springs providing normal and shear resistances, respectively. The overall bonding force and moment are the integral of the normal and shear stresses at a cross-section of the bond, which can be calculated as [@Potyondy.Cundall:2004] \\begin{aligned} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s\\end{aligned} \\begin{aligned} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s\\end{aligned} where F_n^b F_n^b , F_s^b F_s^b , M_n^b M_n^b and M_s^b M_s^b are the bond normal force, shear force, twisting moment, and swinging moment, respectively; \\delta_n \\delta_n , \\delta_s \\delta_s , \\theta_n \\theta_n , and \\theta_s \\theta_s are the relative normal displacement, shear displacement, twisting rotation, and swinging rotation between the two bonded spheres, respectively; A A , I I , and J J are the area, moment of inertia, and polar moment of inertia of the bond (i.e., the circular cross-section with radius R^b R^b ), respectively; and \\Delta \\Delta indicates the increment of each variable in each time step. It should be pointed out that, while the damping is not included in the current formulation, damping terms similar to those in the linear elastic model can be incorporated in a straightforward manner. The bonded-sphere model is also capable of modeling the particle breakage behavior. As an example of a common bond breakage criterion, it can be assumed that a bond would break if the maximum normal or shear stress at the bond exceeds the corresponding normal or shear strength. In the linear parallel bond model, both the normal force and swinging moment contribute to the normal stress, while both the shear force and twisting moment contribute to the shear stress. In this regard, the bond breakage criterion can be written as \\begin{aligned} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{aligned} \\begin{aligned} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{aligned} where \\sigma_{Y,n}^b \\sigma_{Y,n}^b and \\sigma_{Y,s}^b \\sigma_{Y,s}^b are the normal and shear strength, respectively. Model calibration As most of the contact parameters in a DEM model are difficult if not impossible to be measured directly from physical tests, a calibration process is often needed to obtain the contact parameters for a specific material of interest. There are some researches available on the procedures to calibrate contact parameters for a DEM model [@Plassiard.etal:2009; @Chehreghani.etal:2017; @Coetzee:2017]. Usually, the calibration process is accomplished by performing parametric studies on each of contact parameters and selecting values of the contact parameters with which the DEM simulation can reproduce the benchmark matrices of laboratory experiments. Commonly used laboratory experiments for calibration of DEM parameters include compression test, direct and ring shear test, and angle of repose test. Descriptions of these tests can be found in [@Schulze:2008; @Coetzee:2017]. There are some challenges and problems associated with the model calibration. First, to obtain reasonable and realistic contact parameters via calibration, it is necessary that the setup and procedures in the DEM models are to the most extent similar to those in the laboratory experiments. However, in order to get the DEM simulations performed within affordable computational resources, adjustments or tolerances in the particle size, shape or testing speed may exist in a DEM model. As a result, the calibrated contact parameters may deviate from their actual values to some degree. In addition, the contact features and contact models are usually quite simple and conceptual compared to the actual complex contact behavior. The physical meaning of the contact parameters may be lost due to the use of conceptualized contact features and contact models. Lastly, as pointed out in [@Coetzee:2017], the solution of contact parameters might not be unique since all contact parameters may affect the results of a DEM simulation in a complex and highly nonlinear manner. There is no guarantee that the contact parameters for a material calibrated for one experiment will be workable for another. In this regard, it would be necessary to perform the calibration with one experiment and validate the calibration results via another. \\bibliography","title":"DEM manual"},{"location":"documentation/dem_manual/#_1","text":"This section presents a brief introduction and review of the discrete element method (DEM). The intention is to introduce the main components and basic computational workflow of a DEM model, providing necessary background information to the research presented in this dissertation.","title":""},{"location":"documentation/dem_manual/#overview","text":"DEM is a particle-based numerical model that is particularly suitable for describing the mechanical behavior of bulk granular materials. It was first proposed by @Cundall.Strack:1979 for the analysis of geotechnical materials. Since then, DEM has been applied to model all kinds of granular materials and to simulate the problems ranging from solids handling to powder flowing in a variety of different engineering branches [@Cleary:2009; @Tijskens.etal:2003; @OSullivan:2011]. In DEM, all individual particles in the bulk granular material are explicitly modeled and a DEM model directly captures the interactions between particles and tracks the motions of each particle. The bulk behavior of a granular material is presented as an assembly of the actions (i.e., the interactions and motions) of all constituent particles. As a particle-based numerical model, DEM exhibits several advantages compared to the classical continuum theory-based numerical models. First, it bypasses the phenomenological constitutive models for describing the bulk behavior of a granular material within a representative volume [@Andrade.Avila:2012; @Andrade.etal:2012; @Guo.Zhao:2016]. Second, it is straightforward for the DEM to simulate the problems involving large deformation or material failure, such as granular flow, penetration, or strain localization [@Chen:2011]. The major drawback of DEM is also obvious. As DEM tracks the interactions and motions of all particles, DEM simulations are quite computationally expensive, which makes it difficult to scale up [@Liu.Hrenya:2014; @Berger.Hrenya:2014]. Nevertheless, with the advent of computer hardware and parallel capabilities, the DEM has become an increasingly powerful numerical tool that can provide valuable information of and shed lights upon the microscopic behavior of granular materials, which is often difficult or impossible to obtain from classical continuum-based numerical models or from physical experiments.","title":"Overview"},{"location":"documentation/dem_manual/#key-components-of-dem","text":"","title":"Key components of DEM"},{"location":"documentation/dem_manual/#basic-elements","text":"In general, there are two types of basic elements in a DEM model: particles and boundaries. The basic elements are assumed to be rigid but can have overlaps with each other. A particle is a body that has a closed surface. It may be represented by a simple geometry (e.g., sphere or ellipsoid) or a composition of several simple geometries that make up the body surface (see further discussions in ). A review on the particle geometric representations can be found in [@Zhong.etal:2016]. Particles have mass and their motion (i.e., position, velocity, and acceleration) is always tracked during a DEM simulation. Boundaries are also referred to as walls in the DEM literature. They may as well be represented by simple geometries (e.g., triangles) or their combinations, but they do not necessarily have closed surfaces. Boundaries do not have mass and their position and velocity are usually prescribed to provide the desired constraints to the particles in the model.","title":"Basic elements"},{"location":"documentation/dem_manual/#contacts-and-contact-models","text":"Contacts describe the interactions between basic elements. Contact occurs when the surfaces of two basic elements overlap with each other (to model collisions), or when the surfaces are within a specified distance (to model long-range bond or cohesion). Detecting the contacts between basic elements is a mathematical geometry problem and is one of the most time-consuming parts of a DEM simulation. One important task associated with contact detection is to characterize the contact geometric features, which are needed by a contact model to calculate the contact forces and moments. The contact features may include the overlapping (or indentation) distance, relative shear displacement, contact point, contact branch vectors, and so on. Contact models are used to calculate the contact forces and moments between the two elements in contact. Commonly used contact models include the linear elastic model [@Cundall.Strack:1979], the rolling resistance model [@Jiang.etal:2005], the Hertz-Mindlin model [@Hertz:1882; @Mindlin:1953; @Renzo.Maio:2005], and the linear parallel bond model [@Potyondy.Cundall:2004]. The formulation of these contact models will be presented in .","title":"Contacts and contact models"},{"location":"documentation/dem_manual/#newton-euler-equations-of-motion","text":"In DEM, the motion of a particle can be described by the Newton-Euler equations of motion. For any arbitrarily-shaped particle, the Newton-Euler equations of motion are written as \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M}\\end{aligned} \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M}\\end{aligned} where m m is the mass of the particle; \\boldsymbol{I} \\boldsymbol{I} is the inertia tensor of the particle; \\boldsymbol{a} \\boldsymbol{a} and \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} are the translational and rotational acceleration; \\boldsymbol{F} \\boldsymbol{F} and \\boldsymbol{M} \\boldsymbol{M} are the overall external forces and moments acting on the particle; \\boldsymbol{\\omega} \\boldsymbol{\\omega} is the vector of the angular velocities about the principal axes. Herein, the variable in bold-symbol indicates a vector or a tensor. For spherical particles, the Newton-Euler equations of motion reduce to \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M}\\end{aligned} \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M}\\end{aligned} In order to resolve the motion of each particle, all the forces and moments acting on the particle need to be evaluated and summed, which may include gravity, damping, contact forces and moments, and prescribed external forces and moments. Herein, the damping refers to the global damping, which is sometimes (artificially) introduced in a DEM model to facilitate energy dissipation and enhance a quasi-static simulation [@Chung:2006; @PFC:2014]. There is another type of damping called local damping, which is usually incorporated into a contact model as dash-pot forces to account for the realistic energy dissipation due to particle interactions.","title":"Newton-Euler equations of motion"},{"location":"documentation/dem_manual/#time-integration","text":"To fully resolve the particle motion (e.g., the position and velocity) governed by and involves the time integration scheme, where the second-order Velocity Verlet algorithm [@Verlet:1967] is commonly adopted. For spherical particles, suppose that the current state is indexed by time t t and the time increment to the next state is \\Delta t \\Delta t , Velocity Verlet algorithm first calculates the particle velocities at time t t + \\Delta t/2 \\Delta t/2 by \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2\\end{aligned} \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2\\end{aligned} where \\boldsymbol{v} \\boldsymbol{v} and \\boldsymbol{\\omega} \\boldsymbol{\\omega} are translational and angular velocities, respectively. The superscripts (e.g., t t and \\Delta t/2 \\Delta t/2 ) indicate the time indexes. Then, the position and orientation of the particle at time t t + \\Delta t \\Delta t are calculated as \\begin{aligned} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{aligned} \\begin{aligned} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{aligned} where \\boldsymbol{x} \\boldsymbol{x} is the vector of position and \\boldsymbol{\\theta} \\boldsymbol{\\theta} is the vector of orientation. Correspondingly, the translational velocity and angular velocity at time t+\\Delta t t+\\Delta t are updated by \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{aligned} \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{aligned} For non-spherical particles, the original Newton-Euler equations of motion cannot be simplified, and the calculation of the orientations and angular velocity will be much more complicated. A more detailed discussion on the time integration for non-spherical particles will not be included here but can be found in the work of @Chung:2006 and the PFC user manual [@PFC:2014].","title":"Time integration"},{"location":"documentation/dem_manual/#critical-timestep","text":"The time integration based on the second-order Velocity Verlet algorithm is numerically stable only when the time increment being used is less than a threshold value, i.e. the critical timestep [@Otsubo.etal:2017]. If a time increment greater than the critical timestep is used, particles may move too much in one increment, which will result in spuriously infinite overlapping (i.e., abnormally large contact forces). A summary and empirical assessment of different approaches to estimate the critical timestep for DEM simulations can be found in @Otsubo.etal:2017. Basically, there are two categories of approaches to estimate the critical timestep: the oscillation period of a single degree of freedom system (SDOF) based approaches [@Cundall.Strack:1979; @Hart.etal:1988], and the Rayleigh wave speed based approaches [@Thornton:2000; @Li.etal:2005]. The former approaches consider the DEM system to be consist of rigid bodies connected by springs, while the latter ones consider the particles themselves to be springs. In the category of the SDOF-based approaches, @Cundall.Strack:1979 proposed the following expression to estimate the critical timestep \\Delta t_\\text{crit} \\Delta t_\\text{crit} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) where m m is the mass of the particle; I_i I_i is the moment of inertia of the particle; k^\\text{tran} k^\\text{tran} and k_i^\\text{rot} k_i^\\text{rot} represent the translational and rotational stiffness, and the subscript i i indicates the index of principal components. In the category of the Rayleigh wave speed based approaches, @Li.etal:2005 proposed that \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} where R R is the average particle radius; \\rho \\rho is the particle density; G G the particle shear modulus; and \\nu \\nu the Poisson's ratio of the particle.","title":"Critical timestep"},{"location":"documentation/dem_manual/#computational-workflow","text":"DEM-based numerical simulations require cyclic calculations. shows the workflow and calculations that are involved in one typical cycle of a DEM simulation. The workflow and calculations for one DEM cycle can be summarized as follows: At the current state, the positions and velocities of all particles are known: based on the geometries of all particles, identify the inter-particle contacts and evaluate contact features; Calculate the external forces and moments of all particles, while the contact forces and moments are calculated based on selected contact models and the corresponding contact features; Calculate the motion (i.e., the accelerations) of all particles; Update the positions and velocities of all particles following the selected time integration scheme.","title":"Computational workflow"},{"location":"documentation/dem_manual/#particle-representation","text":"There are basically two groups of methods to represent an irregular particle in DEM [@Zhong.etal:2016]: single-particle method and composite-particle method.","title":"Particle representation"},{"location":"documentation/dem_manual/#single-particle-method","text":"The single-particle method utilizes closed geometries to represent particle shapes. Many single-particle-based DEM models have been proposed and developed with the adoption of some specific closed geometries, such as cylinder [@Feng.etal:2017], polyhedron (or polygon in 2D) [@Nassauer.etal:2013; @Daddetta.etal:2002], ellipsoid (or ellipse in 2D) [@Lin.Ng:1997; @Ting.etal:1993], superquadrics [@Williams.Pentland:1992; @Podlozhnyuk.etal:2017], Non-Uniform Rational Basis Spline (NURBS) [@Andrade.etal:2012], as well as their combinations (e.g., poly-ellipsoid [@Peters.etal:2009; @Zhang.etal:2017]). Each of these methods has its own advantages and limitations. The application of the cylinder-based or ellipsoid-based DEM models is limited, due to the particular particle shapes they can represent. The superquadric can be considered as an extension of the ellipsoid and can be used for modeling of spheres, ellipsoids, cylinder-like and box(dice)-like particles by varying the shape parameters. It is more flexible by being able to model larger variations of particle shapes, but also more computationally expensive than the ellipsoid-based DEM models. The polyhedron- (or polygon in 2D) based DEM model is able to replicate arbitrary particle shapes. The accuracy of the shape represented by polyhedron depends on the number of faces in a polyhedron, whereas a large number of faces would hinder the computational efficiency. Moreover, polyhedron can rarely replicate a smooth particle shape. The NURBS based granular element method, developed by @Andrade.etal:2012, is advantageous to replicate general and smooth particle shapes, whereas it is computationally expensive compared to the polyhedron-based DEM. Recently, @Kawamoto.etal:2016 developed another novel type of single-particle-based DEM, which utilizes the level set (LS) method to represent particles. The LS-DEM seamlessly utilizes the level set data of realistic particle shapes characterized from X-ray computational tomography and is computationally efficient. One issue with the LS-DEM is high memory consumption, which somewhat limits its application on large particulate systems.","title":"Single-particle method"},{"location":"documentation/dem_manual/#composite-particle-method","text":"In a composite-particle method, a particle is represented by compositions of simple geometries (usually spheres in 3D or circles in 2D [@Das:2007; @Shi.etal:2015]). This group of methods is advantageous to implementation for that the contact detection and resolution algorithms for the simple geometries can be effortlessly exploited. It should be noted that the accuracy of particle shape represented by compositions of simple geometries depends on the amount of the simple geometries, and a large number of simple geometries would lead to great computational expense though. Nonetheless, the composite-particle method (especially with spheres as the base elements) is currently the most prevalent method to model irregular particles and is supported in most commercial or open-source DEM packages such as PFC [@PFC:2014] and LIGGGHTS [@Kloss.etal:2012]. There are three options to represent a composite particle [@Shi.etal:2015]: the domain overlapping filling method, the domain non-overlapping filling method, and the boundary filling method, as shown in with discs being used as the base elements, for instance. The composite particle generated by domain overlapping filling requires the least number of particles and is, therefore, the most computationally efficient. The domain non-overlapping filling method can be promoted to model physics-based particle deformation (e.g., compression, deflection or distortion) or breakage. The boundary filling method, depending on the size of filling elements, could provide a better representation of surface roughness. A schematic illustration of the three options to represent a composite particle with discs (modified after [@Shi.etal:2015])","title":"Composite-particle method"},{"location":"documentation/dem_manual/#contact-models","text":"A DEM contact model is normally comprised of springs, dash-pots, and sliders to describe the force-displacement behavior at the contact, where the springs account for normal and tangential forces, the dash-pots account for local damping, and the sliders account for shear failure. The formulation of contact models that will be used in this dissertation is presented in this section.","title":"Contact models"},{"location":"documentation/dem_manual/#linear-elastic-model","text":"A linear elastic model generally consists of two elastic springs, two dash-pots, and a slider, as shown schematically in the following. The contact forces \\boldsymbol{F} \\boldsymbol{F} are calculated from two parts: the normal force \\boldsymbol{F}_n \\boldsymbol{F}_n and the shear (or tangential) force \\boldsymbol{F}_s \\boldsymbol{F}_s \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s where \\boldsymbol{n}_n \\boldsymbol{n}_n and \\boldsymbol{n}_s \\boldsymbol{n}_s are the unit vectors denoting the direction of the normal and the shear force, respectively; F_n F_n and F_s F_s are the magnitudes of corresponding contact forces. Assuming the relative displacement increment at the contact during a timestep \\Delta t \\Delta t is given by its components \\Delta \\delta_n \\Delta \\delta_n (compression as a positive) and \\Delta \\delta_s \\Delta \\delta_s , the contact law for a simple linear model with local damping updates the contact forces through [@Cundall.Strack:1979; @PFC:2014] \\begin{aligned}F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n)\\end{aligned} \\begin{aligned}F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n)\\end{aligned} where F_n^0 F_n^0 and F_s^0 F_s^0 are the normal and the shear forces at the beginning of the current timestep, respectively; k_n k_n and k_s k_s are the corresponding stiffness; \\eta_n \\eta_n and \\eta_s \\eta_s are the corresponding damping coefficients; \\dot{\\delta}_n \\dot{\\delta}_n and \\dot{\\delta}_s \\dot{\\delta}_s are the relative normal and shear velocity; \\mu_c \\mu_c is the contact friction coefficient; and \\bar{m} = m_im_j/(m_i+m_j) \\bar{m} = m_im_j/(m_i+m_j) is the effective mass of particles i i and j j associated with the contact, while \\bar{m} = m_i \\bar{m} = m_i for the case of particle-boundary contact.","title":"Linear elastic model"},{"location":"documentation/dem_manual/#rolling-resistance-model","text":"The rolling resistance model is built upon the linear elastic model by adding a term of rolling resistance moment to the contact moment. The formulation to calculate the additional rolling resistance moment can be written as [@Iwashita.Oda:1998; @Jiang.etal:2005; @PFC:2014] M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) where M^0 M^0 is the contact moment at the beginning of the current timestep; \\Delta\\theta_b \\Delta\\theta_b is the relative bending-rotation increment; \\mu_r \\mu_r is the rolling resistance coefficient; k_r k_r is the rolling resistance stiffness defined as: k_r = k_s\\bar{R}^2 k_r = k_s\\bar{R}^2 where \\bar{R} \\bar{R} is the contact effective radius defined as \\bar{R}=R_iR_j/(R_i+R_j) \\bar{R}=R_iR_j/(R_i+R_j) , in which R_i R_i and R_j R_j are the radii of the contact particles. If one side of the contact is a wall, the corresponding radius R_j \\rightarrow \\infty R_j \\rightarrow \\infty . This model uses a simplified formulation for the rolling kinematics, and the particle size effects on the rolling resistance are implicitly incorporated in the rolling stiffness term. The interested reader is referred to [@Luding:2008; @Wang.etal:2015] for examples of improved and more advanced rolling resistance models.","title":"Rolling resistance model"},{"location":"documentation/dem_manual/#hertz-mindlin-model","text":"The Hertz-Mindlin model is a complete frictional contact model based upon the Hertz theory [@Hertz:1882] for contact normal forces and the Mindlin theory [@Mindlin:1953] for contact tangential forces. It takes into account the stiffness variation due to the change of contact areas during the collision of two elastic spheres. Similar to the linear elastic model, the Hertz-Mindlin model also consists of two springs, two dash-pots, and a slider. There are, however, two major differences. First, the normal and shear stiffness in the Hertz-Mindlin model are functions of the contact overlapping distance. Second, the normal contact force in the Hertz-Mindlin model is calculated via the cumulative overlapping distance, while the linear elastic model uses either the cumulative or incremental overlapping distance. To update the contact forces, the Hertz-Mindlin model follows \\begin{aligned} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{aligned} \\begin{aligned} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{aligned} where \\delta_n \\delta_n is the cumulative overlapping distance, while k_n k_n and k_s k_s are calculated as [@Renzo.Maio:2005]: \\begin{aligned} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{aligned} \\begin{aligned} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{aligned} in which \\begin{aligned} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{aligned} \\begin{aligned} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{aligned} where \\bar{E} \\bar{E} and \\bar{G} \\bar{G} are the effective Young's modulus and shear modulus of the particles in contact; E_i E_i is the Young's modulus and \\nu_i \\nu_i is the Poisson's ratio of the i i th particle.","title":"Hertz-Mindlin model"},{"location":"documentation/dem_manual/#linear-parallel-bond-model","text":"The linear parallel bond model describes the contact behavior of two bonded particles, as shown schematically in the following. In the linear parallel bond model, the bond between two spheres is assumed to be a cylinder of finite radius and thickness. Each point in the bond is imposed by two linear elastic springs providing normal and shear resistances, respectively. The overall bonding force and moment are the integral of the normal and shear stresses at a cross-section of the bond, which can be calculated as [@Potyondy.Cundall:2004] \\begin{aligned} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s\\end{aligned} \\begin{aligned} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s\\end{aligned} where F_n^b F_n^b , F_s^b F_s^b , M_n^b M_n^b and M_s^b M_s^b are the bond normal force, shear force, twisting moment, and swinging moment, respectively; \\delta_n \\delta_n , \\delta_s \\delta_s , \\theta_n \\theta_n , and \\theta_s \\theta_s are the relative normal displacement, shear displacement, twisting rotation, and swinging rotation between the two bonded spheres, respectively; A A , I I , and J J are the area, moment of inertia, and polar moment of inertia of the bond (i.e., the circular cross-section with radius R^b R^b ), respectively; and \\Delta \\Delta indicates the increment of each variable in each time step. It should be pointed out that, while the damping is not included in the current formulation, damping terms similar to those in the linear elastic model can be incorporated in a straightforward manner. The bonded-sphere model is also capable of modeling the particle breakage behavior. As an example of a common bond breakage criterion, it can be assumed that a bond would break if the maximum normal or shear stress at the bond exceeds the corresponding normal or shear strength. In the linear parallel bond model, both the normal force and swinging moment contribute to the normal stress, while both the shear force and twisting moment contribute to the shear stress. In this regard, the bond breakage criterion can be written as \\begin{aligned} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{aligned} \\begin{aligned} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{aligned} where \\sigma_{Y,n}^b \\sigma_{Y,n}^b and \\sigma_{Y,s}^b \\sigma_{Y,s}^b are the normal and shear strength, respectively.","title":"Linear parallel bond model"},{"location":"documentation/dem_manual/#model-calibration","text":"As most of the contact parameters in a DEM model are difficult if not impossible to be measured directly from physical tests, a calibration process is often needed to obtain the contact parameters for a specific material of interest. There are some researches available on the procedures to calibrate contact parameters for a DEM model [@Plassiard.etal:2009; @Chehreghani.etal:2017; @Coetzee:2017]. Usually, the calibration process is accomplished by performing parametric studies on each of contact parameters and selecting values of the contact parameters with which the DEM simulation can reproduce the benchmark matrices of laboratory experiments. Commonly used laboratory experiments for calibration of DEM parameters include compression test, direct and ring shear test, and angle of repose test. Descriptions of these tests can be found in [@Schulze:2008; @Coetzee:2017]. There are some challenges and problems associated with the model calibration. First, to obtain reasonable and realistic contact parameters via calibration, it is necessary that the setup and procedures in the DEM models are to the most extent similar to those in the laboratory experiments. However, in order to get the DEM simulations performed within affordable computational resources, adjustments or tolerances in the particle size, shape or testing speed may exist in a DEM model. As a result, the calibrated contact parameters may deviate from their actual values to some degree. In addition, the contact features and contact models are usually quite simple and conceptual compared to the actual complex contact behavior. The physical meaning of the contact parameters may be lost due to the use of conceptualized contact features and contact models. Lastly, as pointed out in [@Coetzee:2017], the solution of contact parameters might not be unique since all contact parameters may affect the results of a DEM simulation in a complex and highly nonlinear manner. There is no guarantee that the contact parameters for a material calibrated for one experiment will be workable for another. In this regard, it would be necessary to perform the calibration with one experiment and validate the calibration results via another. \\bibliography","title":"Model calibration"},{"location":"documentation/developer_manual/","text":"Coding style We generally follow Google C++ Style Guide . Naming Filenames: lowercase words connected by underscores, e.g. particle.hpp , contact_pp.cpp . Variable names: lowercase words connected by underscores, e.g. dir_n . Class and struct names: words with first letters capitalized, e.g. DataDumper . Macros: should be capital, such as PI . Comment Comment is not a requisite, but please add it if an attribute or method is not self-explainary or is ambigious. We use doxygen to generate the code documentation. We suggest the following comment format. Block documentation (e.g., for class description): /** descriptions */ Line documentation: /// descriptions Other commands if approperiate: @warning {warning message}, @todo {things to be done}, @bug , @brief, @var\u3001@enum\u3001@struct\u3001@class\u3001 Formatting Use clang-format . Programing rules Use auto for local variables when appropriate. Mark const when appropriate. Reference vs. pointer: If a variable will not be altered after calling the function, use reference with const mark, e.g., const double &[variable] . If a variable will be altered, use pointer. For int or double, as well as lists of int or double, mark with const (e.g., double *const [variable] ) to aboid mistakenly modifying the pointer. If a variable will not be altered but its value will be passed and stored the calling instance, use pointer. Following the previous item, if you are going to modify a variable, please declare it or passing it as an argument with with & . Prefer use c++ std library rather than c library, e.g., use <cmath> rather than <math.h> . Avoid using smart pointers, such as std::unique_ptr , std::shared_ptr . Never ever use \"using\" (e.g., using namespace std ) in headers . Performance evaluation Procedures Tool: linux perf To probe the performance\uff1a sudo perf stat build/bin/tmp_debug Performance counter stats for 'build/bin/tmp_debug': 12,639.97 msec task-clock # 0.983 CPUs utilized 1,284 context-switches # 0.102 K/sec 42 cpu-migrations # 0.003 K/sec 13,356 page-faults # 0.001 M/sec 26,566,855,696 cycles # 2.102 GHz 56,713,820,846 instructions # 2.13 insn per cycle 10,275,875,523 branches # 812.967 M/sec 31,362,265 branch-misses # 0.31% of all branches 12.857522834 seconds time elapsed 11.472000000 seconds user 1.120000000 seconds sys To sample CPU usage: sudo perf record -e task-clock -g build/bin/tmp_debug sudo perf report -i perf.data To generate heat map and visual: git clone --depth 1 https://github.com/brendangregg/FlameGraph.git FlameGraph/stackcollapse-perf.pl out.perf > out.folded FlameGraph/flamegraph.pl out.folded > out.svg sudo perf script > out.perf # then upload out.perf to https://www.speedscope.app/ to visual","title":"Developer manual"},{"location":"documentation/developer_manual/#coding-style","text":"We generally follow Google C++ Style Guide .","title":"Coding style"},{"location":"documentation/developer_manual/#naming","text":"Filenames: lowercase words connected by underscores, e.g. particle.hpp , contact_pp.cpp . Variable names: lowercase words connected by underscores, e.g. dir_n . Class and struct names: words with first letters capitalized, e.g. DataDumper . Macros: should be capital, such as PI .","title":"Naming"},{"location":"documentation/developer_manual/#comment","text":"Comment is not a requisite, but please add it if an attribute or method is not self-explainary or is ambigious. We use doxygen to generate the code documentation. We suggest the following comment format. Block documentation (e.g., for class description): /** descriptions */ Line documentation: /// descriptions Other commands if approperiate: @warning {warning message}, @todo {things to be done}, @bug , @brief, @var\u3001@enum\u3001@struct\u3001@class\u3001","title":"Comment"},{"location":"documentation/developer_manual/#formatting","text":"Use clang-format .","title":"Formatting"},{"location":"documentation/developer_manual/#programing-rules","text":"Use auto for local variables when appropriate. Mark const when appropriate. Reference vs. pointer: If a variable will not be altered after calling the function, use reference with const mark, e.g., const double &[variable] . If a variable will be altered, use pointer. For int or double, as well as lists of int or double, mark with const (e.g., double *const [variable] ) to aboid mistakenly modifying the pointer. If a variable will not be altered but its value will be passed and stored the calling instance, use pointer. Following the previous item, if you are going to modify a variable, please declare it or passing it as an argument with with & . Prefer use c++ std library rather than c library, e.g., use <cmath> rather than <math.h> . Avoid using smart pointers, such as std::unique_ptr , std::shared_ptr . Never ever use \"using\" (e.g., using namespace std ) in headers .","title":"Programing rules"},{"location":"documentation/developer_manual/#performance-evaluation","text":"","title":"Performance evaluation"},{"location":"documentation/developer_manual/#procedures","text":"Tool: linux perf To probe the performance\uff1a sudo perf stat build/bin/tmp_debug Performance counter stats for 'build/bin/tmp_debug': 12,639.97 msec task-clock # 0.983 CPUs utilized 1,284 context-switches # 0.102 K/sec 42 cpu-migrations # 0.003 K/sec 13,356 page-faults # 0.001 M/sec 26,566,855,696 cycles # 2.102 GHz 56,713,820,846 instructions # 2.13 insn per cycle 10,275,875,523 branches # 812.967 M/sec 31,362,265 branch-misses # 0.31% of all branches 12.857522834 seconds time elapsed 11.472000000 seconds user 1.120000000 seconds sys To sample CPU usage: sudo perf record -e task-clock -g build/bin/tmp_debug sudo perf report -i perf.data To generate heat map and visual: git clone --depth 1 https://github.com/brendangregg/FlameGraph.git FlameGraph/stackcollapse-perf.pl out.perf > out.folded FlameGraph/flamegraph.pl out.folded > out.svg sudo perf script > out.perf # then upload out.perf to https://www.speedscope.app/ to visual","title":"Procedures"},{"location":"documentation/installation/","text":"Install Prerequisites: The compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt install build-essential sudo apt-get install -y autoconf-archive automake cmake texinfo sudo apt-get install openmpi-bin libopenmpi-dev libboost-all-dev Compile and build: make sync_submodule make If some third-party libraries have not been or cannot be downloaded successfully, you can delete them and do a git checkout contrib and make sync_submodule again. Test the installation: ./scripts/run_tests.sh Dependencies git , gcc , cmake : for code developing, configuring and compiling mpich or open mpi : for parallel computing json : for input data interchange cork : for mesh boolean operation gmp igl : another option of mesh boolean operation (robust but much slower than cork) cgal (requires boost , gmp , mpfr ), openmp , eigen googletest : for tests mlpack : for machine learning libraries armadillo (requires lapack , arpack , openblas ), ensmallen , cereal , boost , stb Using dependencies already in the system would save the time required by the compilation of the whole project. Some dependencies (e.g., mlpack) would take fairly long time to compile. One can check out the log files in contrib/[package]/ep/src/[package]-stamp/ for the compiling, building and installing progresses of the dependencies. Some packages (e.g., boost and mpi ) could take forever to compile. It is recommended that you install pre-build boost and mpi using tools such as brew install in mac os, or apt-get install in ubantu.","title":"Installation"},{"location":"documentation/installation/#_1","text":"","title":""},{"location":"documentation/installation/#install","text":"","title":"Install"},{"location":"documentation/installation/#prerequisites","text":"The compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt install build-essential sudo apt-get install -y autoconf-archive automake cmake texinfo sudo apt-get install openmpi-bin libopenmpi-dev libboost-all-dev","title":"Prerequisites:"},{"location":"documentation/installation/#compile-and-build","text":"make sync_submodule make If some third-party libraries have not been or cannot be downloaded successfully, you can delete them and do a git checkout contrib and make sync_submodule again.","title":"Compile and build:"},{"location":"documentation/installation/#test-the-installation","text":"./scripts/run_tests.sh","title":"Test the installation:"},{"location":"documentation/installation/#dependencies","text":"git , gcc , cmake : for code developing, configuring and compiling mpich or open mpi : for parallel computing json : for input data interchange cork : for mesh boolean operation gmp igl : another option of mesh boolean operation (robust but much slower than cork) cgal (requires boost , gmp , mpfr ), openmp , eigen googletest : for tests mlpack : for machine learning libraries armadillo (requires lapack , arpack , openblas ), ensmallen , cereal , boost , stb Using dependencies already in the system would save the time required by the compilation of the whole project. Some dependencies (e.g., mlpack) would take fairly long time to compile. One can check out the log files in contrib/[package]/ep/src/[package]-stamp/ for the compiling, building and installing progresses of the dependencies. Some packages (e.g., boost and mpi ) could take forever to compile. It is recommended that you install pre-build boost and mpi using tools such as brew install in mac os, or apt-get install in ubantu.","title":"Dependencies"},{"location":"documentation/usage/","text":"Run built-in examples There are some built-in examples defined in the examples/ directory. Once the software is installed, it will create an excutable file in the build/bin directory. Run an example using the following command in the root directory. The results will be stored in tmp/out/ directory after the running of the example. ./build/bin/netdem_example_random_packing Visualize the results in paraview . For irregular-shaped particles, use the following command to generate the results with particles represented by triangle meshes. ./build/bin/netdem_tool_point2mesh [in.vtk] [out.vtk] [shape_dir] In case one need to do the generation in batch, the following command can be used ./scripts/batch_data_point2mesh.sh [in_dir] [out_dir] [shape_dir] or easier ./scripts/auto_mesh_particle.sh [out_dir] ./scripts/auto_mesh_wall.sh [out_dir] Visualize & post-process Results can be dumped as VTK files, which can be visualized in paraview . We have a side-repository that provides some matlab or python scripts for post-process (e.g., VTK io, stress-strain, spherical histograms of contact anisotropy).","title":"User manual"},{"location":"documentation/usage/#_1","text":"","title":""},{"location":"documentation/usage/#run-built-in-examples","text":"There are some built-in examples defined in the examples/ directory. Once the software is installed, it will create an excutable file in the build/bin directory. Run an example using the following command in the root directory. The results will be stored in tmp/out/ directory after the running of the example. ./build/bin/netdem_example_random_packing Visualize the results in paraview . For irregular-shaped particles, use the following command to generate the results with particles represented by triangle meshes. ./build/bin/netdem_tool_point2mesh [in.vtk] [out.vtk] [shape_dir] In case one need to do the generation in batch, the following command can be used ./scripts/batch_data_point2mesh.sh [in_dir] [out_dir] [shape_dir] or easier ./scripts/auto_mesh_particle.sh [out_dir] ./scripts/auto_mesh_wall.sh [out_dir]","title":"Run built-in examples"},{"location":"documentation/usage/#visualize-post-process","text":"Results can be dumped as VTK files, which can be visualized in paraview . We have a side-repository that provides some matlab or python scripts for post-process (e.g., VTK io, stress-strain, spherical histograms of contact anisotropy).","title":"Visualize &amp; post-process"},{"location":"download/","text":"NetDEM Source code: https://github.com/net-dem/netdem website: https://github.com/net-dem/netdem_docs Post-processing scripts Matlab: https://github.com/net-dem/dem_postprocess_scripts Other relevant softwares Easybuild : a software environment for easing the configuration, building and installation computational packages. Now support: peridigm liggghts netdem","title":"Download"},{"location":"download/#_1","text":"","title":""},{"location":"download/#netdem","text":"Source code: https://github.com/net-dem/netdem website: https://github.com/net-dem/netdem_docs","title":"NetDEM"},{"location":"download/#post-processing-scripts","text":"Matlab: https://github.com/net-dem/dem_postprocess_scripts","title":"Post-processing scripts"},{"location":"download/#other-relevant-softwares","text":"Easybuild : a software environment for easing the configuration, building and installation computational packages. Now support: peridigm liggghts netdem","title":"Other relevant softwares"},{"location":"examples/angle_of_repose/","text":"","title":"Angle of repose"},{"location":"examples/gallery/","text":"Gallery This page collects animations from various simulations based on NetDEM. Random packing of poly-super-ellipsoid particles. Random packing of level-set particles. Granular mixing of spheres. Nut sliding on bolt without frition and damping. Random packing of poly-super-quadrics particles. Random packing of nuts and bolts that are represented by surface triangle meshes. Triaxial compression of irregular-shaped particles that are represented by spherical harmonics. Random packing of generaly irregular-shaped particles, where the contacts are handled by neurual networks. Random packing of spherical-harmonics particles. Random packing of mixed types of particles, including poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, level set, polyhedron, etc. Column collapsing of irregular-shaped particles that are represented by spherical harmonics.","title":"Gallery"},{"location":"examples/gallery/#gallery","text":"This page collects animations from various simulations based on NetDEM. Random packing of poly-super-ellipsoid particles. Random packing of level-set particles. Granular mixing of spheres. Nut sliding on bolt without frition and damping. Random packing of poly-super-quadrics particles. Random packing of nuts and bolts that are represented by surface triangle meshes. Triaxial compression of irregular-shaped particles that are represented by spherical harmonics. Random packing of generaly irregular-shaped particles, where the contacts are handled by neurual networks. Random packing of spherical-harmonics particles. Random packing of mixed types of particles, including poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, level set, polyhedron, etc. Column collapsing of irregular-shaped particles that are represented by spherical harmonics.","title":"Gallery"},{"location":"examples/granular_mixing/","text":"","title":"Granular mixing"},{"location":"examples/random_packing/","text":"[WIP] Random packing Problem description Setup and implementation Results and discussions","title":"Random packing"},{"location":"examples/random_packing/#random-packing","text":"","title":"Random packing"},{"location":"examples/random_packing/#problem-description","text":"","title":"Problem description"},{"location":"examples/random_packing/#setup-and-implementation","text":"","title":"Setup and implementation"},{"location":"examples/random_packing/#results-and-discussions","text":"","title":"Results and discussions"},{"location":"examples/triaxial_compression/","text":"","title":"Triaxial compression"}]}