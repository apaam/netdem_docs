{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Previous Next NetDEM is a neural network enabled C++ library for discrete element methods. Features It is currently capable of performing basic and general DEM simulations, with following features: Sphere and triangle facets contact solver GJK contact solver for convex particles SDF contact solver for arbitrary (convex and concave) particles Hybrid OpenMP and MPI parallel computing Integrated mlpack machine learning environment The supported particle shapes include sphere, cylinder, poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, triangle mesh, level set, etc. News Date Message Dec 01, 2021 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10, 2021 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15, 2021 Generlized two types of contact solvers, namely GJK and SDF. Mar 15, 2021 Integrated the mlpack as the machine learning environment. Documentation Getting Started \u250a Examples \u250a Code doxygen \u250a Sources We recommend new users to start by examining the example codes . Currently, we use paraview for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . License & citation NetDEM is distributed under the GPL license, see copyright and license for details. See the about page for acknowledgements and citation information.","title":"Home"},{"location":"#features","text":"It is currently capable of performing basic and general DEM simulations, with following features: Sphere and triangle facets contact solver GJK contact solver for convex particles SDF contact solver for arbitrary (convex and concave) particles Hybrid OpenMP and MPI parallel computing Integrated mlpack machine learning environment The supported particle shapes include sphere, cylinder, poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, triangle mesh, level set, etc.","title":"Features"},{"location":"#news","text":"Date Message Dec 01, 2021 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10, 2021 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15, 2021 Generlized two types of contact solvers, namely GJK and SDF. Mar 15, 2021 Integrated the mlpack as the machine learning environment.","title":"News"},{"location":"#documentation","text":"Getting Started \u250a Examples \u250a Code doxygen \u250a Sources We recommend new users to start by examining the example codes . Currently, we use paraview for visualization.","title":"Documentation"},{"location":"#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments .","title":"Contact"},{"location":"#license-citation","text":"NetDEM is distributed under the GPL license, see copyright and license for details. See the about page for acknowledgements and citation information.","title":"License &amp; citation"},{"location":"about/acknowledgement/","text":"How to cite We do not have a paper for this extire library for now. Please cite one of our relevant works with @article{lai2021revisiting, title={Revisiting the GJK and shape erosion method for contact resolution in DEM}, author={Lai, Zhengshou and Zhao, Shiwei and Zhao, Jidong and Huang, Linchong}, journal={Powder Technology}, year={2021}, publisher={Elsevier} } Contributors We would like to thank all the peer researchers that have directly or indrectly made a contribution to this project, by means of submitting commits or pull requests, making suggestions or discussions, finding and resolving bugs or difficulties during usage, etc. We would also like to thank the authors of thrid party software packages (in dependencies ) that are used by this project and have greatly faciliated the development of this project. This website is built on mkdocs and the template extracted from mfem . Fundings This project is under active development. The fundings that have supported the development of this project are acknowledged and will be updated accordingly. 2019-2022: National Natural Science Foundation of China (51909289) 2019-2021: China Postdoctoral Science Foundation (2019M663240) 2020-2022: Hong Kong Scholar program (2020) Copyright & License Copyright \u00a9 2020-, NetDEM team, Applied Process Analysis and Modeling Group. Copyright \u00a9 2020-, Sun Yat-sen University and The Hong Kong University of Science and Technology. NetDEM is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. NetDEM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"Acknowledgements"},{"location":"about/acknowledgement/#_1","text":"","title":""},{"location":"about/acknowledgement/#how-to-cite","text":"We do not have a paper for this extire library for now. Please cite one of our relevant works with @article{lai2021revisiting, title={Revisiting the GJK and shape erosion method for contact resolution in DEM}, author={Lai, Zhengshou and Zhao, Shiwei and Zhao, Jidong and Huang, Linchong}, journal={Powder Technology}, year={2021}, publisher={Elsevier} }","title":"How to cite"},{"location":"about/acknowledgement/#contributors","text":"We would like to thank all the peer researchers that have directly or indrectly made a contribution to this project, by means of submitting commits or pull requests, making suggestions or discussions, finding and resolving bugs or difficulties during usage, etc. We would also like to thank the authors of thrid party software packages (in dependencies ) that are used by this project and have greatly faciliated the development of this project. This website is built on mkdocs and the template extracted from mfem .","title":"Contributors"},{"location":"about/acknowledgement/#fundings","text":"This project is under active development. The fundings that have supported the development of this project are acknowledged and will be updated accordingly. 2019-2022: National Natural Science Foundation of China (51909289) 2019-2021: China Postdoctoral Science Foundation (2019M663240) 2020-2022: Hong Kong Scholar program (2020)","title":"Fundings"},{"location":"about/acknowledgement/#copyright-license","text":"Copyright \u00a9 2020-, NetDEM team, Applied Process Analysis and Modeling Group. Copyright \u00a9 2020-, Sun Yat-sen University and The Hong Kong University of Science and Technology. NetDEM is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. NetDEM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"Copyright &amp; License"},{"location":"about/help_%26_support/","text":"There are varieties of features or functionalities can be implemented into the NetDEM to facilitate its application on scientific research or engineering production. If you have an interest to contribute to any part of this project, please let us know. The users are also cautioned that this code is under active development. If you need help using NetDEM, or have found a bug, please open an issue or submit a pull request . Known issues The compilation of mlpack and its relevant sources in netdem with debug option would consume a lot of memory (~10 G), wihch might cause computers breakdown if compiling with multiple thread. GJK and EPA will encounter convergence issue for two particles contacting at a plane. TODOs Servo control of wall does not work properly in MPI. In MPI, it will need the contact information from all domains. GPU. Contact Dr. Zhengshou Lai, laizhengsh [AT] mail.sysu.edu.cn","title":"Help & Support"},{"location":"about/help_%26_support/#_1","text":"There are varieties of features or functionalities can be implemented into the NetDEM to facilitate its application on scientific research or engineering production. If you have an interest to contribute to any part of this project, please let us know. The users are also cautioned that this code is under active development. If you need help using NetDEM, or have found a bug, please open an issue or submit a pull request .","title":""},{"location":"about/help_%26_support/#known-issues","text":"The compilation of mlpack and its relevant sources in netdem with debug option would consume a lot of memory (~10 G), wihch might cause computers breakdown if compiling with multiple thread. GJK and EPA will encounter convergence issue for two particles contacting at a plane.","title":"Known issues"},{"location":"about/help_%26_support/#todos","text":"Servo control of wall does not work properly in MPI. In MPI, it will need the contact information from all domains. GPU.","title":"TODOs"},{"location":"about/help_%26_support/#contact","text":"Dr. Zhengshou Lai, laizhengsh [AT] mail.sysu.edu.cn","title":"Contact"},{"location":"about/news_%26_updates/","text":"News 2021 Date Message Dec 10 Particle breakage with peridigm-DEM coupling, domain splitting, bonded spheres, bonded voronois Dec 01 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15 Generlized two types of contact solvers, namely GJK and SDF. Mar 15 Integrated the MLPACK as the machine learning environment. Revision notes (As from Dec 11, 2021) v0.0 Rename evaluator to modifier for all classes and files Add membrane with finite element and neo-hookean model Dynamic properties in particle, wall and contacts Seperate collision contacts and bond contacts in data dumper Contact-wise numerical damping","title":"News & Updates"},{"location":"about/news_%26_updates/#news","text":"","title":"News"},{"location":"about/news_%26_updates/#2021","text":"Date Message Dec 10 Particle breakage with peridigm-DEM coupling, domain splitting, bonded spheres, bonded voronois Dec 01 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15 Generlized two types of contact solvers, namely GJK and SDF. Mar 15 Integrated the MLPACK as the machine learning environment.","title":"2021"},{"location":"about/news_%26_updates/#revision-notes","text":"(As from Dec 11, 2021)","title":"Revision notes"},{"location":"about/news_%26_updates/#v00","text":"Rename evaluator to modifier for all classes and files Add membrane with finite element and neo-hookean model Dynamic properties in particle, wall and contacts Seperate collision contacts and bond contacts in data dumper Contact-wise numerical damping","title":"v0.0"},{"location":"about/publications/","text":"2021 Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371.","title":"Publications"},{"location":"about/publications/#2021","text":"Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371.","title":"2021"},{"location":"documentation/code_algorithms/","text":"Code design General framework The program currently contains 7 modules: domain: Define the computational domain evaluator: Define some personalized calculations of the discrete element model, such as adding external forces, exporting data, etc. Because these personalized calculations are not required for every calculation model, they can be added to the model freely through this subscription method. Generally, the evaluator is defined first, and then attached to a simulation and activated. When the discrete element is calculated to a certain node, the subscribed evaluator will be called uniformly. Currently, two evaluators are defined: pre_evaluator and post_evaluator. pre_evaluator is called at the beginning of each calculation cycle, and post_evaluator is called at the end of each calculation cycle. input: Used to interpret the input file. It is planned to adopt the json format as the data exchange format. Each json object corresponds to a command, and the simulation is constructed or modified through the execution of the command. The commands in plan definition 6: create, get, set, fix, unfix, run. create: create objects such as shape, particle, wall, contact model, evaluator, etc. get: get object properties set: set object properties fix: Bind the defined evaluator to simulation to activate. unfix: Unbind the defined evalua to make it invalid. run: start discrete element calculation mpi: data interaction between different parallel computing cores scene: contains shape tmplates, particle, wall, contact model, evaluator, etc. solver: Discrete element solver utils: other tool functions Basic elements Particles: Particles have variables or attributes such as shape, position, speed, and force The movement of particles obeys Newton's law of motion The particles are in contact with each other to generate contact force, which is calculated according to the corresponding contact model Wall or boundary: The boundary has variables or attributes such as shape, position, and force The boundary is generally assumed to be massless, so there is no need to calculate - Newtonian motion, just update its position according to the preset motion law Contact: particle-to-particle, or particle-to-boundary contact with contact geometric characteristics, contact force and other attributes The contact model describes the relationship between contact force and contact geometric characteristics Calculation procedures The basic calculation process of discrete element (DEMSolver calculation process): Traverse all the \"particles\" in this calculation domain, and clear the force and torque to zero. Perform pre_evaluator, such as gravity. Traverse all the \"particles\" in this computational domain to determine whether its contours touch other computational domains: if so, use MPI to transfer its data to the computational domain, and create a new particle in the target computational domain based on the particle data, as The particle is a proxy in the target computing domain, and the proxy particle can come into contact with other particles. The particles in this computing domain are called \"particle agents to be sent\", and the particles in the target computing domain are called \"received particle agents\". Receive the \"particle agent\" data and create an instance of the particle agent: If this calculation domain already contains the id of the particle agent, find the particle pointer through particlem_map, and update the particle instance with the received particle agent data; If the id of the particle agent does not exist, create a new \"particle_ghost\" instance, and update the particle instance with the received particle agent data; Traverse the \"granular agent to be sent\" and send its corresponding \"contact data\" to the target computing domain. Receive contact data and create contact instances: Determine the pointer of the particle according to the particle id, and determine the pointer of the contact model according to the contact model id Determine whether the contact exists through the contact_pp_list of the particle If it exists, update the contact instance from the received contact data. If it does not exist, establish a contact first, and use the received particle agent data to update the particle instance, Traverse all contacts and set their updated to false. Divide the computational domain into grids, traverse all the \"particles\" and \"received particle agents\" in the computational domain, and classify them into each grid. The classification criteria are: If the circumscribed cube of the particle or particle agent contacts a certain grid, then the particle or particle agent is added to the grid. Traverse all grids: Traverse the particles and particle agents in this grid to determine whether they are in contact. If touched: Determine whether it was in contact at the previous time step If yes, find the contact instance, update its contact geometric features and contact force, and set the updated of the contact to true If not, create a new contact instance, initialize the contact geometric features and calculate the contact force, and set the updated of the contact to true Apply contact force to particles and boundaries Traverse the \"received particle agent\": Traverse the contact of the particle agent, if the updated state of the contact is true, use MPI to send the contact data back to the original computing domain Receive contacts returned from other computing domains and reconstruct contact instances If the contact already exists, use the returned data to update the original contact If the contact does not exist, create a new contact and rebuild the particle pointer in the contact If the particle exists in the computational domain, the particle pointer is found through particle_map and particle id. If the particle does not exist in the computational domain, create a new \"particle illusion\" and set the \"particle illusion\" pointer to the contact. Apply contact force to particles Traverse all contacts If its updated status is false, delete the contact; Traverse all particles - Update its speed, position and other attributes according to Newton's law of motion Add the partial_proxy_list to the particle_ghost_list and clear the partial_proxy_list According to the updated particle position, traverse each particle to determine whether it exceeds the calculation domain: If so, send its data to the new computational domain of the particle, and move the particle to particle_ghost_list. Receive the \"particle\" data and create an instance of the particle: If this calculation domain already contains the id of the particle, find the particle pointer through particlem_map, and update the particle instance with the received particle data; If the id of the particle does not exist, create a new particle instance and update the particle instance with the received particle data; Traverse particle_ghost_list If it is not in contact with any particles or boundaries, delete the \"particle phantom\" Perform post_evaluator, such as data output and other functions.","title":"Code algorithms"},{"location":"documentation/code_algorithms/#_1","text":"","title":""},{"location":"documentation/code_algorithms/#code-design","text":"","title":"Code design"},{"location":"documentation/code_algorithms/#general-framework","text":"The program currently contains 7 modules: domain: Define the computational domain evaluator: Define some personalized calculations of the discrete element model, such as adding external forces, exporting data, etc. Because these personalized calculations are not required for every calculation model, they can be added to the model freely through this subscription method. Generally, the evaluator is defined first, and then attached to a simulation and activated. When the discrete element is calculated to a certain node, the subscribed evaluator will be called uniformly. Currently, two evaluators are defined: pre_evaluator and post_evaluator. pre_evaluator is called at the beginning of each calculation cycle, and post_evaluator is called at the end of each calculation cycle. input: Used to interpret the input file. It is planned to adopt the json format as the data exchange format. Each json object corresponds to a command, and the simulation is constructed or modified through the execution of the command. The commands in plan definition 6: create, get, set, fix, unfix, run. create: create objects such as shape, particle, wall, contact model, evaluator, etc. get: get object properties set: set object properties fix: Bind the defined evaluator to simulation to activate. unfix: Unbind the defined evalua to make it invalid. run: start discrete element calculation mpi: data interaction between different parallel computing cores scene: contains shape tmplates, particle, wall, contact model, evaluator, etc. solver: Discrete element solver utils: other tool functions","title":"General framework"},{"location":"documentation/code_algorithms/#basic-elements","text":"Particles: Particles have variables or attributes such as shape, position, speed, and force The movement of particles obeys Newton's law of motion The particles are in contact with each other to generate contact force, which is calculated according to the corresponding contact model Wall or boundary: The boundary has variables or attributes such as shape, position, and force The boundary is generally assumed to be massless, so there is no need to calculate - Newtonian motion, just update its position according to the preset motion law Contact: particle-to-particle, or particle-to-boundary contact with contact geometric characteristics, contact force and other attributes The contact model describes the relationship between contact force and contact geometric characteristics","title":"Basic elements"},{"location":"documentation/code_algorithms/#calculation-procedures","text":"The basic calculation process of discrete element (DEMSolver calculation process): Traverse all the \"particles\" in this calculation domain, and clear the force and torque to zero. Perform pre_evaluator, such as gravity. Traverse all the \"particles\" in this computational domain to determine whether its contours touch other computational domains: if so, use MPI to transfer its data to the computational domain, and create a new particle in the target computational domain based on the particle data, as The particle is a proxy in the target computing domain, and the proxy particle can come into contact with other particles. The particles in this computing domain are called \"particle agents to be sent\", and the particles in the target computing domain are called \"received particle agents\". Receive the \"particle agent\" data and create an instance of the particle agent: If this calculation domain already contains the id of the particle agent, find the particle pointer through particlem_map, and update the particle instance with the received particle agent data; If the id of the particle agent does not exist, create a new \"particle_ghost\" instance, and update the particle instance with the received particle agent data; Traverse the \"granular agent to be sent\" and send its corresponding \"contact data\" to the target computing domain. Receive contact data and create contact instances: Determine the pointer of the particle according to the particle id, and determine the pointer of the contact model according to the contact model id Determine whether the contact exists through the contact_pp_list of the particle If it exists, update the contact instance from the received contact data. If it does not exist, establish a contact first, and use the received particle agent data to update the particle instance, Traverse all contacts and set their updated to false. Divide the computational domain into grids, traverse all the \"particles\" and \"received particle agents\" in the computational domain, and classify them into each grid. The classification criteria are: If the circumscribed cube of the particle or particle agent contacts a certain grid, then the particle or particle agent is added to the grid. Traverse all grids: Traverse the particles and particle agents in this grid to determine whether they are in contact. If touched: Determine whether it was in contact at the previous time step If yes, find the contact instance, update its contact geometric features and contact force, and set the updated of the contact to true If not, create a new contact instance, initialize the contact geometric features and calculate the contact force, and set the updated of the contact to true Apply contact force to particles and boundaries Traverse the \"received particle agent\": Traverse the contact of the particle agent, if the updated state of the contact is true, use MPI to send the contact data back to the original computing domain Receive contacts returned from other computing domains and reconstruct contact instances If the contact already exists, use the returned data to update the original contact If the contact does not exist, create a new contact and rebuild the particle pointer in the contact If the particle exists in the computational domain, the particle pointer is found through particle_map and particle id. If the particle does not exist in the computational domain, create a new \"particle illusion\" and set the \"particle illusion\" pointer to the contact. Apply contact force to particles Traverse all contacts If its updated status is false, delete the contact; Traverse all particles - Update its speed, position and other attributes according to Newton's law of motion Add the partial_proxy_list to the particle_ghost_list and clear the partial_proxy_list According to the updated particle position, traverse each particle to determine whether it exceeds the calculation domain: If so, send its data to the new computational domain of the particle, and move the particle to particle_ghost_list. Receive the \"particle\" data and create an instance of the particle: If this calculation domain already contains the id of the particle, find the particle pointer through particlem_map, and update the particle instance with the received particle data; If the id of the particle does not exist, create a new particle instance and update the particle instance with the received particle data; Traverse particle_ghost_list If it is not in contact with any particles or boundaries, delete the \"particle phantom\" Perform post_evaluator, such as data output and other functions.","title":"Calculation procedures"},{"location":"documentation/dem_formulations/","text":"This page presents a brief introduction and review of the discrete element method (DEM). The intention is to introduce the main components and basic computational workflow of a DEM model, providing necessary background information to the research presented in this dissertation. Overview DEM is a particle-based numerical model that is particularly suitable for describing the mechanical behavior of bulk granular materials. It was first proposed by Cundall &Strack (1979) 2 for the analysis of geotechnical materials. Since then, DEM has been applied to model all kinds of granular materials and to simulate the problems ranging from solids handling to powder flowing in a variety of different engineering branches 3 4 5 . In DEM, all individual particles in the bulk granular material are explicitly modeled and a DEM model directly captures the interactions between particles and tracks the motions of each particle. The bulk behavior of a granular material is presented as an assembly of the actions (i.e., the interactions and motions) of all constituent particles. As a particle-based numerical model, DEM exhibits several advantages compared to the classical continuum theory-based numerical models. First, it bypasses the phenomenological constitutive models for describing the bulk behavior of a granular material within a representative volume 6 7 8 . Second, it is straightforward for the DEM to simulate the problems involving large deformation or material failure, such as granular flow, penetration, or strain localization 9 . The major drawback of DEM is also obvious. As DEM tracks the interactions and motions of all particles, DEM simulations are quite computationally expensive, which makes it difficult to scale up 10 11 . Nevertheless, with the advent of computer hardware and parallel capabilities, the DEM has become an increasingly powerful numerical tool that can provide valuable information of and shed lights upon the microscopic behavior of granular materials, which is often difficult or impossible to obtain from classical continuum-based numerical models or from physical experiments. Key components of DEM Basic elements In general, there are two types of basic elements in a DEM model: particles and boundaries. The basic elements are assumed to be rigid but can have overlaps with each other. A particle is a body that has a closed surface. It may be represented by a simple geometry (e.g., sphere or ellipsoid) or a composition of several simple geometries that make up the body surface (see further discussions in ). A review on the particle geometric representations can be found in Zhong et al. (2016) 12 . Particles have mass and their motion (i.e., position, velocity, and acceleration) is always tracked during a DEM simulation. Boundaries are also referred to as walls in the DEM literature. They may as well be represented by simple geometries (e.g., triangles) or their combinations, but they do not necessarily have closed surfaces. Boundaries do not have mass and their position and velocity are usually prescribed to provide the desired constraints to the particles in the model. Contacts and contact models Contacts describe the interactions between basic elements. Contact occurs when the surfaces of two basic elements overlap with each other (to model collisions), or when the surfaces are within a specified distance (to model long-range bond or cohesion). Detecting the contacts between basic elements is a mathematical geometry problem and is one of the most time-consuming parts of a DEM simulation. One important task associated with contact detection is to characterize the contact geometric features, which are needed by a contact model to calculate the contact forces and moments. The contact features may include the overlapping (or indentation) distance, relative shear displacement, contact point, contact branch vectors, and so on. Contact models are used to calculate the contact forces and moments between the two elements in contact. Commonly used contact models include the linear elastic model 2 , the rolling resistance model 13 14 , the Hertz-Mindlin model 15 16 17 , and the linear parallel bond model 18 . The formulation of these contact models will be presented in . Newton-Euler equations of motion In DEM, the motion of a particle can be described by the Newton-Euler equations of motion. For any arbitrarily-shaped particle, the Newton-Euler equations of motion are written as \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M}\\end{aligned} \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M}\\end{aligned} where m m is the mass of the particle; \\boldsymbol{I} \\boldsymbol{I} is the inertia tensor of the particle; \\boldsymbol{a} \\boldsymbol{a} and \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} are the translational and rotational acceleration; \\boldsymbol{F} \\boldsymbol{F} and \\boldsymbol{M} \\boldsymbol{M} are the overall external forces and moments acting on the particle; \\boldsymbol{\\omega} \\boldsymbol{\\omega} is the vector of the angular velocities about the principal axes. Herein, the variable in bold-symbol indicates a vector or a tensor. For spherical particles, the Newton-Euler equations of motion reduce to \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M}\\end{aligned} \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M}\\end{aligned} In order to resolve the motion of each particle, all the forces and moments acting on the particle need to be evaluated and summed, which may include gravity, damping, contact forces and moments, and prescribed external forces and moments. Herein, the damping refers to the global damping, which is sometimes (artificially) introduced in a DEM model to facilitate energy dissipation and enhance a quasi-static simulation 19 20 . There is another type of damping called local damping, which is usually incorporated into a contact model as dash-pot forces to account for the realistic energy dissipation due to particle interactions. Time integration To fully resolve the particle motion (e.g., the position and velocity) governed by and involves the time integration scheme, where the second-order Velocity Verlet algorithm is commonly adopted. For spherical particles, suppose that the current state is indexed by time t t and the time increment to the next state is \\Delta t \\Delta t , Velocity Verlet algorithm first calculates the particle velocities at time t t + \\Delta t/2 \\Delta t/2 by \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2\\end{aligned} \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2\\end{aligned} where \\boldsymbol{v} \\boldsymbol{v} and \\boldsymbol{\\omega} \\boldsymbol{\\omega} are translational and angular velocities, respectively. The superscripts (e.g., t t and \\Delta t/2 \\Delta t/2 ) indicate the time indexes. Then, the position and orientation of the particle at time t t + \\Delta t \\Delta t are calculated as \\begin{aligned} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{aligned} \\begin{aligned} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{aligned} where \\boldsymbol{x} \\boldsymbol{x} is the vector of position and \\boldsymbol{\\theta} \\boldsymbol{\\theta} is the vector of orientation. Correspondingly, the translational velocity and angular velocity at time t+\\Delta t t+\\Delta t are updated by \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{aligned} \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{aligned} For non-spherical particles, the original Newton-Euler equations of motion cannot be simplified, and the calculation of the orientations and angular velocity will be much more complicated. A more detailed discussion on the time integration for non-spherical particles will not be included here but can be found in the work of Chung (2006) 19 and the PFC user manual 20 . Critical timestep The time integration based on the second-order Velocity Verlet algorithm is numerically stable only when the time increment being used is less than a threshold value, i.e. the critical timestep 21 . If a time increment greater than the critical timestep is used, particles may move too much in one increment, which will result in spuriously infinite overlapping (i.e., abnormally large contact forces). A summary and empirical assessment of different approaches to estimate the critical timestep for DEM simulations can be found in Otsubo et al. (2017) 21 . Basically, there are two categories of approaches to estimate the critical timestep: the oscillation period of a single degree of freedom system (SDOF) based approaches 2 22 , and the Rayleigh wave speed based approaches 23 24 . The former approaches consider the DEM system to be consist of rigid bodies connected by springs, while the latter ones consider the particles themselves to be springs. In the category of the SDOF-based approaches, Cundall & Stract (1979) 2 proposed the following expression to estimate the critical timestep \\Delta t_\\text{crit} \\Delta t_\\text{crit} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) where m m is the mass of the particle; I_i I_i is the moment of inertia of the particle; k^\\text{tran} k^\\text{tran} and k_i^\\text{rot} k_i^\\text{rot} represent the translational and rotational stiffness, and the subscript i i indicates the index of principal components. In the category of the Rayleigh wave speed based approaches, Li et al. (2005) 24 proposed that \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} where R R is the average particle radius; \\rho \\rho is the particle density; G G the particle shear modulus; and \\nu \\nu the Poisson's ratio of the particle. Computational workflow DEM-based numerical simulations require cyclic calculations. shows the workflow and calculations that are involved in one typical cycle of a DEM simulation. The workflow and calculations for one DEM cycle can be summarized as follows: At the current state, the positions and velocities of all particles are known: based on the geometries of all particles, identify the inter-particle contacts and evaluate contact features; Calculate the external forces and moments of all particles, while the contact forces and moments are calculated based on selected contact models and the corresponding contact features; Calculate the motion (i.e., the accelerations) of all particles; Update the positions and velocities of all particles following the selected time integration scheme. Particle representation There are basically two groups of methods to represent an irregular particle in DEM 12 : single-particle method and composite-particle method. Single-particle method The single-particle method utilizes closed geometries to represent particle shapes. Many single-particle-based DEM models have been proposed and developed with the adoption of some specific closed geometries, such as cylinder 25 , polyhedron (or polygon in 2D) 26 27 , ellipsoid (or ellipse in 2D) 28 29 , superquadrics 30 31 , Non-Uniform Rational Basis Spline (NURBS) 32 , as well as their combinations (e.g., poly-ellipsoid 33 34 ). Each of these methods has its own advantages and limitations. The application of the cylinder-based or ellipsoid-based DEM models is limited, due to the particular particle shapes they can represent. The superquadric can be considered as an extension of the ellipsoid and can be used for modeling of spheres, ellipsoids, cylinder-like and box(dice)-like particles by varying the shape parameters. It is more flexible by being able to model larger variations of particle shapes, but also more computationally expensive than the ellipsoid-based DEM models. The polyhedron- (or polygon in 2D) based DEM model is able to replicate arbitrary particle shapes. The accuracy of the shape represented by polyhedron depends on the number of faces in a polyhedron, whereas a large number of faces would hinder the computational efficiency. Moreover, polyhedron can rarely replicate a smooth particle shape. The NURBS based granular element method, developed by Andrade et al. (2012) 32 , is advantageous to replicate general and smooth particle shapes, whereas it is computationally expensive compared to the polyhedron-based DEM. Recently, Kawamoto et al. (2016) 35 developed another novel type of single-particle-based DEM, which utilizes the level set (LS) method to represent particles. The LS-DEM seamlessly utilizes the level set data of realistic particle shapes characterized from X-ray computational tomography and is computationally efficient. One issue with the LS-DEM is high memory consumption, which somewhat limits its application on large particulate systems. Composite-particle method In a composite-particle method, a particle is represented by compositions of simple geometries (usually spheres in 3D or circles in 2D 36 1 ). This group of methods is advantageous to implementation for that the contact detection and resolution algorithms for the simple geometries can be effortlessly exploited. It should be noted that the accuracy of particle shape represented by compositions of simple geometries depends on the amount of the simple geometries, and a large number of simple geometries would lead to great computational expense though. Nonetheless, the composite-particle method (especially with spheres as the base elements) is currently the most prevalent method to model irregular particles and is supported in most commercial or open-source DEM packages such as PFC 20 and LIGGGHTS 37 . There are three options to represent a composite particle (a) (b) (c) A schematic illustration of the three options to represent a composite particle with discs (modified after 1 ) Contact models A DEM contact model is normally comprised of springs, dash-pots, and sliders to describe the force-displacement behavior at the contact, where the springs account for normal and tangential forces, the dash-pots account for local damping, and the sliders account for shear failure. The formulation of contact models that will be used in this dissertation is presented in this section. Linear elastic model A linear elastic model generally consists of two elastic springs, two dash-pots, and a slider, as shown schematically in the following. The contact forces \\boldsymbol{F} \\boldsymbol{F} are calculated from two parts: the normal force \\boldsymbol{F}_n \\boldsymbol{F}_n and the shear (or tangential) force \\boldsymbol{F}_s \\boldsymbol{F}_s \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s where \\boldsymbol{n}_n \\boldsymbol{n}_n and \\boldsymbol{n}_s \\boldsymbol{n}_s are the unit vectors denoting the direction of the normal and the shear force, respectively; F_n F_n and F_s F_s are the magnitudes of corresponding contact forces. Assuming the relative displacement increment at the contact during a timestep \\Delta t \\Delta t is given by its components \\Delta \\delta_n \\Delta \\delta_n (compression as a positive) and \\Delta \\delta_s \\Delta \\delta_s , the contact law for a simple linear model with local damping updates the contact forces through 2 20 \\begin{aligned}F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n)\\end{aligned} \\begin{aligned}F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n)\\end{aligned} where F_n^0 F_n^0 and F_s^0 F_s^0 are the normal and the shear forces at the beginning of the current timestep, respectively; k_n k_n and k_s k_s are the corresponding stiffness; \\eta_n \\eta_n and \\eta_s \\eta_s are the corresponding damping coefficients; \\dot{\\delta}_n \\dot{\\delta}_n and \\dot{\\delta}_s \\dot{\\delta}_s are the relative normal and shear velocity; \\mu_c \\mu_c is the contact friction coefficient; and \\bar{m} = m_im_j/(m_i+m_j) \\bar{m} = m_im_j/(m_i+m_j) is the effective mass of particles i i and j j associated with the contact, while \\bar{m} = m_i \\bar{m} = m_i for the case of particle-boundary contact. Rolling resistance model The rolling resistance model is built upon the linear elastic model by adding a term of rolling resistance moment to the contact moment. The formulation to calculate the additional rolling resistance moment can be written as 38 13 20 M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) where M^0 M^0 is the contact moment at the beginning of the current timestep; \\Delta\\theta_b \\Delta\\theta_b is the relative bending-rotation increment; \\mu_r \\mu_r is the rolling resistance coefficient; k_r k_r is the rolling resistance stiffness defined as: k_r = k_s\\bar{R}^2 k_r = k_s\\bar{R}^2 where \\bar{R} \\bar{R} is the contact effective radius defined as \\bar{R}=R_iR_j/(R_i+R_j) \\bar{R}=R_iR_j/(R_i+R_j) , in which R_i R_i and R_j R_j are the radii of the contact particles. If one side of the contact is a wall, the corresponding radius R_j \\rightarrow \\infty R_j \\rightarrow \\infty . This model uses a simplified formulation for the rolling kinematics, and the particle size effects on the rolling resistance are implicitly incorporated in the rolling stiffness term. The interested reader is referred to Luding (2008) 39 , Wang et al. (2015) 40 for examples of improved and more advanced rolling resistance models. Hertz-Mindlin model The Hertz-Mindlin model is a complete frictional contact model based upon the Hertz theory 15 for contact normal forces and the Mindlin theory 16 for contact tangential forces. It takes into account the stiffness variation due to the change of contact areas during the collision of two elastic spheres. Similar to the linear elastic model, the Hertz-Mindlin model also consists of two springs, two dash-pots, and a slider. There are, however, two major differences. First, the normal and shear stiffness in the Hertz-Mindlin model are functions of the contact overlapping distance. Second, the normal contact force in the Hertz-Mindlin model is calculated via the cumulative overlapping distance, while the linear elastic model uses either the cumulative or incremental overlapping distance. To update the contact forces, the Hertz-Mindlin model follows \\begin{aligned} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{aligned} \\begin{aligned} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{aligned} where \\delta_n \\delta_n is the cumulative overlapping distance, while k_n k_n and k_s k_s are calculated as 17 : \\begin{aligned} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{aligned} \\begin{aligned} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{aligned} in which \\begin{aligned} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{aligned} \\begin{aligned} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{aligned} where \\bar{E} \\bar{E} and \\bar{G} \\bar{G} are the effective Young's modulus and shear modulus of the particles in contact; E_i E_i is the Young's modulus and \\nu_i \\nu_i is the Poisson's ratio of the i i th particle. Linear parallel bond model The linear parallel bond model describes the contact behavior of two bonded particles, as shown schematically in the following. In the linear parallel bond model, the bond between two spheres is assumed to be a cylinder of finite radius and thickness. Each point in the bond is imposed by two linear elastic springs providing normal and shear resistances, respectively. The overall bonding force and moment are the integral of the normal and shear stresses at a cross-section of the bond, which can be calculated as 18 \\begin{aligned} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s\\end{aligned} \\begin{aligned} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s\\end{aligned} where F_n^b F_n^b , F_s^b F_s^b , M_n^b M_n^b and M_s^b M_s^b are the bond normal force, shear force, twisting moment, and swinging moment, respectively; \\delta_n \\delta_n , \\delta_s \\delta_s , \\theta_n \\theta_n , and \\theta_s \\theta_s are the relative normal displacement, shear displacement, twisting rotation, and swinging rotation between the two bonded spheres, respectively; A A , I I , and J J are the area, moment of inertia, and polar moment of inertia of the bond (i.e., the circular cross-section with radius R^b R^b ), respectively; and \\Delta \\Delta indicates the increment of each variable in each time step. It should be pointed out that, while the damping is not included in the current formulation, damping terms similar to those in the linear elastic model can be incorporated in a straightforward manner. The bonded-sphere model is also capable of modeling the particle breakage behavior. As an example of a common bond breakage criterion, it can be assumed that a bond would break if the maximum normal or shear stress at the bond exceeds the corresponding normal or shear strength. In the linear parallel bond model, both the normal force and swinging moment contribute to the normal stress, while both the shear force and twisting moment contribute to the shear stress. In this regard, the bond breakage criterion can be written as \\begin{aligned} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{aligned} \\begin{aligned} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{aligned} where \\sigma_{Y,n}^b \\sigma_{Y,n}^b and \\sigma_{Y,s}^b \\sigma_{Y,s}^b are the normal and shear strength, respectively. Model calibration As most of the contact parameters in a DEM model are difficult if not impossible to be measured directly from physical tests, a calibration process is often needed to obtain the contact parameters for a specific material of interest. There are some researches available on the procedures to calibrate contact parameters for a DEM model 41 42 43 . Usually, the calibration process is accomplished by performing parametric studies on each of contact parameters and selecting values of the contact parameters with which the DEM simulation can reproduce the benchmark matrices of laboratory experiments. Commonly used laboratory experiments for calibration of DEM parameters include compression test, direct and ring shear test, and angle of repose test. Descriptions of these tests can be found in Schulze (2008) 44 , Coetzee (2017) 43 . There are some challenges and problems associated with the model calibration. First, to obtain reasonable and realistic contact parameters via calibration, it is necessary that the setup and procedures in the DEM models are to the most extent similar to those in the laboratory experiments. However, in order to get the DEM simulations performed within affordable computational resources, adjustments or tolerances in the particle size, shape or testing speed may exist in a DEM model. As a result, the calibrated contact parameters may deviate from their actual values to some degree. In addition, the contact features and contact models are usually quite simple and conceptual compared to the actual complex contact behavior. The physical meaning of the contact parameters may be lost due to the use of conceptualized contact features and contact models. Lastly, as pointed out in 43 , the solution of contact parameters might not be unique since all contact parameters may affect the results of a DEM simulation in a complex and highly nonlinear manner. There is no guarantee that the contact parameters for a material calibrated for one experiment will be workable for another. In this regard, it would be necessary to perform the calibration with one experiment and validate the calibration results via another. C. Shi, D. Li, W. Xu, and R. Wang. Discrete element cluster modeling of complex mesoscopic particles for use with the particle flow code method. Granular Matter , 17 3 3 :377\u2013387, 2015. \u21a9 \u21a9 P. A Cundall and O. D. L. Strack. A discrete numerical model for granular assemblies. geotechnique , 29 1 1 :47\u201365, 1979. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 P.W. Cleary. Industrial particle flow modelling using discrete element method. Engineering Computations , 26 6 6 :698\u2013743, 2009. \u21a9 E. Tijskens, H. Ramon, and J. De Baerdemaeker. Discrete element modelling for process simulation in agriculture. Journal of sound and vibration , 266 3 3 :493\u2013514, 2003. \u21a9 C. O'Sullivan. Particle-based discrete element modeling: geomechanics perspective. International Journal of Geomechanics , 11 6 6 :449\u2013464, 2011. \u21a9 J.E. Andrade and C.F. Avila. Granular element method GEM GEM : linking inter-particle forces with macroscopic loading. Granular Matter , 14 1 1 :51\u201361, 2012. \u21a9 J.E. Andrade, Q. Chen, P.H. Le, C.F. Avila, and T.M. Evans. On the rheology of dilative granular media: bridging solid-and fluid-like behavior. Journal of the Mechanics and Physics of Solids , 60 6 6 :1122\u20131136, 2012. \u21a9 N. Guo and J. Zhao. Multiscale insights into classical geomechanics problems. International Journal for Numerical and Analytical Methods in Geomechanics , 40 3 3 :367\u2013390, 2016. \u21a9 Q. Chen. Multiscale Modeling of Failure in Granular Media: From Continuum Scales to Granular Scale . PhD thesis, Northwestern University, 2011. \u21a9 P. Liu and C.M. Hrenya. Challenges of DEM: I. Competing bottlenecks in parallelization of gas\u2013solid flows. Powder Technology , 264:620\u2013626, 2014. \u21a9 K.J. Berger and C.M. Hrenya. Challenges of DEM: II. Wide particle size distributions. Powder Technology , 264:627\u2013633, 2014. \u21a9 W. Zhong, A. Yu, X. Liu, Z. Tong, and H. Zhang. DEM/CFD-DEM modelling of non-spherical particulate systems: theoretical developments and applications. Powder Technology , 302:108\u2013152, 2016. \u21a9 \u21a9 M. Jiang, H. S. Yu, and D. Harris. A novel discrete model for granular material incorporating rolling resistance. Computers and Geotechnics , 32 5 5 :340\u2013357, 2005. \u21a9 \u21a9 M. Jiang, Z. Shen, and J. Wang. A novel three-dimensional contact model for granulates incorporating rolling and twisting resistances. Computers and Geotechnics , 65:147\u2013163, 2015. \u21a9 H.R. Hertz. Uber die Beruhrung fester elastischer Korper und Uber die Harte. Verhandlung des Vereins zur Beforderung des GewerbefleiBes, Berlin , pages 449, 1882. \u21a9 \u21a9 R.D. Mindlin. Elastic spheres in contact under varying oblique forces. Journal of Applied Mechanics , 20:327\u2013344, 1953. \u21a9 \u21a9 A. Di Renzo and F.P. Di Maio. An improved integral non-linear model for the contact of particles in distinct element simulations. Chemical Engineering Science , 60 5 5 :1303\u20131312, 2005. \u21a9 \u21a9 D. O. Potyondy and P. A. Cundall. A bonded-particle model for rock. International journal of rock mechanics and mining sciences , 41 8 8 :1329\u20131364, 2004. \u21a9 \u21a9 Y.C. Chung. Discrete element modelling and experimental validation of a granular solid subject to different loading conditions . PhD thesis, University of Edinburgh, 2006. \u21a9 \u21a9 \u21a9 Itasca Consulting Group, Inc. PFC \u2013 Particle Flow Code, Ver. 5.0. 2014. Minneapolis: Itasca. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 M. Otsubo, C. O'Sullivan, and T. Shire. Empirical assessment of the critical time increment in explicit particulate discrete element method simulations. Computers and Geotechnics , 86:67\u201379, 2017. \u21a9 \u21a9 R. Hart, P.A. Cundall, and J. Lemos. Formulation of a three-dimensional distinct element model\u2013Part II. Mechanical calculations for motion and interaction of a system composed of many polyhedral blocks. International Journal of Rock Mechanics and Mining Sciences & Geomechanics Abstracts , 25 3 3 :117\u2013125, 1988. \u21a9 C. Thornton. Numerical simulations of deviatoric shear deformation of granular media. G\u00e9otechnique , 50 1 1 :43\u201353, 2000. \u21a9 Y. Li, Y. Xu, and C. Thornton. A comparison of discrete element simulations and experiments for `sandpiles' composed of spherical particles. Powder Technology , 160 3 3 :219\u2013228, 2005. \u21a9 \u21a9 Y.T. Feng, K. Han, and D.R.J. Owen. A generic contact detection framework for cylindrical particles in discrete element modelling. Computer Methods in Applied Mechanics and Engineering , 315:632\u2013651, 2017. \u21a9 B. Nassauer, T. Liedke, and M. Kuna. Polyhedral particles for the discrete element method. Granular Matter , 15 1 1 :85\u201393, 2013. \u21a9 G.A. D'Addetta, F. Kun, and E. Ramm. On the application of a discrete model to the fracture process of cohesive granular materials. Granular matter , 4 2 2 :77\u201390, 2002. \u21a9 X. Lin and T.T. Ng. A three-dimensional discrete element model using arrays of ellipsoids. G\u00e9otechnique , 47 2 2 :319\u2013329, 1997. \u21a9 J.M. Ting, M. Khwaja, L.R. Meachum, and J.D. Rowell. An ellipse-based discrete element model for granular materials. International Journal for Numerical and Analytical Methods in Geomechanics , 17 9 9 :603\u2013623, 1993. \u21a9 J.R. Williams and A.P. Pentland. Superquadrics and modal dynamics for discrete elements in interactive design. Engineering Computations , 9 2 2 :115\u2013127, 1992. \u21a9 A. Podlozhnyuk, S. Pirker, and C. Kloss. Efficient implementation of superquadric particles in discrete element method within an open-source framework. Computational Particle Mechanics , 4 1 1 :101\u2013118, 2017. \u21a9 J. E. Andrade, K. W. Lim, C. F. Avila, and I. Vlahini\u0107. Granular element method for computational particle mechanics. Computer Methods in Applied Mechanics and Engineering , 241:262\u2013274, 2012. \u21a9 \u21a9 J.F. Peters, M.A. Hopkins, R. Kala, and R.E. Wahl. A poly-ellipsoid particle for non-spherical discrete element method. Engineering Computations , 26 6 6 :645\u2013657, 2009. \u21a9 B. Zhang, R. Regueiro, A. Druckrey, and K. Alshibli. Construction of poly-ellipsoidal grain shapes from SMT imaging on sand, and the development of a new DEM contact detection algorithm. Engineering Computations , 35 2 2 :733\u2013771, 2018. \u21a9 R. Kawamoto, E. And\u00f2, G. Viggiani, and J.E. Andrade. Level set discrete element method for three-dimensional computations with triaxial case study. Journal of the Mechanics and Physics of Solids , 91:1\u201313, 2016. \u21a9 N. Das. Modeling three-dimensional shape of sand grains using discrete element method . PhD thesis, University of South Florida, 2007. \u21a9 C. Kloss, C. Goniva, A. Hager, S. Amberger, and S. Pirker. Models, algorithms and validation for opensource DEM and CFD\u2013DEM. Progress in Computational Fluid Dynamics, an International Journal , 12 2 2 :140\u2013152, 2012. \u21a9 K. Iwashita and M. Oda. Rolling resistance at contacts in simulation of shear band development by dem. Journal of engineering mechanics , 124 3 3 :285\u2013292, 1998. \u21a9 S. Luding. Cohesive, frictional powders: contact models for tension. Granular matter , 10 4 4 :235, 2008. \u21a9 Y. Wang, F. Alonso-Marroquin, S. Xue, and J. Xie. Revisiting rolling and sliding in two-dimensional discrete element models. Particuology , 18:35\u201341, 2015. \u21a9 J. P. Plassiard, N. Belheine, and F. V. Donz\u00e9. A spherical discrete element model: calibration procedure and incremental response. Granular Matter , 11 5 5 :293\u2013306, 2009. \u21a9 S. Chehreghani, M. Noaparast, B. Rezai, and S. Z. Shafaei. Bonded-particle model calibration using response surface methodology. Particuology , 32:141\u2013152, 2017. \u21a9 C. J. Coetzee. Calibration of the discrete element method. Powder Technology , 310:104\u2013142, 2017. \u21a9 \u21a9 \u21a9 D. Schulze. Powders and bulk solids . Springer, Heidelberg, Germany, 2008. \u21a9","title":"DEM formulations"},{"location":"documentation/dem_formulations/#overview","text":"DEM is a particle-based numerical model that is particularly suitable for describing the mechanical behavior of bulk granular materials. It was first proposed by Cundall &Strack (1979) 2 for the analysis of geotechnical materials. Since then, DEM has been applied to model all kinds of granular materials and to simulate the problems ranging from solids handling to powder flowing in a variety of different engineering branches 3 4 5 . In DEM, all individual particles in the bulk granular material are explicitly modeled and a DEM model directly captures the interactions between particles and tracks the motions of each particle. The bulk behavior of a granular material is presented as an assembly of the actions (i.e., the interactions and motions) of all constituent particles. As a particle-based numerical model, DEM exhibits several advantages compared to the classical continuum theory-based numerical models. First, it bypasses the phenomenological constitutive models for describing the bulk behavior of a granular material within a representative volume 6 7 8 . Second, it is straightforward for the DEM to simulate the problems involving large deformation or material failure, such as granular flow, penetration, or strain localization 9 . The major drawback of DEM is also obvious. As DEM tracks the interactions and motions of all particles, DEM simulations are quite computationally expensive, which makes it difficult to scale up 10 11 . Nevertheless, with the advent of computer hardware and parallel capabilities, the DEM has become an increasingly powerful numerical tool that can provide valuable information of and shed lights upon the microscopic behavior of granular materials, which is often difficult or impossible to obtain from classical continuum-based numerical models or from physical experiments.","title":"Overview"},{"location":"documentation/dem_formulations/#key-components-of-dem","text":"","title":"Key components of DEM"},{"location":"documentation/dem_formulations/#basic-elements","text":"In general, there are two types of basic elements in a DEM model: particles and boundaries. The basic elements are assumed to be rigid but can have overlaps with each other. A particle is a body that has a closed surface. It may be represented by a simple geometry (e.g., sphere or ellipsoid) or a composition of several simple geometries that make up the body surface (see further discussions in ). A review on the particle geometric representations can be found in Zhong et al. (2016) 12 . Particles have mass and their motion (i.e., position, velocity, and acceleration) is always tracked during a DEM simulation. Boundaries are also referred to as walls in the DEM literature. They may as well be represented by simple geometries (e.g., triangles) or their combinations, but they do not necessarily have closed surfaces. Boundaries do not have mass and their position and velocity are usually prescribed to provide the desired constraints to the particles in the model.","title":"Basic elements"},{"location":"documentation/dem_formulations/#contacts-and-contact-models","text":"Contacts describe the interactions between basic elements. Contact occurs when the surfaces of two basic elements overlap with each other (to model collisions), or when the surfaces are within a specified distance (to model long-range bond or cohesion). Detecting the contacts between basic elements is a mathematical geometry problem and is one of the most time-consuming parts of a DEM simulation. One important task associated with contact detection is to characterize the contact geometric features, which are needed by a contact model to calculate the contact forces and moments. The contact features may include the overlapping (or indentation) distance, relative shear displacement, contact point, contact branch vectors, and so on. Contact models are used to calculate the contact forces and moments between the two elements in contact. Commonly used contact models include the linear elastic model 2 , the rolling resistance model 13 14 , the Hertz-Mindlin model 15 16 17 , and the linear parallel bond model 18 . The formulation of these contact models will be presented in .","title":"Contacts and contact models"},{"location":"documentation/dem_formulations/#newton-euler-equations-of-motion","text":"In DEM, the motion of a particle can be described by the Newton-Euler equations of motion. For any arbitrarily-shaped particle, the Newton-Euler equations of motion are written as \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M}\\end{aligned} \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M}\\end{aligned} where m m is the mass of the particle; \\boldsymbol{I} \\boldsymbol{I} is the inertia tensor of the particle; \\boldsymbol{a} \\boldsymbol{a} and \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} are the translational and rotational acceleration; \\boldsymbol{F} \\boldsymbol{F} and \\boldsymbol{M} \\boldsymbol{M} are the overall external forces and moments acting on the particle; \\boldsymbol{\\omega} \\boldsymbol{\\omega} is the vector of the angular velocities about the principal axes. Herein, the variable in bold-symbol indicates a vector or a tensor. For spherical particles, the Newton-Euler equations of motion reduce to \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M}\\end{aligned} \\begin{aligned} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M}\\end{aligned} In order to resolve the motion of each particle, all the forces and moments acting on the particle need to be evaluated and summed, which may include gravity, damping, contact forces and moments, and prescribed external forces and moments. Herein, the damping refers to the global damping, which is sometimes (artificially) introduced in a DEM model to facilitate energy dissipation and enhance a quasi-static simulation 19 20 . There is another type of damping called local damping, which is usually incorporated into a contact model as dash-pot forces to account for the realistic energy dissipation due to particle interactions.","title":"Newton-Euler equations of motion"},{"location":"documentation/dem_formulations/#time-integration","text":"To fully resolve the particle motion (e.g., the position and velocity) governed by and involves the time integration scheme, where the second-order Velocity Verlet algorithm is commonly adopted. For spherical particles, suppose that the current state is indexed by time t t and the time increment to the next state is \\Delta t \\Delta t , Velocity Verlet algorithm first calculates the particle velocities at time t t + \\Delta t/2 \\Delta t/2 by \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2\\end{aligned} \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2\\end{aligned} where \\boldsymbol{v} \\boldsymbol{v} and \\boldsymbol{\\omega} \\boldsymbol{\\omega} are translational and angular velocities, respectively. The superscripts (e.g., t t and \\Delta t/2 \\Delta t/2 ) indicate the time indexes. Then, the position and orientation of the particle at time t t + \\Delta t \\Delta t are calculated as \\begin{aligned} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{aligned} \\begin{aligned} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{aligned} where \\boldsymbol{x} \\boldsymbol{x} is the vector of position and \\boldsymbol{\\theta} \\boldsymbol{\\theta} is the vector of orientation. Correspondingly, the translational velocity and angular velocity at time t+\\Delta t t+\\Delta t are updated by \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{aligned} \\begin{aligned} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{aligned} For non-spherical particles, the original Newton-Euler equations of motion cannot be simplified, and the calculation of the orientations and angular velocity will be much more complicated. A more detailed discussion on the time integration for non-spherical particles will not be included here but can be found in the work of Chung (2006) 19 and the PFC user manual 20 .","title":"Time integration"},{"location":"documentation/dem_formulations/#critical-timestep","text":"The time integration based on the second-order Velocity Verlet algorithm is numerically stable only when the time increment being used is less than a threshold value, i.e. the critical timestep 21 . If a time increment greater than the critical timestep is used, particles may move too much in one increment, which will result in spuriously infinite overlapping (i.e., abnormally large contact forces). A summary and empirical assessment of different approaches to estimate the critical timestep for DEM simulations can be found in Otsubo et al. (2017) 21 . Basically, there are two categories of approaches to estimate the critical timestep: the oscillation period of a single degree of freedom system (SDOF) based approaches 2 22 , and the Rayleigh wave speed based approaches 23 24 . The former approaches consider the DEM system to be consist of rigid bodies connected by springs, while the latter ones consider the particles themselves to be springs. In the category of the SDOF-based approaches, Cundall & Stract (1979) 2 proposed the following expression to estimate the critical timestep \\Delta t_\\text{crit} \\Delta t_\\text{crit} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) where m m is the mass of the particle; I_i I_i is the moment of inertia of the particle; k^\\text{tran} k^\\text{tran} and k_i^\\text{rot} k_i^\\text{rot} represent the translational and rotational stiffness, and the subscript i i indicates the index of principal components. In the category of the Rayleigh wave speed based approaches, Li et al. (2005) 24 proposed that \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} where R R is the average particle radius; \\rho \\rho is the particle density; G G the particle shear modulus; and \\nu \\nu the Poisson's ratio of the particle.","title":"Critical timestep"},{"location":"documentation/dem_formulations/#computational-workflow","text":"DEM-based numerical simulations require cyclic calculations. shows the workflow and calculations that are involved in one typical cycle of a DEM simulation. The workflow and calculations for one DEM cycle can be summarized as follows: At the current state, the positions and velocities of all particles are known: based on the geometries of all particles, identify the inter-particle contacts and evaluate contact features; Calculate the external forces and moments of all particles, while the contact forces and moments are calculated based on selected contact models and the corresponding contact features; Calculate the motion (i.e., the accelerations) of all particles; Update the positions and velocities of all particles following the selected time integration scheme.","title":"Computational workflow"},{"location":"documentation/dem_formulations/#particle-representation","text":"There are basically two groups of methods to represent an irregular particle in DEM 12 : single-particle method and composite-particle method.","title":"Particle representation"},{"location":"documentation/dem_formulations/#single-particle-method","text":"The single-particle method utilizes closed geometries to represent particle shapes. Many single-particle-based DEM models have been proposed and developed with the adoption of some specific closed geometries, such as cylinder 25 , polyhedron (or polygon in 2D) 26 27 , ellipsoid (or ellipse in 2D) 28 29 , superquadrics 30 31 , Non-Uniform Rational Basis Spline (NURBS) 32 , as well as their combinations (e.g., poly-ellipsoid 33 34 ). Each of these methods has its own advantages and limitations. The application of the cylinder-based or ellipsoid-based DEM models is limited, due to the particular particle shapes they can represent. The superquadric can be considered as an extension of the ellipsoid and can be used for modeling of spheres, ellipsoids, cylinder-like and box(dice)-like particles by varying the shape parameters. It is more flexible by being able to model larger variations of particle shapes, but also more computationally expensive than the ellipsoid-based DEM models. The polyhedron- (or polygon in 2D) based DEM model is able to replicate arbitrary particle shapes. The accuracy of the shape represented by polyhedron depends on the number of faces in a polyhedron, whereas a large number of faces would hinder the computational efficiency. Moreover, polyhedron can rarely replicate a smooth particle shape. The NURBS based granular element method, developed by Andrade et al. (2012) 32 , is advantageous to replicate general and smooth particle shapes, whereas it is computationally expensive compared to the polyhedron-based DEM. Recently, Kawamoto et al. (2016) 35 developed another novel type of single-particle-based DEM, which utilizes the level set (LS) method to represent particles. The LS-DEM seamlessly utilizes the level set data of realistic particle shapes characterized from X-ray computational tomography and is computationally efficient. One issue with the LS-DEM is high memory consumption, which somewhat limits its application on large particulate systems.","title":"Single-particle method"},{"location":"documentation/dem_formulations/#composite-particle-method","text":"In a composite-particle method, a particle is represented by compositions of simple geometries (usually spheres in 3D or circles in 2D 36 1 ). This group of methods is advantageous to implementation for that the contact detection and resolution algorithms for the simple geometries can be effortlessly exploited. It should be noted that the accuracy of particle shape represented by compositions of simple geometries depends on the amount of the simple geometries, and a large number of simple geometries would lead to great computational expense though. Nonetheless, the composite-particle method (especially with spheres as the base elements) is currently the most prevalent method to model irregular particles and is supported in most commercial or open-source DEM packages such as PFC 20 and LIGGGHTS 37 . There are three options to represent a composite particle (a) (b) (c) A schematic illustration of the three options to represent a composite particle with discs (modified after 1 )","title":"Composite-particle method"},{"location":"documentation/dem_formulations/#contact-models","text":"A DEM contact model is normally comprised of springs, dash-pots, and sliders to describe the force-displacement behavior at the contact, where the springs account for normal and tangential forces, the dash-pots account for local damping, and the sliders account for shear failure. The formulation of contact models that will be used in this dissertation is presented in this section.","title":"Contact models"},{"location":"documentation/dem_formulations/#linear-elastic-model","text":"A linear elastic model generally consists of two elastic springs, two dash-pots, and a slider, as shown schematically in the following. The contact forces \\boldsymbol{F} \\boldsymbol{F} are calculated from two parts: the normal force \\boldsymbol{F}_n \\boldsymbol{F}_n and the shear (or tangential) force \\boldsymbol{F}_s \\boldsymbol{F}_s \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s where \\boldsymbol{n}_n \\boldsymbol{n}_n and \\boldsymbol{n}_s \\boldsymbol{n}_s are the unit vectors denoting the direction of the normal and the shear force, respectively; F_n F_n and F_s F_s are the magnitudes of corresponding contact forces. Assuming the relative displacement increment at the contact during a timestep \\Delta t \\Delta t is given by its components \\Delta \\delta_n \\Delta \\delta_n (compression as a positive) and \\Delta \\delta_s \\Delta \\delta_s , the contact law for a simple linear model with local damping updates the contact forces through 2 20 \\begin{aligned}F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n)\\end{aligned} \\begin{aligned}F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n)\\end{aligned} where F_n^0 F_n^0 and F_s^0 F_s^0 are the normal and the shear forces at the beginning of the current timestep, respectively; k_n k_n and k_s k_s are the corresponding stiffness; \\eta_n \\eta_n and \\eta_s \\eta_s are the corresponding damping coefficients; \\dot{\\delta}_n \\dot{\\delta}_n and \\dot{\\delta}_s \\dot{\\delta}_s are the relative normal and shear velocity; \\mu_c \\mu_c is the contact friction coefficient; and \\bar{m} = m_im_j/(m_i+m_j) \\bar{m} = m_im_j/(m_i+m_j) is the effective mass of particles i i and j j associated with the contact, while \\bar{m} = m_i \\bar{m} = m_i for the case of particle-boundary contact.","title":"Linear elastic model"},{"location":"documentation/dem_formulations/#rolling-resistance-model","text":"The rolling resistance model is built upon the linear elastic model by adding a term of rolling resistance moment to the contact moment. The formulation to calculate the additional rolling resistance moment can be written as 38 13 20 M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) where M^0 M^0 is the contact moment at the beginning of the current timestep; \\Delta\\theta_b \\Delta\\theta_b is the relative bending-rotation increment; \\mu_r \\mu_r is the rolling resistance coefficient; k_r k_r is the rolling resistance stiffness defined as: k_r = k_s\\bar{R}^2 k_r = k_s\\bar{R}^2 where \\bar{R} \\bar{R} is the contact effective radius defined as \\bar{R}=R_iR_j/(R_i+R_j) \\bar{R}=R_iR_j/(R_i+R_j) , in which R_i R_i and R_j R_j are the radii of the contact particles. If one side of the contact is a wall, the corresponding radius R_j \\rightarrow \\infty R_j \\rightarrow \\infty . This model uses a simplified formulation for the rolling kinematics, and the particle size effects on the rolling resistance are implicitly incorporated in the rolling stiffness term. The interested reader is referred to Luding (2008) 39 , Wang et al. (2015) 40 for examples of improved and more advanced rolling resistance models.","title":"Rolling resistance model"},{"location":"documentation/dem_formulations/#hertz-mindlin-model","text":"The Hertz-Mindlin model is a complete frictional contact model based upon the Hertz theory 15 for contact normal forces and the Mindlin theory 16 for contact tangential forces. It takes into account the stiffness variation due to the change of contact areas during the collision of two elastic spheres. Similar to the linear elastic model, the Hertz-Mindlin model also consists of two springs, two dash-pots, and a slider. There are, however, two major differences. First, the normal and shear stiffness in the Hertz-Mindlin model are functions of the contact overlapping distance. Second, the normal contact force in the Hertz-Mindlin model is calculated via the cumulative overlapping distance, while the linear elastic model uses either the cumulative or incremental overlapping distance. To update the contact forces, the Hertz-Mindlin model follows \\begin{aligned} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{aligned} \\begin{aligned} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{aligned} where \\delta_n \\delta_n is the cumulative overlapping distance, while k_n k_n and k_s k_s are calculated as 17 : \\begin{aligned} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{aligned} \\begin{aligned} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{aligned} in which \\begin{aligned} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{aligned} \\begin{aligned} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{aligned} where \\bar{E} \\bar{E} and \\bar{G} \\bar{G} are the effective Young's modulus and shear modulus of the particles in contact; E_i E_i is the Young's modulus and \\nu_i \\nu_i is the Poisson's ratio of the i i th particle.","title":"Hertz-Mindlin model"},{"location":"documentation/dem_formulations/#linear-parallel-bond-model","text":"The linear parallel bond model describes the contact behavior of two bonded particles, as shown schematically in the following. In the linear parallel bond model, the bond between two spheres is assumed to be a cylinder of finite radius and thickness. Each point in the bond is imposed by two linear elastic springs providing normal and shear resistances, respectively. The overall bonding force and moment are the integral of the normal and shear stresses at a cross-section of the bond, which can be calculated as 18 \\begin{aligned} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s\\end{aligned} \\begin{aligned} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s\\end{aligned} where F_n^b F_n^b , F_s^b F_s^b , M_n^b M_n^b and M_s^b M_s^b are the bond normal force, shear force, twisting moment, and swinging moment, respectively; \\delta_n \\delta_n , \\delta_s \\delta_s , \\theta_n \\theta_n , and \\theta_s \\theta_s are the relative normal displacement, shear displacement, twisting rotation, and swinging rotation between the two bonded spheres, respectively; A A , I I , and J J are the area, moment of inertia, and polar moment of inertia of the bond (i.e., the circular cross-section with radius R^b R^b ), respectively; and \\Delta \\Delta indicates the increment of each variable in each time step. It should be pointed out that, while the damping is not included in the current formulation, damping terms similar to those in the linear elastic model can be incorporated in a straightforward manner. The bonded-sphere model is also capable of modeling the particle breakage behavior. As an example of a common bond breakage criterion, it can be assumed that a bond would break if the maximum normal or shear stress at the bond exceeds the corresponding normal or shear strength. In the linear parallel bond model, both the normal force and swinging moment contribute to the normal stress, while both the shear force and twisting moment contribute to the shear stress. In this regard, the bond breakage criterion can be written as \\begin{aligned} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{aligned} \\begin{aligned} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{aligned} where \\sigma_{Y,n}^b \\sigma_{Y,n}^b and \\sigma_{Y,s}^b \\sigma_{Y,s}^b are the normal and shear strength, respectively.","title":"Linear parallel bond model"},{"location":"documentation/dem_formulations/#model-calibration","text":"As most of the contact parameters in a DEM model are difficult if not impossible to be measured directly from physical tests, a calibration process is often needed to obtain the contact parameters for a specific material of interest. There are some researches available on the procedures to calibrate contact parameters for a DEM model 41 42 43 . Usually, the calibration process is accomplished by performing parametric studies on each of contact parameters and selecting values of the contact parameters with which the DEM simulation can reproduce the benchmark matrices of laboratory experiments. Commonly used laboratory experiments for calibration of DEM parameters include compression test, direct and ring shear test, and angle of repose test. Descriptions of these tests can be found in Schulze (2008) 44 , Coetzee (2017) 43 . There are some challenges and problems associated with the model calibration. First, to obtain reasonable and realistic contact parameters via calibration, it is necessary that the setup and procedures in the DEM models are to the most extent similar to those in the laboratory experiments. However, in order to get the DEM simulations performed within affordable computational resources, adjustments or tolerances in the particle size, shape or testing speed may exist in a DEM model. As a result, the calibrated contact parameters may deviate from their actual values to some degree. In addition, the contact features and contact models are usually quite simple and conceptual compared to the actual complex contact behavior. The physical meaning of the contact parameters may be lost due to the use of conceptualized contact features and contact models. Lastly, as pointed out in 43 , the solution of contact parameters might not be unique since all contact parameters may affect the results of a DEM simulation in a complex and highly nonlinear manner. There is no guarantee that the contact parameters for a material calibrated for one experiment will be workable for another. In this regard, it would be necessary to perform the calibration with one experiment and validate the calibration results via another. C. Shi, D. Li, W. Xu, and R. Wang. Discrete element cluster modeling of complex mesoscopic particles for use with the particle flow code method. Granular Matter , 17 3 3 :377\u2013387, 2015. \u21a9 \u21a9 P. A Cundall and O. D. L. Strack. A discrete numerical model for granular assemblies. geotechnique , 29 1 1 :47\u201365, 1979. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 P.W. Cleary. Industrial particle flow modelling using discrete element method. Engineering Computations , 26 6 6 :698\u2013743, 2009. \u21a9 E. Tijskens, H. Ramon, and J. De Baerdemaeker. Discrete element modelling for process simulation in agriculture. Journal of sound and vibration , 266 3 3 :493\u2013514, 2003. \u21a9 C. O'Sullivan. Particle-based discrete element modeling: geomechanics perspective. International Journal of Geomechanics , 11 6 6 :449\u2013464, 2011. \u21a9 J.E. Andrade and C.F. Avila. Granular element method GEM GEM : linking inter-particle forces with macroscopic loading. Granular Matter , 14 1 1 :51\u201361, 2012. \u21a9 J.E. Andrade, Q. Chen, P.H. Le, C.F. Avila, and T.M. Evans. On the rheology of dilative granular media: bridging solid-and fluid-like behavior. Journal of the Mechanics and Physics of Solids , 60 6 6 :1122\u20131136, 2012. \u21a9 N. Guo and J. Zhao. Multiscale insights into classical geomechanics problems. International Journal for Numerical and Analytical Methods in Geomechanics , 40 3 3 :367\u2013390, 2016. \u21a9 Q. Chen. Multiscale Modeling of Failure in Granular Media: From Continuum Scales to Granular Scale . PhD thesis, Northwestern University, 2011. \u21a9 P. Liu and C.M. Hrenya. Challenges of DEM: I. Competing bottlenecks in parallelization of gas\u2013solid flows. Powder Technology , 264:620\u2013626, 2014. \u21a9 K.J. Berger and C.M. Hrenya. Challenges of DEM: II. Wide particle size distributions. Powder Technology , 264:627\u2013633, 2014. \u21a9 W. Zhong, A. Yu, X. Liu, Z. Tong, and H. Zhang. DEM/CFD-DEM modelling of non-spherical particulate systems: theoretical developments and applications. Powder Technology , 302:108\u2013152, 2016. \u21a9 \u21a9 M. Jiang, H. S. Yu, and D. Harris. A novel discrete model for granular material incorporating rolling resistance. Computers and Geotechnics , 32 5 5 :340\u2013357, 2005. \u21a9 \u21a9 M. Jiang, Z. Shen, and J. Wang. A novel three-dimensional contact model for granulates incorporating rolling and twisting resistances. Computers and Geotechnics , 65:147\u2013163, 2015. \u21a9 H.R. Hertz. Uber die Beruhrung fester elastischer Korper und Uber die Harte. Verhandlung des Vereins zur Beforderung des GewerbefleiBes, Berlin , pages 449, 1882. \u21a9 \u21a9 R.D. Mindlin. Elastic spheres in contact under varying oblique forces. Journal of Applied Mechanics , 20:327\u2013344, 1953. \u21a9 \u21a9 A. Di Renzo and F.P. Di Maio. An improved integral non-linear model for the contact of particles in distinct element simulations. Chemical Engineering Science , 60 5 5 :1303\u20131312, 2005. \u21a9 \u21a9 D. O. Potyondy and P. A. Cundall. A bonded-particle model for rock. International journal of rock mechanics and mining sciences , 41 8 8 :1329\u20131364, 2004. \u21a9 \u21a9 Y.C. Chung. Discrete element modelling and experimental validation of a granular solid subject to different loading conditions . PhD thesis, University of Edinburgh, 2006. \u21a9 \u21a9 \u21a9 Itasca Consulting Group, Inc. PFC \u2013 Particle Flow Code, Ver. 5.0. 2014. Minneapolis: Itasca. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 M. Otsubo, C. O'Sullivan, and T. Shire. Empirical assessment of the critical time increment in explicit particulate discrete element method simulations. Computers and Geotechnics , 86:67\u201379, 2017. \u21a9 \u21a9 R. Hart, P.A. Cundall, and J. Lemos. Formulation of a three-dimensional distinct element model\u2013Part II. Mechanical calculations for motion and interaction of a system composed of many polyhedral blocks. International Journal of Rock Mechanics and Mining Sciences & Geomechanics Abstracts , 25 3 3 :117\u2013125, 1988. \u21a9 C. Thornton. Numerical simulations of deviatoric shear deformation of granular media. G\u00e9otechnique , 50 1 1 :43\u201353, 2000. \u21a9 Y. Li, Y. Xu, and C. Thornton. A comparison of discrete element simulations and experiments for `sandpiles' composed of spherical particles. Powder Technology , 160 3 3 :219\u2013228, 2005. \u21a9 \u21a9 Y.T. Feng, K. Han, and D.R.J. Owen. A generic contact detection framework for cylindrical particles in discrete element modelling. Computer Methods in Applied Mechanics and Engineering , 315:632\u2013651, 2017. \u21a9 B. Nassauer, T. Liedke, and M. Kuna. Polyhedral particles for the discrete element method. Granular Matter , 15 1 1 :85\u201393, 2013. \u21a9 G.A. D'Addetta, F. Kun, and E. Ramm. On the application of a discrete model to the fracture process of cohesive granular materials. Granular matter , 4 2 2 :77\u201390, 2002. \u21a9 X. Lin and T.T. Ng. A three-dimensional discrete element model using arrays of ellipsoids. G\u00e9otechnique , 47 2 2 :319\u2013329, 1997. \u21a9 J.M. Ting, M. Khwaja, L.R. Meachum, and J.D. Rowell. An ellipse-based discrete element model for granular materials. International Journal for Numerical and Analytical Methods in Geomechanics , 17 9 9 :603\u2013623, 1993. \u21a9 J.R. Williams and A.P. Pentland. Superquadrics and modal dynamics for discrete elements in interactive design. Engineering Computations , 9 2 2 :115\u2013127, 1992. \u21a9 A. Podlozhnyuk, S. Pirker, and C. Kloss. Efficient implementation of superquadric particles in discrete element method within an open-source framework. Computational Particle Mechanics , 4 1 1 :101\u2013118, 2017. \u21a9 J. E. Andrade, K. W. Lim, C. F. Avila, and I. Vlahini\u0107. Granular element method for computational particle mechanics. Computer Methods in Applied Mechanics and Engineering , 241:262\u2013274, 2012. \u21a9 \u21a9 J.F. Peters, M.A. Hopkins, R. Kala, and R.E. Wahl. A poly-ellipsoid particle for non-spherical discrete element method. Engineering Computations , 26 6 6 :645\u2013657, 2009. \u21a9 B. Zhang, R. Regueiro, A. Druckrey, and K. Alshibli. Construction of poly-ellipsoidal grain shapes from SMT imaging on sand, and the development of a new DEM contact detection algorithm. Engineering Computations , 35 2 2 :733\u2013771, 2018. \u21a9 R. Kawamoto, E. And\u00f2, G. Viggiani, and J.E. Andrade. Level set discrete element method for three-dimensional computations with triaxial case study. Journal of the Mechanics and Physics of Solids , 91:1\u201313, 2016. \u21a9 N. Das. Modeling three-dimensional shape of sand grains using discrete element method . PhD thesis, University of South Florida, 2007. \u21a9 C. Kloss, C. Goniva, A. Hager, S. Amberger, and S. Pirker. Models, algorithms and validation for opensource DEM and CFD\u2013DEM. Progress in Computational Fluid Dynamics, an International Journal , 12 2 2 :140\u2013152, 2012. \u21a9 K. Iwashita and M. Oda. Rolling resistance at contacts in simulation of shear band development by dem. Journal of engineering mechanics , 124 3 3 :285\u2013292, 1998. \u21a9 S. Luding. Cohesive, frictional powders: contact models for tension. Granular matter , 10 4 4 :235, 2008. \u21a9 Y. Wang, F. Alonso-Marroquin, S. Xue, and J. Xie. Revisiting rolling and sliding in two-dimensional discrete element models. Particuology , 18:35\u201341, 2015. \u21a9 J. P. Plassiard, N. Belheine, and F. V. Donz\u00e9. A spherical discrete element model: calibration procedure and incremental response. Granular Matter , 11 5 5 :293\u2013306, 2009. \u21a9 S. Chehreghani, M. Noaparast, B. Rezai, and S. Z. Shafaei. Bonded-particle model calibration using response surface methodology. Particuology , 32:141\u2013152, 2017. \u21a9 C. J. Coetzee. Calibration of the discrete element method. Powder Technology , 310:104\u2013142, 2017. \u21a9 \u21a9 \u21a9 D. Schulze. Powders and bulk solids . Springer, Heidelberg, Germany, 2008. \u21a9","title":"Model calibration"},{"location":"documentation/developer_manual/","text":"Coding style We generally follow Google C++ Style Guide . Naming Filenames: lowercase words connected by underscores, e.g. particle.hpp , contact_pp.cpp . Variable names: lowercase words connected by underscores, e.g. dir_n . Class and struct names: words with first letters capitalized, e.g. DataDumper . Macros: should be capital, such as PI . Comment Comment is not a requisite, but please add it if an attribute or method is not self-explainary or is ambigious. We use doxygen to generate the code documentation. We suggest the following comment format. Block documentation (e.g., for class description): /** descriptions */ Line documentation: /// descriptions Other commands if approperiate: @warning {warning message}, @todo {things to be done}, @bug , @brief, @var\u3001@enum\u3001@struct\u3001@class\u3001 Formatting Use clang-format . Programing rules Use auto for local variables when appropriate. Mark const when appropriate. Reference vs. pointer: If a variable will not be altered after calling the function, use reference with const mark, e.g., const double &[variable] . If a variable will be altered, use pointer. For int or double, as well as lists of int or double, mark with const (e.g., double *const [variable] ) to aboid mistakenly modifying the pointer. If a variable will not be altered but its value will be passed and stored the calling instance, use pointer. Following the previous item, if you are going to modify a variable, please declare it or passing it as an argument with with & . Prefer use c++ std library rather than c library, e.g., use <cmath> rather than <math.h> . Avoid using smart pointers, such as std::unique_ptr , std::shared_ptr . Never ever use \"using\" (e.g., using namespace std ) in headers . Performance evaluation Procedures Tool: linux perf To probe the performance\uff1a sudo perf stat build/bin/tmp_debug Performance counter stats for 'build/bin/tmp_debug': 12,639.97 msec task-clock # 0.983 CPUs utilized 1,284 context-switches # 0.102 K/sec 42 cpu-migrations # 0.003 K/sec 13,356 page-faults # 0.001 M/sec 26,566,855,696 cycles # 2.102 GHz 56,713,820,846 instructions # 2.13 insn per cycle 10,275,875,523 branches # 812.967 M/sec 31,362,265 branch-misses # 0.31% of all branches 12.857522834 seconds time elapsed 11.472000000 seconds user 1.120000000 seconds sys To sample CPU usage: sudo perf record -e task-clock -g build/bin/tmp_debug sudo perf report -i perf.data To generate heat map and visual: git clone --depth 1 https://github.com/brendangregg/FlameGraph.git FlameGraph/stackcollapse-perf.pl out.perf > out.folded FlameGraph/flamegraph.pl out.folded > out.svg sudo perf script > out.perf # then upload out.perf to https://www.speedscope.app/ to visual","title":"Developer manual"},{"location":"documentation/developer_manual/#_1","text":"","title":""},{"location":"documentation/developer_manual/#coding-style","text":"We generally follow Google C++ Style Guide .","title":"Coding style"},{"location":"documentation/developer_manual/#naming","text":"Filenames: lowercase words connected by underscores, e.g. particle.hpp , contact_pp.cpp . Variable names: lowercase words connected by underscores, e.g. dir_n . Class and struct names: words with first letters capitalized, e.g. DataDumper . Macros: should be capital, such as PI .","title":"Naming"},{"location":"documentation/developer_manual/#comment","text":"Comment is not a requisite, but please add it if an attribute or method is not self-explainary or is ambigious. We use doxygen to generate the code documentation. We suggest the following comment format. Block documentation (e.g., for class description): /** descriptions */ Line documentation: /// descriptions Other commands if approperiate: @warning {warning message}, @todo {things to be done}, @bug , @brief, @var\u3001@enum\u3001@struct\u3001@class\u3001","title":"Comment"},{"location":"documentation/developer_manual/#formatting","text":"Use clang-format .","title":"Formatting"},{"location":"documentation/developer_manual/#programing-rules","text":"Use auto for local variables when appropriate. Mark const when appropriate. Reference vs. pointer: If a variable will not be altered after calling the function, use reference with const mark, e.g., const double &[variable] . If a variable will be altered, use pointer. For int or double, as well as lists of int or double, mark with const (e.g., double *const [variable] ) to aboid mistakenly modifying the pointer. If a variable will not be altered but its value will be passed and stored the calling instance, use pointer. Following the previous item, if you are going to modify a variable, please declare it or passing it as an argument with with & . Prefer use c++ std library rather than c library, e.g., use <cmath> rather than <math.h> . Avoid using smart pointers, such as std::unique_ptr , std::shared_ptr . Never ever use \"using\" (e.g., using namespace std ) in headers .","title":"Programing rules"},{"location":"documentation/developer_manual/#performance-evaluation","text":"","title":"Performance evaluation"},{"location":"documentation/developer_manual/#procedures","text":"Tool: linux perf To probe the performance\uff1a sudo perf stat build/bin/tmp_debug Performance counter stats for 'build/bin/tmp_debug': 12,639.97 msec task-clock # 0.983 CPUs utilized 1,284 context-switches # 0.102 K/sec 42 cpu-migrations # 0.003 K/sec 13,356 page-faults # 0.001 M/sec 26,566,855,696 cycles # 2.102 GHz 56,713,820,846 instructions # 2.13 insn per cycle 10,275,875,523 branches # 812.967 M/sec 31,362,265 branch-misses # 0.31% of all branches 12.857522834 seconds time elapsed 11.472000000 seconds user 1.120000000 seconds sys To sample CPU usage: sudo perf record -e task-clock -g build/bin/tmp_debug sudo perf report -i perf.data To generate heat map and visual: git clone --depth 1 https://github.com/brendangregg/FlameGraph.git FlameGraph/stackcollapse-perf.pl out.perf > out.folded FlameGraph/flamegraph.pl out.folded > out.svg sudo perf script > out.perf # then upload out.perf to https://www.speedscope.app/ to visual","title":"Procedures"},{"location":"documentation/user_manual/","text":"Installation Prerequisites The compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt install build-essential sudo apt-get install -y autoconf-archive automake cmake texinfo sudo apt-get install openmpi-bin libopenmpi-dev libboost-all-dev Compile and build make sync_submodule make If some third-party libraries have not been or cannot be downloaded successfully, you can delete them and do a git checkout contrib and make sync_submodule again. Test the installation ./scripts/run_tests.sh Related to installation Installation on Apple M1 (As of Dec. 20 2021) OpenMP seems not compitible with Apple M1. To enforce an OpenMP installation, set USE_INTERNAL_OPENMP in netdem CMakeLists.txt to OFF , and use brew install libomp to install a pre-built copy of OpenMP. Add M1 support to fast_winding_number functional in igl via SIMDE (please see the discussion in https://github.com/sideeffects/WindingNumber/pull/3/files ): Install simde using brew install simde . Add -flax-vector-conversions to the gcc complier flag in netdem CMakeLists.txt . Add the following lines to the FastWindingNumberForSoups in igl and comment out the #include <emmintrin.h> line. #define SIMDE_ENABLE_NATIVE_ALIASES #include <simde/x86/sse.h> #include <simde/x86/sse4.1.h> // Recent GCC define the macro in x86intrin.h #ifndef _MM_MK_INSERTPS_NDX #define _MM_MK_INSERTPS_NDX(srcField, dstField, zeroMask) (((srcField)<<6) | ((dstField)<<4) | (zeroMask)) #endif Build netdem following the original procedures. Although we can build netdem via this work-around, we may encounter runtime errors that might be related with OpenMP . Some errors are listed bellow: terminate called after throwing an instance of 'std::bad_array_new_length' Dependencies git , gcc , cmake : for code developing, configuring and compiling mpich or open mpi : for parallel computing json : for input data interchange cork : for mesh boolean operation gmp igl : another option of mesh boolean operation (robust but much slower than cork) cgal (requires boost , gmp , mpfr ), openmp , eigen googletest : for tests mlpack : for machine learning libraries armadillo (requires lapack , arpack , openblas ), ensmallen , cereal , boost , stb Using dependencies already in the system would save the time required by the compilation of the whole project. Some dependencies (e.g., mlpack) would take fairly long time to compile. One can check out the log files in contrib/[package]/ep/src/[package]-stamp/ for the compiling, building and installing progresses of the dependencies. Some packages (e.g., boost and mpi ) could take forever to compile. It is recommended that you install pre-build boost and mpi using tools such as brew install in mac os, or apt-get install in ubantu. Run built-in examples There are some built-in examples defined in the examples/ directory. Once the software is installed, it will create an excutable file in the build/bin directory. Run an example using the following command in the root directory. The results will be stored in tmp/out/ directory after the running of the example. ./build/bin/netdem_example_random_packing Visualize the results in paraview . For irregular-shaped particles, use the following command to generate the results with particles represented by triangle meshes. ./build/bin/netdem_tool_point2mesh [in.vtk] [out.vtk] [shape_dir] In case one need to do the generation in batch, the following command can be used ./scripts/batch_data_point2mesh.sh [in_dir] [out_dir] [shape_dir] or easier ./scripts/auto_mesh_particle.sh [out_dir] ./scripts/auto_mesh_wall.sh [out_dir] Visualize & post-process Results can be dumped as VTK files, which can be visualized in paraview . We have a side-repository that provides some matlab or python scripts for post-process (e.g., VTK io, stress-strain, spherical histograms of contact anisotropy).","title":"User manual"},{"location":"documentation/user_manual/#_1","text":"","title":""},{"location":"documentation/user_manual/#installation","text":"","title":"Installation"},{"location":"documentation/user_manual/#prerequisites","text":"The compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt install build-essential sudo apt-get install -y autoconf-archive automake cmake texinfo sudo apt-get install openmpi-bin libopenmpi-dev libboost-all-dev","title":"Prerequisites"},{"location":"documentation/user_manual/#compile-and-build","text":"make sync_submodule make If some third-party libraries have not been or cannot be downloaded successfully, you can delete them and do a git checkout contrib and make sync_submodule again.","title":"Compile and build"},{"location":"documentation/user_manual/#test-the-installation","text":"./scripts/run_tests.sh","title":"Test the installation"},{"location":"documentation/user_manual/#related-to-installation","text":"","title":"Related to installation"},{"location":"documentation/user_manual/#installation-on-apple-m1","text":"(As of Dec. 20 2021) OpenMP seems not compitible with Apple M1. To enforce an OpenMP installation, set USE_INTERNAL_OPENMP in netdem CMakeLists.txt to OFF , and use brew install libomp to install a pre-built copy of OpenMP. Add M1 support to fast_winding_number functional in igl via SIMDE (please see the discussion in https://github.com/sideeffects/WindingNumber/pull/3/files ): Install simde using brew install simde . Add -flax-vector-conversions to the gcc complier flag in netdem CMakeLists.txt . Add the following lines to the FastWindingNumberForSoups in igl and comment out the #include <emmintrin.h> line. #define SIMDE_ENABLE_NATIVE_ALIASES #include <simde/x86/sse.h> #include <simde/x86/sse4.1.h> // Recent GCC define the macro in x86intrin.h #ifndef _MM_MK_INSERTPS_NDX #define _MM_MK_INSERTPS_NDX(srcField, dstField, zeroMask) (((srcField)<<6) | ((dstField)<<4) | (zeroMask)) #endif Build netdem following the original procedures. Although we can build netdem via this work-around, we may encounter runtime errors that might be related with OpenMP . Some errors are listed bellow: terminate called after throwing an instance of 'std::bad_array_new_length'","title":"Installation on Apple M1"},{"location":"documentation/user_manual/#dependencies","text":"git , gcc , cmake : for code developing, configuring and compiling mpich or open mpi : for parallel computing json : for input data interchange cork : for mesh boolean operation gmp igl : another option of mesh boolean operation (robust but much slower than cork) cgal (requires boost , gmp , mpfr ), openmp , eigen googletest : for tests mlpack : for machine learning libraries armadillo (requires lapack , arpack , openblas ), ensmallen , cereal , boost , stb Using dependencies already in the system would save the time required by the compilation of the whole project. Some dependencies (e.g., mlpack) would take fairly long time to compile. One can check out the log files in contrib/[package]/ep/src/[package]-stamp/ for the compiling, building and installing progresses of the dependencies. Some packages (e.g., boost and mpi ) could take forever to compile. It is recommended that you install pre-build boost and mpi using tools such as brew install in mac os, or apt-get install in ubantu.","title":"Dependencies"},{"location":"documentation/user_manual/#run-built-in-examples","text":"There are some built-in examples defined in the examples/ directory. Once the software is installed, it will create an excutable file in the build/bin directory. Run an example using the following command in the root directory. The results will be stored in tmp/out/ directory after the running of the example. ./build/bin/netdem_example_random_packing Visualize the results in paraview . For irregular-shaped particles, use the following command to generate the results with particles represented by triangle meshes. ./build/bin/netdem_tool_point2mesh [in.vtk] [out.vtk] [shape_dir] In case one need to do the generation in batch, the following command can be used ./scripts/batch_data_point2mesh.sh [in_dir] [out_dir] [shape_dir] or easier ./scripts/auto_mesh_particle.sh [out_dir] ./scripts/auto_mesh_wall.sh [out_dir]","title":"Run built-in examples"},{"location":"documentation/user_manual/#visualize-post-process","text":"Results can be dumped as VTK files, which can be visualized in paraview . We have a side-repository that provides some matlab or python scripts for post-process (e.g., VTK io, stress-strain, spherical histograms of contact anisotropy).","title":"Visualize &amp; post-process"},{"location":"download/","text":"NetDEM Source code: https://github.com/net-dem/netdem Website: https://github.com/net-dem/netdem_docs Post-processing scripts Matlab: https://github.com/net-dem/dem_postprocess_scripts Other relevant softwares Easybuild : a software environment for easing the configuration, building and installation computational packages. Now support: deal.II : a C++ program library targeted at the computational solution of partial differential equations using adaptive finite elements. liggghts : an open source discrete element method particle simulation software that is improved from LAMMPS for general granular and granular heat transfer simulations. This project used a modified version that includes granular bond formulations. netdem : a neural network machine learning enabled DEM framework for computational particle mechanics. [to be open-source soon] openfoam : a free, open source computational fluid dynamics (CFD) software package released by the OpenFOAM Foundation. peridigm : an open-source computational peridynamics code developed, originally at Sandia National Laboratories and open-sourced in 2011, for massively-parallel multi-physics simulations.","title":"Download"},{"location":"download/#_1","text":"","title":""},{"location":"download/#netdem","text":"Source code: https://github.com/net-dem/netdem Website: https://github.com/net-dem/netdem_docs","title":"NetDEM"},{"location":"download/#post-processing-scripts","text":"Matlab: https://github.com/net-dem/dem_postprocess_scripts","title":"Post-processing scripts"},{"location":"download/#other-relevant-softwares","text":"Easybuild : a software environment for easing the configuration, building and installation computational packages. Now support: deal.II : a C++ program library targeted at the computational solution of partial differential equations using adaptive finite elements. liggghts : an open source discrete element method particle simulation software that is improved from LAMMPS for general granular and granular heat transfer simulations. This project used a modified version that includes granular bond formulations. netdem : a neural network machine learning enabled DEM framework for computational particle mechanics. [to be open-source soon] openfoam : a free, open source computational fluid dynamics (CFD) software package released by the OpenFOAM Foundation. peridigm : an open-source computational peridynamics code developed, originally at Sandia National Laboratories and open-sourced in 2011, for massively-parallel multi-physics simulations.","title":"Other relevant softwares"},{"location":"examples/angle_of_repose/","text":"","title":"Angle of repose"},{"location":"examples/granular_mixing/","text":"","title":"Granular mixing"},{"location":"examples/random_packing/","text":"[WIP] Random packing Problem description Setup and implementation Results and discussions","title":"Random packing"},{"location":"examples/random_packing/#random-packing","text":"","title":"Random packing"},{"location":"examples/random_packing/#problem-description","text":"","title":"Problem description"},{"location":"examples/random_packing/#setup-and-implementation","text":"","title":"Setup and implementation"},{"location":"examples/random_packing/#results-and-discussions","text":"","title":"Results and discussions"},{"location":"examples/triaxial_compression/","text":"","title":"Triaxial compression"},{"location":"gallery/animations/","text":"This page collects animations from various simulations based on NetDEM. Random packing of poly-super-ellipsoid particles. Random packing of level-set particles. Granular mixing of spheres. Nut sliding on bolt without frition and damping, where the nut and bolt is modeled with polyhdral particles in DEM. Membrane tensiling and twisting, simulated with finite element and neo-hookean model. Random packing of poly-super-quadrics particles. Random packing of polydral particles. Triaxial compression of irregular-shaped particles that are represented by spherical harmonics. Random packing of generaly irregular-shaped particles, where the contacts are handled by neurual networks. Random packing of spherical-harmonics particles. Random packing of mixed types of particles. Column collapsing of irregular-shaped particles that are represented by spherical harmonics. Particle curshing simuated with coupled DEM-peridigm, where level set-based domain splitting appraoch is employed for fragments reconstruction.","title":"Animations"},{"location":"gallery/animations/#_1","text":"This page collects animations from various simulations based on NetDEM. Random packing of poly-super-ellipsoid particles. Random packing of level-set particles. Granular mixing of spheres. Nut sliding on bolt without frition and damping, where the nut and bolt is modeled with polyhdral particles in DEM. Membrane tensiling and twisting, simulated with finite element and neo-hookean model. Random packing of poly-super-quadrics particles. Random packing of polydral particles. Triaxial compression of irregular-shaped particles that are represented by spherical harmonics. Random packing of generaly irregular-shaped particles, where the contacts are handled by neurual networks. Random packing of spherical-harmonics particles. Random packing of mixed types of particles. Column collapsing of irregular-shaped particles that are represented by spherical harmonics. Particle curshing simuated with coupled DEM-peridigm, where level set-based domain splitting appraoch is employed for fragments reconstruction.","title":""},{"location":"gallery/snapshots/","text":"","title":"Snapshots"}]}