{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Previous Next NetDEM is a neural network enabled C++ library for discrete element methods. Features It is currently capable of performing basic and general DEM simulations, with following features: Sphere and triangle facets contact solver GJK contact solver for convex particles SDF contact solver for arbitrary (convex and concave) particles Hybrid OpenMP and MPI parallel computing Integrated mlpack machine learning environment The supported particle shapes include sphere, cylinder, poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, triangle mesh, level set, etc. News Date Message Dec 01, 2021 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10, 2021 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15, 2021 Generlized two types of contact solvers, namely GJK and SDF. Mar 15, 2021 Integrated the mlpack as the machine learning environment. Documentation Getting Started \u250a Examples \u250a Code doxygen \u250a Sources We recommend new users to start by examining the example codes . Currently, we use paraview for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . License & citation NetDEM is distributed under the GPL license, see copyright and license for details. See the about page for acknowledgements and citation information.","title":"Home"},{"location":"#features","text":"It is currently capable of performing basic and general DEM simulations, with following features: Sphere and triangle facets contact solver GJK contact solver for convex particles SDF contact solver for arbitrary (convex and concave) particles Hybrid OpenMP and MPI parallel computing Integrated mlpack machine learning environment The supported particle shapes include sphere, cylinder, poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, triangle mesh, level set, etc.","title":"Features"},{"location":"#news","text":"Date Message Dec 01, 2021 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10, 2021 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15, 2021 Generlized two types of contact solvers, namely GJK and SDF. Mar 15, 2021 Integrated the mlpack as the machine learning environment.","title":"News"},{"location":"#documentation","text":"Getting Started \u250a Examples \u250a Code doxygen \u250a Sources We recommend new users to start by examining the example codes . Currently, we use paraview for visualization.","title":"Documentation"},{"location":"#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments .","title":"Contact"},{"location":"#license-citation","text":"NetDEM is distributed under the GPL license, see copyright and license for details. See the about page for acknowledgements and citation information.","title":"License &amp; citation"},{"location":"about/acknowledgement/","text":"How to cite We do not have a paper for this extire library for now. Please cite one of our relevant works with Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371. Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2022). Signed distance field framework for unified DEM modeling of granular media with arbitrary particle shapes . Computational Mechanics, 1-21. Contributors We would like to thank all the peer researchers that have directly or indrectly made a contribution to this project, by means of submitting commits or pull requests, making suggestions or discussions, finding and resolving bugs or difficulties during usage, etc. We would also like to thank the authors of thrid party software packages (in dependencies ) that are used by this project and have greatly faciliated the development of this project. This website is built on mkdocs and the template extracted from mfem . Fundings This project is under active development. The fundings that have supported the development of this project are acknowledged and will be updated accordingly. 2019-2022: National Natural Science Foundation of China (51909289) 2019-2021: China Postdoctoral Science Foundation (2019M663240) 2020-2022: Hong Kong Scholar program (2020) Copyright & License Copyright \u00a9 2020-, NetDEM team, Applied Process Analysis and Modeling Group. Copyright \u00a9 2020-, Sun Yat-sen University and The Hong Kong University of Science and Technology. NetDEM is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. NetDEM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"Acknowledgements"},{"location":"about/acknowledgement/#_1","text":"","title":""},{"location":"about/acknowledgement/#how-to-cite","text":"We do not have a paper for this extire library for now. Please cite one of our relevant works with Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371. Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2022). Signed distance field framework for unified DEM modeling of granular media with arbitrary particle shapes . Computational Mechanics, 1-21.","title":"How to cite"},{"location":"about/acknowledgement/#contributors","text":"We would like to thank all the peer researchers that have directly or indrectly made a contribution to this project, by means of submitting commits or pull requests, making suggestions or discussions, finding and resolving bugs or difficulties during usage, etc. We would also like to thank the authors of thrid party software packages (in dependencies ) that are used by this project and have greatly faciliated the development of this project. This website is built on mkdocs and the template extracted from mfem .","title":"Contributors"},{"location":"about/acknowledgement/#fundings","text":"This project is under active development. The fundings that have supported the development of this project are acknowledged and will be updated accordingly. 2019-2022: National Natural Science Foundation of China (51909289) 2019-2021: China Postdoctoral Science Foundation (2019M663240) 2020-2022: Hong Kong Scholar program (2020)","title":"Fundings"},{"location":"about/acknowledgement/#copyright-license","text":"Copyright \u00a9 2020-, NetDEM team, Applied Process Analysis and Modeling Group. Copyright \u00a9 2020-, Sun Yat-sen University and The Hong Kong University of Science and Technology. NetDEM is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. NetDEM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"Copyright &amp; License"},{"location":"about/help_%26_support/","text":"There are varieties of features or functionalities can be implemented into the NetDEM to facilitate its application on scientific research or engineering production. If you have an interest to contribute to any part of this project, please let us know. The users are also cautioned that this code is under active development. If you need help using NetDEM, or have found a bug, please open an issue or submit a pull request . Contact Dr. Zhengshou Lai, laizhengsh [AT] mail.sysu.edu.cn","title":"Help & Support"},{"location":"about/help_%26_support/#_1","text":"There are varieties of features or functionalities can be implemented into the NetDEM to facilitate its application on scientific research or engineering production. If you have an interest to contribute to any part of this project, please let us know. The users are also cautioned that this code is under active development. If you need help using NetDEM, or have found a bug, please open an issue or submit a pull request .","title":""},{"location":"about/help_%26_support/#contact","text":"Dr. Zhengshou Lai, laizhengsh [AT] mail.sysu.edu.cn","title":"Contact"},{"location":"about/news_%26_updates/","text":"News 2021 Date Message Dec 10 Particle breakage with peridigm-DEM coupling, domain splitting, bonded spheres, bonded voronois Dec 01 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15 Generlized two types of contact solvers, namely GJK and SDF. Mar 15 Integrated the MLPACK as the machine learning environment. Revision notes (As from Dec 11, 2021) v0.0 Implement light-weight FEM to model deformable particle Change raw array to std::vector, etc. Rename evaluator to modifier for all classes and files Add membrane with finite element and neo-hookean model Dynamic properties in particle, wall and contacts Seperate collision contacts and bond contacts in data dumper Contact-wise numerical damping","title":"News & Updates"},{"location":"about/news_%26_updates/#news","text":"","title":"News"},{"location":"about/news_%26_updates/#2021","text":"Date Message Dec 10 Particle breakage with peridigm-DEM coupling, domain splitting, bonded spheres, bonded voronois Dec 01 Added pybind11 environment and python examples, exposed most APIs to python. Sep 10 Poly-super-ellipsoid, poly-super-quadric, spherical harmonics, level set, polyhedron and etc. Aug 15 Generlized two types of contact solvers, namely GJK and SDF. Mar 15 Integrated the MLPACK as the machine learning environment.","title":"2021"},{"location":"about/news_%26_updates/#revision-notes","text":"(As from Dec 11, 2021)","title":"Revision notes"},{"location":"about/news_%26_updates/#v00","text":"Implement light-weight FEM to model deformable particle Change raw array to std::vector, etc. Rename evaluator to modifier for all classes and files Add membrane with finite element and neo-hookean model Dynamic properties in particle, wall and contacts Seperate collision contacts and bond contacts in data dumper Contact-wise numerical damping","title":"v0.0"},{"location":"about/publications/","text":"2021 Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371. Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2022). Signed distance field framework for unified DEM modeling of granular media with arbitrary particle shapes . Computational Mechanics, 70, 763\u2013783.","title":"Publications"},{"location":"about/publications/#2021","text":"Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2021). Revisiting the GJK and shape erosion method for contact resolution in DEM . Powder Technology, 394, 363-371. Lai, Z., Zhao, S., Zhao, J., & Huang, L. (2022). Signed distance field framework for unified DEM modeling of granular media with arbitrary particle shapes . Computational Mechanics, 70, 763\u2013783.","title":"2021"},{"location":"documentation/basic_usage/","text":"User manual \u250a Previous \u250a Next Run built-in examples There are some built-in examples defined in the examples/ directory. Once the software is installed, it will create an excutable file in the build/bin directory. Run an example using the following command in the root directory. The results will be stored in tmp/out/ directory after the running of the example, and can be visualized in paraview . ./build/bin/netdem_example_random_packing python3 example/00_random_packing/pynetdem_1_gjk_solver.py Reconstruct mesh of particles and walls For irregular-shaped particles, use the following command to generate the results with particles represented by triangle meshes. ./build/bin/netdem_tool_point2mesh [in.vtk] [out.vtk] [shape_dir] In case one need to do the generation in batch, the following command can be used ./scripts/batch_data_point2mesh.sh [in_dir] [out_dir] [shape_dir] [0, 1] Option [0, 1] is for importing shape informaiton, such that 0 indicates using the json shape info (i.e., shape_000_000000000000000.json), 1 indicates using stl shape files. For json shape info, please specify the exact file name for [shape_dir] , whereas the directory shape/ for stl shape info. or easier ./scripts/auto_mesh_particle.sh [out_dir] [0, 1, or 2] ./scripts/auto_mesh_wall.sh [out_dir] [0, 1, or 2] Option [0, 1, or 2] is for importing shape informaiton, such that 0 indicates using the 0-time-step shape info (i.e., shape_000_000000000000000.json) in the shape/ sub-directory of the result root, 1 indicates using STL shape files, whereas 2 indicates using time specific shape info (e.g., shape_000_0000000xxxxxxxxx.json). Customized simulation Please follow the built-in examples to write the c++ or python scripts. Visualize in paraview Results can be dumped as VTK files, which can be visualized in paraview . Spherical particles Import particle info into paraview; Set Representation to Point Gaussian , and adjust the radius; In case particles are of various sizes, enable Toggle advanced properties , enable Use Scale Array , select the proper Scale Array Component , and adjust the Range . General particles and walls Reconstruc the mesh of particles and walls ; Import to praview; Contact force chain Enable dump contact force by set: data_dump.dump_contact_info = true ; Import contact info into paraview; Add a tube filter to the contact force data in paraview, and adjust the radius of the contact tubes. Ray tracing Enable Ray Tracing at the end of Properties section; Change the Back end to OsPRay pathtracer ; Increase the Samples Per Pixel , which gives fair results with a value 5 in reasonble rendering time; Set the Background mode to Backplase , which is while as suggested. One can play with the Material options in the middle-while of the Properties section. Create animation In paraview, go File \u2192 Save Animation ; Select the avi option and specify the name; Suggest to set the image resolution with 1920 x 1080 , i.e., 1080p, and Set the Frame Rate to 24 (a minimal value to give fluent animation); Compress the avi animation with third-party tools, such as ffmpeg or Tencent Cloud ; For Tencent Cloud , suggested procedures (in Chinese): \u9009\u62e9\u4e91\u4ea7\u54c1 \u4e91\u70b9\u64ad \uff0c\u5728 \u5a92\u8d44\u7ba1\u7406 \u2192 \u97f3\u89c6\u9891\u7ba1\u7406 \u4e2d\uff0c\u4e0a\u4f20\u89c6\u9891; \u4e0a\u4f20\u89c6\u9891\u540e\uff0c\u9009\u62e9\u5f85\u5904\u7406\u7684\u89c6\u9891\uff0c\u8fdb\u884c \u89c6\u9891\u5904\u7406 \uff0c\u5efa\u8bae\u9009\u62e9 TESHD-H264-MP4-720P \u8f6c\u7801\u6a21\u677f; \u70b9\u51fb\u53f3\u4fa7\u7684 \u7ba1\u7406 \uff0c\u53ef\u67e5\u770b\u89c6\u9891\u5c01\u9762\u548c\u89c6\u9891\u64ad\u653e\u5730\u5740\u7b49\u94fe\u63a5\uff0c\u53ef\u7528\u4e8e\u7f51\u9875\u5236\u4f5c. Post-process We have a side-repository that provides some matlab or python scripts for post-process (e.g., VTK io, stress-strain, spherical histograms of contact anisotropy). User manual \u250a Previous \u250a Next","title":"Basic usage"},{"location":"documentation/basic_usage/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/basic_usage/#run-built-in-examples","text":"There are some built-in examples defined in the examples/ directory. Once the software is installed, it will create an excutable file in the build/bin directory. Run an example using the following command in the root directory. The results will be stored in tmp/out/ directory after the running of the example, and can be visualized in paraview . ./build/bin/netdem_example_random_packing python3 example/00_random_packing/pynetdem_1_gjk_solver.py","title":"Run built-in examples"},{"location":"documentation/basic_usage/#reconstruct-mesh-of-particles-and-walls","text":"For irregular-shaped particles, use the following command to generate the results with particles represented by triangle meshes. ./build/bin/netdem_tool_point2mesh [in.vtk] [out.vtk] [shape_dir] In case one need to do the generation in batch, the following command can be used ./scripts/batch_data_point2mesh.sh [in_dir] [out_dir] [shape_dir] [0, 1] Option [0, 1] is for importing shape informaiton, such that 0 indicates using the json shape info (i.e., shape_000_000000000000000.json), 1 indicates using stl shape files. For json shape info, please specify the exact file name for [shape_dir] , whereas the directory shape/ for stl shape info. or easier ./scripts/auto_mesh_particle.sh [out_dir] [0, 1, or 2] ./scripts/auto_mesh_wall.sh [out_dir] [0, 1, or 2] Option [0, 1, or 2] is for importing shape informaiton, such that 0 indicates using the 0-time-step shape info (i.e., shape_000_000000000000000.json) in the shape/ sub-directory of the result root, 1 indicates using STL shape files, whereas 2 indicates using time specific shape info (e.g., shape_000_0000000xxxxxxxxx.json).","title":"Reconstruct mesh of particles and walls"},{"location":"documentation/basic_usage/#customized-simulation","text":"Please follow the built-in examples to write the c++ or python scripts.","title":"Customized simulation"},{"location":"documentation/basic_usage/#visualize-in-paraview","text":"Results can be dumped as VTK files, which can be visualized in paraview .","title":"Visualize in paraview"},{"location":"documentation/basic_usage/#spherical-particles","text":"Import particle info into paraview; Set Representation to Point Gaussian , and adjust the radius; In case particles are of various sizes, enable Toggle advanced properties , enable Use Scale Array , select the proper Scale Array Component , and adjust the Range .","title":"Spherical particles"},{"location":"documentation/basic_usage/#general-particles-and-walls","text":"Reconstruc the mesh of particles and walls ; Import to praview;","title":"General particles and walls"},{"location":"documentation/basic_usage/#contact-force-chain","text":"Enable dump contact force by set: data_dump.dump_contact_info = true ; Import contact info into paraview; Add a tube filter to the contact force data in paraview, and adjust the radius of the contact tubes.","title":"Contact force chain"},{"location":"documentation/basic_usage/#ray-tracing","text":"Enable Ray Tracing at the end of Properties section; Change the Back end to OsPRay pathtracer ; Increase the Samples Per Pixel , which gives fair results with a value 5 in reasonble rendering time; Set the Background mode to Backplase , which is while as suggested. One can play with the Material options in the middle-while of the Properties section.","title":"Ray tracing"},{"location":"documentation/basic_usage/#create-animation","text":"In paraview, go File \u2192 Save Animation ; Select the avi option and specify the name; Suggest to set the image resolution with 1920 x 1080 , i.e., 1080p, and Set the Frame Rate to 24 (a minimal value to give fluent animation); Compress the avi animation with third-party tools, such as ffmpeg or Tencent Cloud ; For Tencent Cloud , suggested procedures (in Chinese): \u9009\u62e9\u4e91\u4ea7\u54c1 \u4e91\u70b9\u64ad \uff0c\u5728 \u5a92\u8d44\u7ba1\u7406 \u2192 \u97f3\u89c6\u9891\u7ba1\u7406 \u4e2d\uff0c\u4e0a\u4f20\u89c6\u9891; \u4e0a\u4f20\u89c6\u9891\u540e\uff0c\u9009\u62e9\u5f85\u5904\u7406\u7684\u89c6\u9891\uff0c\u8fdb\u884c \u89c6\u9891\u5904\u7406 \uff0c\u5efa\u8bae\u9009\u62e9 TESHD-H264-MP4-720P \u8f6c\u7801\u6a21\u677f; \u70b9\u51fb\u53f3\u4fa7\u7684 \u7ba1\u7406 \uff0c\u53ef\u67e5\u770b\u89c6\u9891\u5c01\u9762\u548c\u89c6\u9891\u64ad\u653e\u5730\u5740\u7b49\u94fe\u63a5\uff0c\u53ef\u7528\u4e8e\u7f51\u9875\u5236\u4f5c.","title":"Create animation"},{"location":"documentation/basic_usage/#post-process","text":"We have a side-repository that provides some matlab or python scripts for post-process (e.g., VTK io, stress-strain, spherical histograms of contact anisotropy). User manual \u250a Previous \u250a Next","title":"Post-process"},{"location":"documentation/blender_rendering/","text":"User manual \u250a Previous Install blender and add-ons Install blender, which can be obtained from https://www.blender.org . Install VTK inside the blender python environment. Hint: to add vtk support in blender, please visit https://github.com/simboden/BVtkNodes/blob/master/build_vtk.md . Install BVtkNodes add-on, which can be obtained from https://github.com/tkeskita/BVtkNodes . Thanks Silvano Imboden (s.imboden@cineca.it), Lorenzo Celli, and Paul Mc Manus for the original work , and Tuomo Keskitalo for functionality extending and maintaining. Hint: to install add-on in blender: go to Edit \u2192 Preferences \u2192 add-on , and install the add-on by selecting the zip file downloaded from the github main/master branch. Rendering Switch to the BVTK Node Tree editor, and new a node tree similar to the following figure. Switch back to the 3D Viewport editor, and you should get a scene as following. Play with the VTK filters and blender feature to polish the scene (color represents the stress). Below is an animation of membrane pulling and twisting, where the result data is simulated and created in NetDEM . Hints: Shortkeys: ctrl + alt + NumPad 0 to set the camera to current view; G to translate the selected object; x to delete the selected object; ctrl or shift + mouse operalaitons to pan, zoom-in and zoom-out the view. Rendering settings: suggest to use cycles engine, with the Max Samples set to 10 . For rendering animaiton: the Time Selector filter will change the file name according to the index of frame. At current stage, the file names should indexed with sequential numbers, i.e., xx_000.vtk , xx_001.vtk , xx_999.vtk , etc. One can play with the vtk filters for possible entension. User manual \u250a Previous","title":"Blender rendering"},{"location":"documentation/blender_rendering/#_1","text":"User manual \u250a Previous","title":""},{"location":"documentation/blender_rendering/#install-blender-and-add-ons","text":"Install blender, which can be obtained from https://www.blender.org . Install VTK inside the blender python environment. Hint: to add vtk support in blender, please visit https://github.com/simboden/BVtkNodes/blob/master/build_vtk.md . Install BVtkNodes add-on, which can be obtained from https://github.com/tkeskita/BVtkNodes . Thanks Silvano Imboden (s.imboden@cineca.it), Lorenzo Celli, and Paul Mc Manus for the original work , and Tuomo Keskitalo for functionality extending and maintaining. Hint: to install add-on in blender: go to Edit \u2192 Preferences \u2192 add-on , and install the add-on by selecting the zip file downloaded from the github main/master branch.","title":"Install blender and add-ons"},{"location":"documentation/blender_rendering/#rendering","text":"Switch to the BVTK Node Tree editor, and new a node tree similar to the following figure. Switch back to the 3D Viewport editor, and you should get a scene as following. Play with the VTK filters and blender feature to polish the scene (color represents the stress). Below is an animation of membrane pulling and twisting, where the result data is simulated and created in NetDEM . Hints: Shortkeys: ctrl + alt + NumPad 0 to set the camera to current view; G to translate the selected object; x to delete the selected object; ctrl or shift + mouse operalaitons to pan, zoom-in and zoom-out the view. Rendering settings: suggest to use cycles engine, with the Max Samples set to 10 . For rendering animaiton: the Time Selector filter will change the file name according to the index of frame. At current stage, the file names should indexed with sequential numbers, i.e., xx_000.vtk , xx_001.vtk , xx_999.vtk , etc. One can play with the vtk filters for possible entension. User manual \u250a Previous","title":"Rendering"},{"location":"documentation/cfddem_simulation/","text":"User manual Installation Install netdem , openfoam , and cfddem from https://github.com/apaam . mkdir apaam cd apaam git clone https://github.com/apaam/netdem.git . cd netdem make cd .. git clone https://github.com/apaam/openfoam_customized.git . cd openfoam_customized make cd .. git clone https://github.com/apaam/cfddem.git . cd cfddem make cd .. Init OpenFOAM environment by adding the following lines to and sourcing the .bashrc (where $path_apaam is the path of apaam) export path_openfoam=$path_apaam/openfoam_customized/OpenFOAM-build alias openfoam_init='source $path_openfoam/etc/bashrc' openfoam_init echo \"using openfoam=$path_openfoam\" Add the binary directory to syatem PATH in .bashrc (where $path_apaam is the path of apaam) export PATH=$PATH:$path_apaam/cfddem/build/bin Run water entry example Copy the example folder to a local directory cd cfddem cp -rf examples/interIBdem/water_entry local/interIBdem/ Run the example Please note that system/fvSolution -> coupling specifies the DEM file and function that will be invoked for the coupling. cd local/interIBdem/water_entry ./Allclean ./Allrun-parallel In case the run fails, please check the lib path has been correctly set in createDEM.py , where the path is the directory of netdem libs. Paraview Rendering Render CFD results Open interIBdem.foam to paraview Change the properties Type Case to Decomposed Case and uncheck Skip Zero Time (optional) Play with the result fields Optinal: for viaulizeing interal filed results, one can use the Clip or Slice filter Optinal: to construct the interface of the water and air, one can add Contour filter to interIBdem.foam , set Contour by to alpha.water and change the contour value to 0.5 Render DEM results Open dem/particle_mesh_xxx.vtk.serries to paraview Optional: select all particle_mesh_xxx.vtk.serries and add a Group Datesets filter Optional: add a Caculator filter after the Group Datesets filter, set Result Array Name to U , and input formulation vel . This will add a U field to the particles, wihch can be linked with the CFD field U Optional: for probing the evolution of a property value with time, one can add a Plot Data Over Time filter to the Group Datesets , and change the Field Associates to Cells . Then, one can play with the property to show in the newly opened Line Chart View Modify the water entry parameters Fuild properties such as viscosity and density is specified in file constant/transportProperties . Please note that fuilds being used are speficied in phases . Geometries are determined by the system/blockMeshDict . Please note that when scale exist, the coordinates of the vertices with be multiplied by the scale when creating the real mesh. Mesh size are govened by the three values before simpleGrading in the blocks -> hex entry. It is suggested to use cubic elements. The inital volume fraction of the fuilds are specifed in system/setFiledsDict . Please not that the scale parameter in system/blockMeshDict will not work here, thus the vertices here are their exact values. Entry box (-0.05 -0.05 -0.15) (0.05 0.05 0.03) specifies the lower-left-front and upper-right-back coordicates of the box Please note that the field entry alpha.glycerol should be consistent with that specified in constant/transportProperties -> phases File system/controlDict specifies the simulation time, timestep and writing interval, etc. In createDEM.py -> oneSphere() funciton, one can modify the DEM domain geometries and particle properties. Please note that in the present funciton, the parameter scale varies the size of the DEM domain, wall box and particle intertion region, whereas the p_size is the exact value of particle diameter. User manual","title":"Cfddem simulation"},{"location":"documentation/cfddem_simulation/#_1","text":"User manual","title":""},{"location":"documentation/cfddem_simulation/#installation","text":"Install netdem , openfoam , and cfddem from https://github.com/apaam . mkdir apaam cd apaam git clone https://github.com/apaam/netdem.git . cd netdem make cd .. git clone https://github.com/apaam/openfoam_customized.git . cd openfoam_customized make cd .. git clone https://github.com/apaam/cfddem.git . cd cfddem make cd .. Init OpenFOAM environment by adding the following lines to and sourcing the .bashrc (where $path_apaam is the path of apaam) export path_openfoam=$path_apaam/openfoam_customized/OpenFOAM-build alias openfoam_init='source $path_openfoam/etc/bashrc' openfoam_init echo \"using openfoam=$path_openfoam\" Add the binary directory to syatem PATH in .bashrc (where $path_apaam is the path of apaam) export PATH=$PATH:$path_apaam/cfddem/build/bin","title":"Installation"},{"location":"documentation/cfddem_simulation/#run-water-entry-example","text":"Copy the example folder to a local directory cd cfddem cp -rf examples/interIBdem/water_entry local/interIBdem/ Run the example Please note that system/fvSolution -> coupling specifies the DEM file and function that will be invoked for the coupling. cd local/interIBdem/water_entry ./Allclean ./Allrun-parallel In case the run fails, please check the lib path has been correctly set in createDEM.py , where the path is the directory of netdem libs.","title":"Run water entry example"},{"location":"documentation/cfddem_simulation/#paraview-rendering","text":"Render CFD results Open interIBdem.foam to paraview Change the properties Type Case to Decomposed Case and uncheck Skip Zero Time (optional) Play with the result fields Optinal: for viaulizeing interal filed results, one can use the Clip or Slice filter Optinal: to construct the interface of the water and air, one can add Contour filter to interIBdem.foam , set Contour by to alpha.water and change the contour value to 0.5 Render DEM results Open dem/particle_mesh_xxx.vtk.serries to paraview Optional: select all particle_mesh_xxx.vtk.serries and add a Group Datesets filter Optional: add a Caculator filter after the Group Datesets filter, set Result Array Name to U , and input formulation vel . This will add a U field to the particles, wihch can be linked with the CFD field U Optional: for probing the evolution of a property value with time, one can add a Plot Data Over Time filter to the Group Datesets , and change the Field Associates to Cells . Then, one can play with the property to show in the newly opened Line Chart View","title":"Paraview Rendering"},{"location":"documentation/cfddem_simulation/#modify-the-water-entry-parameters","text":"Fuild properties such as viscosity and density is specified in file constant/transportProperties . Please note that fuilds being used are speficied in phases . Geometries are determined by the system/blockMeshDict . Please note that when scale exist, the coordinates of the vertices with be multiplied by the scale when creating the real mesh. Mesh size are govened by the three values before simpleGrading in the blocks -> hex entry. It is suggested to use cubic elements. The inital volume fraction of the fuilds are specifed in system/setFiledsDict . Please not that the scale parameter in system/blockMeshDict will not work here, thus the vertices here are their exact values. Entry box (-0.05 -0.05 -0.15) (0.05 0.05 0.03) specifies the lower-left-front and upper-right-back coordicates of the box Please note that the field entry alpha.glycerol should be consistent with that specified in constant/transportProperties -> phases File system/controlDict specifies the simulation time, timestep and writing interval, etc. In createDEM.py -> oneSphere() funciton, one can modify the DEM domain geometries and particle properties. Please note that in the present funciton, the parameter scale varies the size of the DEM domain, wall box and particle intertion region, whereas the p_size is the exact value of particle diameter. User manual","title":"Modify the water entry parameters"},{"location":"documentation/dem_basics/","text":"DEM wiki \u250a Next [This page is part of Dr. Zhengshou Lai's dissertation .] This page presents a brief introduction and review of the discrete element method (DEM). The intention is to introduce the main components and basic computational workflow of a DEM model, providing necessary background information to the research presented in this dissertation. Overview DEM is a particle-based numerical model that is particularly suitable for describing the mechanical behavior of bulk granular materials. It was first proposed by Cundall &Strack (1979) 2 for the analysis of geotechnical materials. Since then, DEM has been applied to model all kinds of granular materials and to simulate the problems ranging from solids handling to powder flowing in a variety of different engineering branches 3 4 5 . In DEM, all individual particles in the bulk granular material are explicitly modeled and a DEM model directly captures the interactions between particles and tracks the motions of each particle. The bulk behavior of a granular material is presented as an assembly of the actions (i.e., the interactions and motions) of all constituent particles. As a particle-based numerical model, DEM exhibits several advantages compared to the classical continuum theory-based numerical models. First, it bypasses the phenomenological constitutive models for describing the bulk behavior of a granular material within a representative volume 6 7 8 . Second, it is straightforward for the DEM to simulate the problems involving large deformation or material failure, such as granular flow, penetration, or strain localization 9 . The major drawback of DEM is also obvious. As DEM tracks the interactions and motions of all particles, DEM simulations are quite computationally expensive, which makes it difficult to scale up 10 11 . Nevertheless, with the advent of computer hardware and parallel capabilities, the DEM has become an increasingly powerful numerical tool that can provide valuable information of and shed lights upon the microscopic behavior of granular materials, which is often difficult or impossible to obtain from classical continuum-based numerical models or from physical experiments. Key components of DEM Basic elements In general, there are two types of basic elements in a DEM model: particles and boundaries. The basic elements are assumed to be rigid but can have overlaps with each other. A particle is a body that has a closed surface. It may be represented by a simple geometry (e.g., sphere or ellipsoid) or a composition of several simple geometries that make up the body surface (see further discussions in ). A review on the particle geometric representations can be found in Zhong et al. (2016) 12 . Particles have mass and their motion (i.e., position, velocity, and acceleration) is always tracked during a DEM simulation. Boundaries are also referred to as walls in the DEM literature. They may as well be represented by simple geometries (e.g., triangles) or their combinations, but they do not necessarily have closed surfaces. Boundaries do not have mass and their position and velocity are usually prescribed to provide the desired constraints to the particles in the model. Contacts and contact models Contacts describe the interactions between basic elements. Contact occurs when the surfaces of two basic elements overlap with each other (to model collisions), or when the surfaces are within a specified distance (to model long-range bond or cohesion). Detecting the contacts between basic elements is a mathematical geometry problem and is one of the most time-consuming parts of a DEM simulation. One important task associated with contact detection is to characterize the contact geometric features, which are needed by a contact model to calculate the contact forces and moments. The contact features may include the overlapping (or indentation) distance, relative shear displacement, contact point, contact branch vectors, and so on. Contact models are used to calculate the contact forces and moments between the two elements in contact. Commonly used contact models include the linear elastic model 2 , the rolling resistance model 13 14 , the Hertz-Mindlin model 15 16 17 , and the linear parallel bond model 18 . The formulation of these contact models will be presented in . Newton-Euler equations of motion In DEM, the motion of a particle can be described by the Newton-Euler equations of motion. For any arbitrarily-shaped particle, the Newton-Euler equations of motion are written as \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M} \\end{align} \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M} \\end{align} where m m is the mass of the particle; \\boldsymbol{I} \\boldsymbol{I} is the inertia tensor of the particle; \\boldsymbol{a} \\boldsymbol{a} and \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} are the translational and rotational acceleration; \\boldsymbol{F} \\boldsymbol{F} and \\boldsymbol{M} \\boldsymbol{M} are the overall external forces and moments acting on the particle; \\boldsymbol{\\omega} \\boldsymbol{\\omega} is the vector of the angular velocities about the principal axes. Herein, the variable in bold-symbol indicates a vector or a tensor. For spherical particles, the Newton-Euler equations of motion reduce to \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M} \\end{align} \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M} \\end{align} In order to resolve the motion of each particle, all the forces and moments acting on the particle need to be evaluated and summed, which may include gravity, damping, contact forces and moments, and prescribed external forces and moments. Herein, the damping refers to the global damping, which is sometimes (artificially) introduced in a DEM model to facilitate energy dissipation and enhance a quasi-static simulation 19 20 . There is another type of damping called local damping, which is usually incorporated into a contact model as dash-pot forces to account for the realistic energy dissipation due to particle interactions. Time integration To fully resolve the particle motion (e.g., the position and velocity) governed by and involves the time integration scheme, where the second-order Velocity Verlet algorithm is commonly adopted. For spherical particles, suppose that the current state is indexed by time t t and the time increment to the next state is \\Delta t \\Delta t , Velocity Verlet algorithm first calculates the particle velocities at time t t + \\Delta t/2 \\Delta t/2 by \\begin{align} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2 \\end{align} \\begin{align} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2 \\end{align} where \\boldsymbol{v} \\boldsymbol{v} and \\boldsymbol{\\omega} \\boldsymbol{\\omega} are translational and angular velocities, respectively. The superscripts (e.g., t t and \\Delta t/2 \\Delta t/2 ) indicate the time indexes. Then, the position and orientation of the particle at time t t + \\Delta t \\Delta t are calculated as \\begin{align} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{align} \\begin{align} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{align} where \\boldsymbol{x} \\boldsymbol{x} is the vector of position and \\boldsymbol{\\theta} \\boldsymbol{\\theta} is the vector of orientation. Correspondingly, the translational velocity and angular velocity at time t+\\Delta t t+\\Delta t are updated by \\begin{align} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{align} \\begin{align} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{align} For non-spherical particles, the original Newton-Euler equations of motion cannot be simplified, and the calculation of the orientations and angular velocity will be much more complicated. A more detailed discussion on the time integration for non-spherical particles will not be included here but can be found in the work of Chung (2006) 19 and the PFC user manual 20 . Critical timestep The time integration based on the second-order Velocity Verlet algorithm is numerically stable only when the time increment being used is less than a threshold value, i.e. the critical timestep 21 . If a time increment greater than the critical timestep is used, particles may move too much in one increment, which will result in spuriously infinite overlapping (i.e., abnormally large contact forces). A summary and empirical assessment of different approaches to estimate the critical timestep for DEM simulations can be found in Otsubo et al. (2017) 21 . Basically, there are two categories of approaches to estimate the critical timestep: the oscillation period of a single degree of freedom system (SDOF) based approaches 2 22 , and the Rayleigh wave speed based approaches 23 24 . The former approaches consider the DEM system to be consist of rigid bodies connected by springs, while the latter ones consider the particles themselves to be springs. In the category of the SDOF-based approaches, Cundall & Stract (1979) 2 proposed the following expression to estimate the critical timestep \\Delta t_\\text{crit} \\Delta t_\\text{crit} \\begin{align} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\end{align} \\begin{align} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\end{align} where m m is the mass of the particle; I_i I_i is the moment of inertia of the particle; k^\\text{tran} k^\\text{tran} and k_i^\\text{rot} k_i^\\text{rot} represent the translational and rotational stiffness, and the subscript i i indicates the index of principal components. In the category of the Rayleigh wave speed based approaches, Li et al. (2005) 24 proposed that \\begin{align} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\end{align} \\begin{align} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\end{align} where R R is the average particle radius; \\rho \\rho is the particle density; G G the particle shear modulus; and \\nu \\nu the Poisson's ratio of the particle. Computational workflow DEM-based numerical simulations require cyclic calculations. shows the workflow and calculations that are involved in one typical cycle of a DEM simulation. The workflow and calculations for one DEM cycle can be summarized as follows: At the current state, the positions and velocities of all particles are known: based on the geometries of all particles, identify the inter-particle contacts and evaluate contact features; Calculate the external forces and moments of all particles, while the contact forces and moments are calculated based on selected contact models and the corresponding contact features; Calculate the motion (i.e., the accelerations) of all particles; Update the positions and velocities of all particles following the selected time integration scheme. Particle representation There are basically two groups of methods to represent an irregular particle in DEM 12 : single-particle method and composite-particle method. Single-particle method The single-particle method utilizes closed geometries to represent particle shapes. Many single-particle-based DEM models have been proposed and developed with the adoption of some specific closed geometries, such as cylinder 25 , polyhedron (or polygon in 2D) 26 27 , ellipsoid (or ellipse in 2D) 28 29 , superquadrics 30 31 , Non-Uniform Rational Basis Spline (NURBS) 32 , as well as their combinations (e.g., poly-ellipsoid 33 34 ). Each of these methods has its own advantages and limitations. The application of the cylinder-based or ellipsoid-based DEM models is limited, due to the particular particle shapes they can represent. The superquadric can be considered as an extension of the ellipsoid and can be used for modeling of spheres, ellipsoids, cylinder-like and box(dice)-like particles by varying the shape parameters. It is more flexible by being able to model larger variations of particle shapes, but also more computationally expensive than the ellipsoid-based DEM models. The polyhedron- (or polygon in 2D) based DEM model is able to replicate arbitrary particle shapes. The accuracy of the shape represented by polyhedron depends on the number of faces in a polyhedron, whereas a large number of faces would hinder the computational efficiency. Moreover, polyhedron can rarely replicate a smooth particle shape. The NURBS based granular element method, developed by Andrade et al. (2012) 32 , is advantageous to replicate general and smooth particle shapes, whereas it is computationally expensive compared to the polyhedron-based DEM. Recently, Kawamoto et al. (2016) 35 developed another novel type of single-particle-based DEM, which utilizes the level set (LS) method to represent particles. The LS-DEM seamlessly utilizes the level set data of realistic particle shapes characterized from X-ray computational tomography and is computationally efficient. One issue with the LS-DEM is high memory consumption, which somewhat limits its application on large particulate systems. Composite-particle method In a composite-particle method, a particle is represented by compositions of simple geometries (usually spheres in 3D or circles in 2D 36 1 ). This group of methods is advantageous to implementation for that the contact detection and resolution algorithms for the simple geometries can be effortlessly exploited. It should be noted that the accuracy of particle shape represented by compositions of simple geometries depends on the amount of the simple geometries, and a large number of simple geometries would lead to great computational expense though. Nonetheless, the composite-particle method (especially with spheres as the base elements) is currently the most prevalent method to model irregular particles and is supported in most commercial or open-source DEM packages such as PFC 20 and LIGGGHTS 37 . There are three options to represent a composite particle (a) (b) (c) A schematic illustration of the three options to represent a composite particle with discs (modified after 1 ) Contact models A DEM contact model is normally comprised of springs, dash-pots, and sliders to describe the force-displacement behavior at the contact, where the springs account for normal and tangential forces, the dash-pots account for local damping, and the sliders account for shear failure. The formulation of contact models that will be used in this dissertation is presented in this section. Linear elastic model A linear elastic model generally consists of two elastic springs, two dash-pots, and a slider, as shown schematically in the following. The contact forces \\boldsymbol{F} \\boldsymbol{F} are calculated from two parts: the normal force \\boldsymbol{F}_n \\boldsymbol{F}_n and the shear (or tangential) force \\boldsymbol{F}_s \\boldsymbol{F}_s \\begin{align} \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\end{align} \\begin{align} \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\end{align} where \\boldsymbol{n}_n \\boldsymbol{n}_n and \\boldsymbol{n}_s \\boldsymbol{n}_s are the unit vectors denoting the direction of the normal and the shear force, respectively; F_n F_n and F_s F_s are the magnitudes of corresponding contact forces. Assuming the relative displacement increment at the contact during a timestep \\Delta t \\Delta t is given by its components \\Delta \\delta_n \\Delta \\delta_n (compression as a positive) and \\Delta \\delta_s \\Delta \\delta_s , the contact law for a simple linear model with local damping updates the contact forces through 2 20 \\begin{align} F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} \\begin{align} F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} where F_n^0 F_n^0 and F_s^0 F_s^0 are the normal and the shear forces at the beginning of the current timestep, respectively; k_n k_n and k_s k_s are the corresponding stiffness; \\eta_n \\eta_n and \\eta_s \\eta_s are the corresponding damping coefficients; \\dot{\\delta}_n \\dot{\\delta}_n and \\dot{\\delta}_s \\dot{\\delta}_s are the relative normal and shear velocity; \\mu_c \\mu_c is the contact friction coefficient; and \\bar{m} = m_im_j/(m_i+m_j) \\bar{m} = m_im_j/(m_i+m_j) is the effective mass of particles i i and j j associated with the contact, while \\bar{m} = m_i \\bar{m} = m_i for the case of particle-boundary contact. Rolling resistance model The rolling resistance model is built upon the linear elastic model by adding a term of rolling resistance moment to the contact moment. The formulation to calculate the additional rolling resistance moment can be written as 38 13 20 \\begin{align} M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) \\end{align} \\begin{align} M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) \\end{align} where M^0 M^0 is the contact moment at the beginning of the current timestep; \\Delta\\theta_b \\Delta\\theta_b is the relative bending-rotation increment; \\mu_r \\mu_r is the rolling resistance coefficient; k_r k_r is the rolling resistance stiffness defined as: \\begin{align} k_r = k_s\\bar{R}^2 \\end{align} \\begin{align} k_r = k_s\\bar{R}^2 \\end{align} where \\bar{R} \\bar{R} is the contact effective radius defined as \\bar{R}=R_iR_j/(R_i+R_j) \\bar{R}=R_iR_j/(R_i+R_j) , in which R_i R_i and R_j R_j are the radii of the contact particles. If one side of the contact is a wall, the corresponding radius R_j \\rightarrow \\infty R_j \\rightarrow \\infty . This model uses a simplified formulation for the rolling kinematics, and the particle size effects on the rolling resistance are implicitly incorporated in the rolling stiffness term. The interested reader is referred to Luding (2008) 39 , Wang et al. (2015) 40 for examples of improved and more advanced rolling resistance models. Hertz-Mindlin model The Hertz-Mindlin model is a complete frictional contact model based upon the Hertz theory 15 for contact normal forces and the Mindlin theory 16 for contact tangential forces. It takes into account the stiffness variation due to the change of contact areas during the collision of two elastic spheres. Similar to the linear elastic model, the Hertz-Mindlin model also consists of two springs, two dash-pots, and a slider. There are, however, two major differences. First, the normal and shear stiffness in the Hertz-Mindlin model are functions of the contact overlapping distance. Second, the normal contact force in the Hertz-Mindlin model is calculated via the cumulative overlapping distance, while the linear elastic model uses either the cumulative or incremental overlapping distance. To update the contact forces, the Hertz-Mindlin model follows \\begin{align} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} \\begin{align} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} where \\delta_n \\delta_n is the cumulative overlapping distance, while k_n k_n and k_s k_s are calculated as 17 : \\begin{align} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{align} \\begin{align} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{align} in which \\begin{align} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{align} \\begin{align} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{align} where \\bar{E} \\bar{E} and \\bar{G} \\bar{G} are the effective Young's modulus and shear modulus of the particles in contact; E_i E_i is the Young's modulus and \\nu_i \\nu_i is the Poisson's ratio of the i i th particle. Linear parallel bond model The linear parallel bond model describes the contact behavior of two bonded particles, as shown schematically in the following. In the linear parallel bond model, the bond between two spheres is assumed to be a cylinder of finite radius and thickness. Each point in the bond is imposed by two linear elastic springs providing normal and shear resistances, respectively. The overall bonding force and moment are the integral of the normal and shear stresses at a cross-section of the bond, which can be calculated as 18 \\begin{align} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s \\end{align} \\begin{align} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s \\end{align} where F_n^b F_n^b , F_s^b F_s^b , M_n^b M_n^b and M_s^b M_s^b are the bond normal force, shear force, twisting moment, and swinging moment, respectively; \\delta_n \\delta_n , \\delta_s \\delta_s , \\theta_n \\theta_n , and \\theta_s \\theta_s are the relative normal displacement, shear displacement, twisting rotation, and swinging rotation between the two bonded spheres, respectively; A A , I I , and J J are the area, moment of inertia, and polar moment of inertia of the bond (i.e., the circular cross-section with radius R^b R^b ), respectively; and \\Delta \\Delta indicates the increment of each variable in each time step. It should be pointed out that, while the damping is not included in the current formulation, damping terms similar to those in the linear elastic model can be incorporated in a straightforward manner. The bonded-sphere model is also capable of modeling the particle breakage behavior. As an example of a common bond breakage criterion, it can be assumed that a bond would break if the maximum normal or shear stress at the bond exceeds the corresponding normal or shear strength. In the linear parallel bond model, both the normal force and swinging moment contribute to the normal stress, while both the shear force and twisting moment contribute to the shear stress. In this regard, the bond breakage criterion can be written as \\begin{align} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{align} \\begin{align} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{align} where \\sigma_{Y,n}^b \\sigma_{Y,n}^b and \\sigma_{Y,s}^b \\sigma_{Y,s}^b are the normal and shear strength, respectively. Model calibration As most of the contact parameters in a DEM model are difficult if not impossible to be measured directly from physical tests, a calibration process is often needed to obtain the contact parameters for a specific material of interest. There are some researches available on the procedures to calibrate contact parameters for a DEM model 41 42 43 . Usually, the calibration process is accomplished by performing parametric studies on each of contact parameters and selecting values of the contact parameters with which the DEM simulation can reproduce the benchmark matrices of laboratory experiments. Commonly used laboratory experiments for calibration of DEM parameters include compression test, direct and ring shear test, and angle of repose test. Descriptions of these tests can be found in Schulze (2008) 44 , Coetzee (2017) 43 . There are some challenges and problems associated with the model calibration. First, to obtain reasonable and realistic contact parameters via calibration, it is necessary that the setup and procedures in the DEM models are to the most extent similar to those in the laboratory experiments. However, in order to get the DEM simulations performed within affordable computational resources, adjustments or tolerances in the particle size, shape or testing speed may exist in a DEM model. As a result, the calibrated contact parameters may deviate from their actual values to some degree. In addition, the contact features and contact models are usually quite simple and conceptual compared to the actual complex contact behavior. The physical meaning of the contact parameters may be lost due to the use of conceptualized contact features and contact models. Lastly, as pointed out in 43 , the solution of contact parameters might not be unique since all contact parameters may affect the results of a DEM simulation in a complex and highly nonlinear manner. There is no guarantee that the contact parameters for a material calibrated for one experiment will be workable for another. In this regard, it would be necessary to perform the calibration with one experiment and validate the calibration results via another. DEM wiki \u250a Next References C. Shi, D. Li, W. Xu, and R. Wang. Discrete element cluster modeling of complex mesoscopic particles for use with the particle flow code method. Granular Matter , 17(3):377\u2013387, 2015. \u21a9 \u21a9 P. A Cundall and O. D. L. Strack. A discrete numerical model for granular assemblies. geotechnique , 29(1):47\u201365, 1979. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 P.W. Cleary. Industrial particle flow modelling using discrete element method. Engineering Computations , 26(6):698\u2013743, 2009. \u21a9 E. Tijskens, H. Ramon, and J. De Baerdemaeker. Discrete element modelling for process simulation in agriculture. Journal of sound and vibration , 266(3):493\u2013514, 2003. \u21a9 C. O'Sullivan. Particle-based discrete element modeling: geomechanics perspective. International Journal of Geomechanics , 11(6):449\u2013464, 2011. \u21a9 J.E. Andrade and C.F. Avila. Granular element method (GEM): linking inter-particle forces with macroscopic loading. Granular Matter , 14(1):51\u201361, 2012. \u21a9 J.E. Andrade, Q. Chen, P.H. Le, C.F. Avila, and T.M. Evans. On the rheology of dilative granular media: bridging solid-and fluid-like behavior. Journal of the Mechanics and Physics of Solids , 60(6):1122\u20131136, 2012. \u21a9 N. Guo and J. Zhao. Multiscale insights into classical geomechanics problems. International Journal for Numerical and Analytical Methods in Geomechanics , 40(3):367\u2013390, 2016. \u21a9 Q. Chen. Multiscale Modeling of Failure in Granular Media: From Continuum Scales to Granular Scale . PhD thesis, Northwestern University, 2011. \u21a9 P. Liu and C.M. Hrenya. Challenges of DEM: I. Competing bottlenecks in parallelization of gas\u2013solid flows. Powder Technology , 264:620\u2013626, 2014. \u21a9 K.J. Berger and C.M. Hrenya. Challenges of DEM: II. Wide particle size distributions. Powder Technology , 264:627\u2013633, 2014. \u21a9 W. Zhong, A. Yu, X. Liu, Z. Tong, and H. Zhang. DEM/CFD-DEM modelling of non-spherical particulate systems: theoretical developments and applications. Powder Technology , 302:108\u2013152, 2016. \u21a9 \u21a9 M. Jiang, H. S. Yu, and D. Harris. A novel discrete model for granular material incorporating rolling resistance. Computers and Geotechnics , 32(5):340\u2013357, 2005. \u21a9 \u21a9 M. Jiang, Z. Shen, and J. Wang. A novel three-dimensional contact model for granulates incorporating rolling and twisting resistances. Computers and Geotechnics , 65:147\u2013163, 2015. \u21a9 H.R. Hertz. Uber die Beruhrung fester elastischer Korper und Uber die Harte. Verhandlung des Vereins zur Beforderung des GewerbefleiBes, Berlin , pages 449, 1882. \u21a9 \u21a9 R.D. Mindlin. Elastic spheres in contact under varying oblique forces. Journal of Applied Mechanics , 20:327\u2013344, 1953. \u21a9 \u21a9 A. Di Renzo and F.P. Di Maio. An improved integral non-linear model for the contact of particles in distinct element simulations. Chemical Engineering Science , 60(5):1303\u20131312, 2005. \u21a9 \u21a9 D. O. Potyondy and P. A. Cundall. A bonded-particle model for rock. International journal of rock mechanics and mining sciences , 41(8):1329\u20131364, 2004. \u21a9 \u21a9 Y.C. Chung. Discrete element modelling and experimental validation of a granular solid subject to different loading conditions . PhD thesis, University of Edinburgh, 2006. \u21a9 \u21a9 \u21a9 Itasca Consulting Group, Inc. PFC \u2013 Particle Flow Code, Ver. 5.0. 2014. Minneapolis: Itasca. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 M. Otsubo, C. O'Sullivan, and T. Shire. Empirical assessment of the critical time increment in explicit particulate discrete element method simulations. Computers and Geotechnics , 86:67\u201379, 2017. \u21a9 \u21a9 R. Hart, P.A. Cundall, and J. Lemos. Formulation of a three-dimensional distinct element model\u2013Part II. Mechanical calculations for motion and interaction of a system composed of many polyhedral blocks. International Journal of Rock Mechanics and Mining Sciences & Geomechanics Abstracts , 25(3):117\u2013125, 1988. \u21a9 C. Thornton. Numerical simulations of deviatoric shear deformation of granular media. G\u00e9otechnique , 50(1):43\u201353, 2000. \u21a9 Y. Li, Y. Xu, and C. Thornton. A comparison of discrete element simulations and experiments for `sandpiles' composed of spherical particles. Powder Technology , 160(3):219\u2013228, 2005. \u21a9 \u21a9 Y.T. Feng, K. Han, and D.R.J. Owen. A generic contact detection framework for cylindrical particles in discrete element modelling. Computer Methods in Applied Mechanics and Engineering , 315:632\u2013651, 2017. \u21a9 B. Nassauer, T. Liedke, and M. Kuna. Polyhedral particles for the discrete element method. Granular Matter , 15(1):85\u201393, 2013. \u21a9 G.A. D'Addetta, F. Kun, and E. Ramm. On the application of a discrete model to the fracture process of cohesive granular materials. Granular matter , 4(2):77\u201390, 2002. \u21a9 X. Lin and T.T. Ng. A three-dimensional discrete element model using arrays of ellipsoids. G\u00e9otechnique , 47(2):319\u2013329, 1997. \u21a9 J.M. Ting, M. Khwaja, L.R. Meachum, and J.D. Rowell. An ellipse-based discrete element model for granular materials. International Journal for Numerical and Analytical Methods in Geomechanics , 17(9):603\u2013623, 1993. \u21a9 J.R. Williams and A.P. Pentland. Superquadrics and modal dynamics for discrete elements in interactive design. Engineering Computations , 9(2):115\u2013127, 1992. \u21a9 A. Podlozhnyuk, S. Pirker, and C. Kloss. Efficient implementation of superquadric particles in discrete element method within an open-source framework. Computational Particle Mechanics , 4(1):101\u2013118, 2017. \u21a9 J. E. Andrade, K. W. Lim, C. F. Avila, and I. Vlahini\u0107. Granular element method for computational particle mechanics. Computer Methods in Applied Mechanics and Engineering , 241:262\u2013274, 2012. \u21a9 \u21a9 J.F. Peters, M.A. Hopkins, R. Kala, and R.E. Wahl. A poly-ellipsoid particle for non-spherical discrete element method. Engineering Computations , 26(6):645\u2013657, 2009. \u21a9 B. Zhang, R. Regueiro, A. Druckrey, and K. Alshibli. Construction of poly-ellipsoidal grain shapes from SMT imaging on sand, and the development of a new DEM contact detection algorithm. Engineering Computations , 35(2):733\u2013771, 2018. \u21a9 R. Kawamoto, E. And\u00f2, G. Viggiani, and J.E. Andrade. Level set discrete element method for three-dimensional computations with triaxial case study. Journal of the Mechanics and Physics of Solids , 91:1\u201313, 2016. \u21a9 N. Das. Modeling three-dimensional shape of sand grains using discrete element method . PhD thesis, University of South Florida, 2007. \u21a9 C. Kloss, C. Goniva, A. Hager, S. Amberger, and S. Pirker. Models, algorithms and validation for opensource DEM and CFD\u2013DEM. Progress in Computational Fluid Dynamics, an International Journal , 12(2):140\u2013152, 2012. \u21a9 K. Iwashita and M. Oda. Rolling resistance at contacts in simulation of shear band development by dem. Journal of engineering mechanics , 124(3):285\u2013292, 1998. \u21a9 S. Luding. Cohesive, frictional powders: contact models for tension. Granular matter , 10(4):235, 2008. \u21a9 Y. Wang, F. Alonso-Marroquin, S. Xue, and J. Xie. Revisiting rolling and sliding in two-dimensional discrete element models. Particuology , 18:35\u201341, 2015. \u21a9 J. P. Plassiard, N. Belheine, and F. V. Donz\u00e9. A spherical discrete element model: calibration procedure and incremental response. Granular Matter , 11(5):293\u2013306, 2009. \u21a9 S. Chehreghani, M. Noaparast, B. Rezai, and S. Z. Shafaei. Bonded-particle model calibration using response surface methodology. Particuology , 32:141\u2013152, 2017. \u21a9 C. J. Coetzee. Calibration of the discrete element method. Powder Technology , 310:104\u2013142, 2017. \u21a9 \u21a9 \u21a9 D. Schulze. Powders and bulk solids . Springer, Heidelberg, Germany, 2008. \u21a9","title":"Dem basics"},{"location":"documentation/dem_basics/#_1","text":"DEM wiki \u250a Next [This page is part of Dr. Zhengshou Lai's dissertation .] This page presents a brief introduction and review of the discrete element method (DEM). The intention is to introduce the main components and basic computational workflow of a DEM model, providing necessary background information to the research presented in this dissertation.","title":""},{"location":"documentation/dem_basics/#overview","text":"DEM is a particle-based numerical model that is particularly suitable for describing the mechanical behavior of bulk granular materials. It was first proposed by Cundall &Strack (1979) 2 for the analysis of geotechnical materials. Since then, DEM has been applied to model all kinds of granular materials and to simulate the problems ranging from solids handling to powder flowing in a variety of different engineering branches 3 4 5 . In DEM, all individual particles in the bulk granular material are explicitly modeled and a DEM model directly captures the interactions between particles and tracks the motions of each particle. The bulk behavior of a granular material is presented as an assembly of the actions (i.e., the interactions and motions) of all constituent particles. As a particle-based numerical model, DEM exhibits several advantages compared to the classical continuum theory-based numerical models. First, it bypasses the phenomenological constitutive models for describing the bulk behavior of a granular material within a representative volume 6 7 8 . Second, it is straightforward for the DEM to simulate the problems involving large deformation or material failure, such as granular flow, penetration, or strain localization 9 . The major drawback of DEM is also obvious. As DEM tracks the interactions and motions of all particles, DEM simulations are quite computationally expensive, which makes it difficult to scale up 10 11 . Nevertheless, with the advent of computer hardware and parallel capabilities, the DEM has become an increasingly powerful numerical tool that can provide valuable information of and shed lights upon the microscopic behavior of granular materials, which is often difficult or impossible to obtain from classical continuum-based numerical models or from physical experiments.","title":"Overview"},{"location":"documentation/dem_basics/#key-components-of-dem","text":"","title":"Key components of DEM"},{"location":"documentation/dem_basics/#basic-elements","text":"In general, there are two types of basic elements in a DEM model: particles and boundaries. The basic elements are assumed to be rigid but can have overlaps with each other. A particle is a body that has a closed surface. It may be represented by a simple geometry (e.g., sphere or ellipsoid) or a composition of several simple geometries that make up the body surface (see further discussions in ). A review on the particle geometric representations can be found in Zhong et al. (2016) 12 . Particles have mass and their motion (i.e., position, velocity, and acceleration) is always tracked during a DEM simulation. Boundaries are also referred to as walls in the DEM literature. They may as well be represented by simple geometries (e.g., triangles) or their combinations, but they do not necessarily have closed surfaces. Boundaries do not have mass and their position and velocity are usually prescribed to provide the desired constraints to the particles in the model.","title":"Basic elements"},{"location":"documentation/dem_basics/#contacts-and-contact-models","text":"Contacts describe the interactions between basic elements. Contact occurs when the surfaces of two basic elements overlap with each other (to model collisions), or when the surfaces are within a specified distance (to model long-range bond or cohesion). Detecting the contacts between basic elements is a mathematical geometry problem and is one of the most time-consuming parts of a DEM simulation. One important task associated with contact detection is to characterize the contact geometric features, which are needed by a contact model to calculate the contact forces and moments. The contact features may include the overlapping (or indentation) distance, relative shear displacement, contact point, contact branch vectors, and so on. Contact models are used to calculate the contact forces and moments between the two elements in contact. Commonly used contact models include the linear elastic model 2 , the rolling resistance model 13 14 , the Hertz-Mindlin model 15 16 17 , and the linear parallel bond model 18 . The formulation of these contact models will be presented in .","title":"Contacts and contact models"},{"location":"documentation/dem_basics/#newton-euler-equations-of-motion","text":"In DEM, the motion of a particle can be described by the Newton-Euler equations of motion. For any arbitrarily-shaped particle, the Newton-Euler equations of motion are written as \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M} \\end{align} \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha}+\\boldsymbol{\\omega}\\times L &= \\boldsymbol{M} \\end{align} where m m is the mass of the particle; \\boldsymbol{I} \\boldsymbol{I} is the inertia tensor of the particle; \\boldsymbol{a} \\boldsymbol{a} and \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} are the translational and rotational acceleration; \\boldsymbol{F} \\boldsymbol{F} and \\boldsymbol{M} \\boldsymbol{M} are the overall external forces and moments acting on the particle; \\boldsymbol{\\omega} \\boldsymbol{\\omega} is the vector of the angular velocities about the principal axes. Herein, the variable in bold-symbol indicates a vector or a tensor. For spherical particles, the Newton-Euler equations of motion reduce to \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M} \\end{align} \\begin{align} m\\boldsymbol{a} &= \\boldsymbol{F} \\\\ \\boldsymbol{I}\\boldsymbol{\\alpha} &= \\boldsymbol{M} \\end{align} In order to resolve the motion of each particle, all the forces and moments acting on the particle need to be evaluated and summed, which may include gravity, damping, contact forces and moments, and prescribed external forces and moments. Herein, the damping refers to the global damping, which is sometimes (artificially) introduced in a DEM model to facilitate energy dissipation and enhance a quasi-static simulation 19 20 . There is another type of damping called local damping, which is usually incorporated into a contact model as dash-pot forces to account for the realistic energy dissipation due to particle interactions.","title":"Newton-Euler equations of motion"},{"location":"documentation/dem_basics/#time-integration","text":"To fully resolve the particle motion (e.g., the position and velocity) governed by and involves the time integration scheme, where the second-order Velocity Verlet algorithm is commonly adopted. For spherical particles, suppose that the current state is indexed by time t t and the time increment to the next state is \\Delta t \\Delta t , Velocity Verlet algorithm first calculates the particle velocities at time t t + \\Delta t/2 \\Delta t/2 by \\begin{align} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2 \\end{align} \\begin{align} \\boldsymbol{v}^{t+\\Delta t/2} &= \\boldsymbol{v}^t + \\boldsymbol{a}^t\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t/2} &= \\boldsymbol{\\omega}^t + \\boldsymbol{\\alpha}^t\\Delta t/2 \\end{align} where \\boldsymbol{v} \\boldsymbol{v} and \\boldsymbol{\\omega} \\boldsymbol{\\omega} are translational and angular velocities, respectively. The superscripts (e.g., t t and \\Delta t/2 \\Delta t/2 ) indicate the time indexes. Then, the position and orientation of the particle at time t t + \\Delta t \\Delta t are calculated as \\begin{align} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{align} \\begin{align} \\boldsymbol{x}^{t+\\Delta t} &= \\boldsymbol{x}^t + \\boldsymbol{v}^{t+\\Delta t/2}\\Delta t \\\\ \\boldsymbol{\\theta}^{t+\\Delta t} &= \\boldsymbol{\\theta}^t + \\boldsymbol{\\omega}^{t+\\Delta t/2}\\Delta t \\end{align} where \\boldsymbol{x} \\boldsymbol{x} is the vector of position and \\boldsymbol{\\theta} \\boldsymbol{\\theta} is the vector of orientation. Correspondingly, the translational velocity and angular velocity at time t+\\Delta t t+\\Delta t are updated by \\begin{align} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{align} \\begin{align} \\boldsymbol{v}^{t+\\Delta t} &= \\boldsymbol{v}^{t+\\Delta t/2} + \\boldsymbol{a}^{t+\\Delta t/2}\\Delta t/2 \\\\ \\boldsymbol{\\omega}^{t+\\Delta t} &= \\boldsymbol{\\omega}^{t+\\Delta t/2} + \\boldsymbol{\\alpha}^{t+\\Delta t/2}\\Delta t/2 \\end{align} For non-spherical particles, the original Newton-Euler equations of motion cannot be simplified, and the calculation of the orientations and angular velocity will be much more complicated. A more detailed discussion on the time integration for non-spherical particles will not be included here but can be found in the work of Chung (2006) 19 and the PFC user manual 20 .","title":"Time integration"},{"location":"documentation/dem_basics/#critical-timestep","text":"The time integration based on the second-order Velocity Verlet algorithm is numerically stable only when the time increment being used is less than a threshold value, i.e. the critical timestep 21 . If a time increment greater than the critical timestep is used, particles may move too much in one increment, which will result in spuriously infinite overlapping (i.e., abnormally large contact forces). A summary and empirical assessment of different approaches to estimate the critical timestep for DEM simulations can be found in Otsubo et al. (2017) 21 . Basically, there are two categories of approaches to estimate the critical timestep: the oscillation period of a single degree of freedom system (SDOF) based approaches 2 22 , and the Rayleigh wave speed based approaches 23 24 . The former approaches consider the DEM system to be consist of rigid bodies connected by springs, while the latter ones consider the particles themselves to be springs. In the category of the SDOF-based approaches, Cundall & Stract (1979) 2 proposed the following expression to estimate the critical timestep \\Delta t_\\text{crit} \\Delta t_\\text{crit} \\begin{align} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\end{align} \\begin{align} \\Delta t_\\text{crit} = \\min(\\sqrt{m/k^\\text{tran}}, \\sqrt{I_i/k_i^\\text{rot}}) \\end{align} where m m is the mass of the particle; I_i I_i is the moment of inertia of the particle; k^\\text{tran} k^\\text{tran} and k_i^\\text{rot} k_i^\\text{rot} represent the translational and rotational stiffness, and the subscript i i indicates the index of principal components. In the category of the Rayleigh wave speed based approaches, Li et al. (2005) 24 proposed that \\begin{align} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\end{align} \\begin{align} \\Delta t_\\text{crit} = \\frac{\\pi R \\sqrt{\\rho/G}}{0.1631\\nu+0.8766} \\end{align} where R R is the average particle radius; \\rho \\rho is the particle density; G G the particle shear modulus; and \\nu \\nu the Poisson's ratio of the particle.","title":"Critical timestep"},{"location":"documentation/dem_basics/#computational-workflow","text":"DEM-based numerical simulations require cyclic calculations. shows the workflow and calculations that are involved in one typical cycle of a DEM simulation. The workflow and calculations for one DEM cycle can be summarized as follows: At the current state, the positions and velocities of all particles are known: based on the geometries of all particles, identify the inter-particle contacts and evaluate contact features; Calculate the external forces and moments of all particles, while the contact forces and moments are calculated based on selected contact models and the corresponding contact features; Calculate the motion (i.e., the accelerations) of all particles; Update the positions and velocities of all particles following the selected time integration scheme.","title":"Computational workflow"},{"location":"documentation/dem_basics/#particle-representation","text":"There are basically two groups of methods to represent an irregular particle in DEM 12 : single-particle method and composite-particle method.","title":"Particle representation"},{"location":"documentation/dem_basics/#single-particle-method","text":"The single-particle method utilizes closed geometries to represent particle shapes. Many single-particle-based DEM models have been proposed and developed with the adoption of some specific closed geometries, such as cylinder 25 , polyhedron (or polygon in 2D) 26 27 , ellipsoid (or ellipse in 2D) 28 29 , superquadrics 30 31 , Non-Uniform Rational Basis Spline (NURBS) 32 , as well as their combinations (e.g., poly-ellipsoid 33 34 ). Each of these methods has its own advantages and limitations. The application of the cylinder-based or ellipsoid-based DEM models is limited, due to the particular particle shapes they can represent. The superquadric can be considered as an extension of the ellipsoid and can be used for modeling of spheres, ellipsoids, cylinder-like and box(dice)-like particles by varying the shape parameters. It is more flexible by being able to model larger variations of particle shapes, but also more computationally expensive than the ellipsoid-based DEM models. The polyhedron- (or polygon in 2D) based DEM model is able to replicate arbitrary particle shapes. The accuracy of the shape represented by polyhedron depends on the number of faces in a polyhedron, whereas a large number of faces would hinder the computational efficiency. Moreover, polyhedron can rarely replicate a smooth particle shape. The NURBS based granular element method, developed by Andrade et al. (2012) 32 , is advantageous to replicate general and smooth particle shapes, whereas it is computationally expensive compared to the polyhedron-based DEM. Recently, Kawamoto et al. (2016) 35 developed another novel type of single-particle-based DEM, which utilizes the level set (LS) method to represent particles. The LS-DEM seamlessly utilizes the level set data of realistic particle shapes characterized from X-ray computational tomography and is computationally efficient. One issue with the LS-DEM is high memory consumption, which somewhat limits its application on large particulate systems.","title":"Single-particle method"},{"location":"documentation/dem_basics/#composite-particle-method","text":"In a composite-particle method, a particle is represented by compositions of simple geometries (usually spheres in 3D or circles in 2D 36 1 ). This group of methods is advantageous to implementation for that the contact detection and resolution algorithms for the simple geometries can be effortlessly exploited. It should be noted that the accuracy of particle shape represented by compositions of simple geometries depends on the amount of the simple geometries, and a large number of simple geometries would lead to great computational expense though. Nonetheless, the composite-particle method (especially with spheres as the base elements) is currently the most prevalent method to model irregular particles and is supported in most commercial or open-source DEM packages such as PFC 20 and LIGGGHTS 37 . There are three options to represent a composite particle (a) (b) (c) A schematic illustration of the three options to represent a composite particle with discs (modified after 1 )","title":"Composite-particle method"},{"location":"documentation/dem_basics/#contact-models","text":"A DEM contact model is normally comprised of springs, dash-pots, and sliders to describe the force-displacement behavior at the contact, where the springs account for normal and tangential forces, the dash-pots account for local damping, and the sliders account for shear failure. The formulation of contact models that will be used in this dissertation is presented in this section.","title":"Contact models"},{"location":"documentation/dem_basics/#linear-elastic-model","text":"A linear elastic model generally consists of two elastic springs, two dash-pots, and a slider, as shown schematically in the following. The contact forces \\boldsymbol{F} \\boldsymbol{F} are calculated from two parts: the normal force \\boldsymbol{F}_n \\boldsymbol{F}_n and the shear (or tangential) force \\boldsymbol{F}_s \\boldsymbol{F}_s \\begin{align} \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\end{align} \\begin{align} \\boldsymbol{F} = \\boldsymbol{F}_n + \\boldsymbol{F}_s = F_n\\boldsymbol{n}_n + F_s\\boldsymbol{n}_s \\end{align} where \\boldsymbol{n}_n \\boldsymbol{n}_n and \\boldsymbol{n}_s \\boldsymbol{n}_s are the unit vectors denoting the direction of the normal and the shear force, respectively; F_n F_n and F_s F_s are the magnitudes of corresponding contact forces. Assuming the relative displacement increment at the contact during a timestep \\Delta t \\Delta t is given by its components \\Delta \\delta_n \\Delta \\delta_n (compression as a positive) and \\Delta \\delta_s \\Delta \\delta_s , the contact law for a simple linear model with local damping updates the contact forces through 2 20 \\begin{align} F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} \\begin{align} F_n &= F_n^0 + k_n\\Delta\\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} where F_n^0 F_n^0 and F_s^0 F_s^0 are the normal and the shear forces at the beginning of the current timestep, respectively; k_n k_n and k_s k_s are the corresponding stiffness; \\eta_n \\eta_n and \\eta_s \\eta_s are the corresponding damping coefficients; \\dot{\\delta}_n \\dot{\\delta}_n and \\dot{\\delta}_s \\dot{\\delta}_s are the relative normal and shear velocity; \\mu_c \\mu_c is the contact friction coefficient; and \\bar{m} = m_im_j/(m_i+m_j) \\bar{m} = m_im_j/(m_i+m_j) is the effective mass of particles i i and j j associated with the contact, while \\bar{m} = m_i \\bar{m} = m_i for the case of particle-boundary contact.","title":"Linear elastic model"},{"location":"documentation/dem_basics/#rolling-resistance-model","text":"The rolling resistance model is built upon the linear elastic model by adding a term of rolling resistance moment to the contact moment. The formulation to calculate the additional rolling resistance moment can be written as 38 13 20 \\begin{align} M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) \\end{align} \\begin{align} M = \\min(M^0 + k_r\\Delta\\theta_b, \\mu_r \\bar{R} F_n) \\end{align} where M^0 M^0 is the contact moment at the beginning of the current timestep; \\Delta\\theta_b \\Delta\\theta_b is the relative bending-rotation increment; \\mu_r \\mu_r is the rolling resistance coefficient; k_r k_r is the rolling resistance stiffness defined as: \\begin{align} k_r = k_s\\bar{R}^2 \\end{align} \\begin{align} k_r = k_s\\bar{R}^2 \\end{align} where \\bar{R} \\bar{R} is the contact effective radius defined as \\bar{R}=R_iR_j/(R_i+R_j) \\bar{R}=R_iR_j/(R_i+R_j) , in which R_i R_i and R_j R_j are the radii of the contact particles. If one side of the contact is a wall, the corresponding radius R_j \\rightarrow \\infty R_j \\rightarrow \\infty . This model uses a simplified formulation for the rolling kinematics, and the particle size effects on the rolling resistance are implicitly incorporated in the rolling stiffness term. The interested reader is referred to Luding (2008) 39 , Wang et al. (2015) 40 for examples of improved and more advanced rolling resistance models.","title":"Rolling resistance model"},{"location":"documentation/dem_basics/#hertz-mindlin-model","text":"The Hertz-Mindlin model is a complete frictional contact model based upon the Hertz theory 15 for contact normal forces and the Mindlin theory 16 for contact tangential forces. It takes into account the stiffness variation due to the change of contact areas during the collision of two elastic spheres. Similar to the linear elastic model, the Hertz-Mindlin model also consists of two springs, two dash-pots, and a slider. There are, however, two major differences. First, the normal and shear stiffness in the Hertz-Mindlin model are functions of the contact overlapping distance. Second, the normal contact force in the Hertz-Mindlin model is calculated via the cumulative overlapping distance, while the linear elastic model uses either the cumulative or incremental overlapping distance. To update the contact forces, the Hertz-Mindlin model follows \\begin{align} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} \\begin{align} F_n &= k_n \\delta_n - \\eta_n\\sqrt{\\bar{m}k_n}\\dot{\\delta}_n \\\\ F_s &= \\min(F_s^0 + k_s\\Delta\\delta_s - \\eta_s\\sqrt{\\bar{m}k_s}\\dot{\\delta}_s, \\mu_c F_n) \\end{align} where \\delta_n \\delta_n is the cumulative overlapping distance, while k_n k_n and k_s k_s are calculated as 17 : \\begin{align} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{align} \\begin{align} k_n &= \\frac{4}{3}\\bar{E}\\sqrt{\\bar{R}\\delta_n} \\\\ k_s &= 8\\bar{G}\\sqrt{\\bar{R}\\delta_n} \\end{align} in which \\begin{align} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{align} \\begin{align} \\frac{1}{\\bar{E}} &= \\frac{(1-\\nu_i^2)}{E_i} + \\frac{(1-\\nu_j^2)}{E_j} \\\\ \\frac{1}{\\bar{G}} &= \\frac{2(2-\\nu_i)(1+\\nu_i)}{E_i} + \\frac{2(2-\\nu_j)(1+\\nu_j)}{E_j} \\end{align} where \\bar{E} \\bar{E} and \\bar{G} \\bar{G} are the effective Young's modulus and shear modulus of the particles in contact; E_i E_i is the Young's modulus and \\nu_i \\nu_i is the Poisson's ratio of the i i th particle.","title":"Hertz-Mindlin model"},{"location":"documentation/dem_basics/#linear-parallel-bond-model","text":"The linear parallel bond model describes the contact behavior of two bonded particles, as shown schematically in the following. In the linear parallel bond model, the bond between two spheres is assumed to be a cylinder of finite radius and thickness. Each point in the bond is imposed by two linear elastic springs providing normal and shear resistances, respectively. The overall bonding force and moment are the integral of the normal and shear stresses at a cross-section of the bond, which can be calculated as 18 \\begin{align} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s \\end{align} \\begin{align} \\Delta F_n^b &= k_n^b A \\Delta \\delta_n \\\\ \\Delta F_s^b &= k_s^b A \\Delta \\delta_s \\\\ \\Delta M_n^b &= k_s^b J \\Delta \\theta_n \\\\ \\Delta M_s^b &= k_n^b I \\Delta \\theta_s \\end{align} where F_n^b F_n^b , F_s^b F_s^b , M_n^b M_n^b and M_s^b M_s^b are the bond normal force, shear force, twisting moment, and swinging moment, respectively; \\delta_n \\delta_n , \\delta_s \\delta_s , \\theta_n \\theta_n , and \\theta_s \\theta_s are the relative normal displacement, shear displacement, twisting rotation, and swinging rotation between the two bonded spheres, respectively; A A , I I , and J J are the area, moment of inertia, and polar moment of inertia of the bond (i.e., the circular cross-section with radius R^b R^b ), respectively; and \\Delta \\Delta indicates the increment of each variable in each time step. It should be pointed out that, while the damping is not included in the current formulation, damping terms similar to those in the linear elastic model can be incorporated in a straightforward manner. The bonded-sphere model is also capable of modeling the particle breakage behavior. As an example of a common bond breakage criterion, it can be assumed that a bond would break if the maximum normal or shear stress at the bond exceeds the corresponding normal or shear strength. In the linear parallel bond model, both the normal force and swinging moment contribute to the normal stress, while both the shear force and twisting moment contribute to the shear stress. In this regard, the bond breakage criterion can be written as \\begin{align} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{align} \\begin{align} \\sigma_{\\max}^b &= \\frac{F_n^b}{A}+\\frac{M_s^bR^b}{I} < \\sigma_{Y,n}^b \\\\ \\tau_{\\max}^b &= \\frac{F_s^b}{A}+\\frac{M_n^bR^b}{J} < \\sigma_{Y,s}^b \\end{align} where \\sigma_{Y,n}^b \\sigma_{Y,n}^b and \\sigma_{Y,s}^b \\sigma_{Y,s}^b are the normal and shear strength, respectively.","title":"Linear parallel bond model"},{"location":"documentation/dem_basics/#model-calibration","text":"As most of the contact parameters in a DEM model are difficult if not impossible to be measured directly from physical tests, a calibration process is often needed to obtain the contact parameters for a specific material of interest. There are some researches available on the procedures to calibrate contact parameters for a DEM model 41 42 43 . Usually, the calibration process is accomplished by performing parametric studies on each of contact parameters and selecting values of the contact parameters with which the DEM simulation can reproduce the benchmark matrices of laboratory experiments. Commonly used laboratory experiments for calibration of DEM parameters include compression test, direct and ring shear test, and angle of repose test. Descriptions of these tests can be found in Schulze (2008) 44 , Coetzee (2017) 43 . There are some challenges and problems associated with the model calibration. First, to obtain reasonable and realistic contact parameters via calibration, it is necessary that the setup and procedures in the DEM models are to the most extent similar to those in the laboratory experiments. However, in order to get the DEM simulations performed within affordable computational resources, adjustments or tolerances in the particle size, shape or testing speed may exist in a DEM model. As a result, the calibrated contact parameters may deviate from their actual values to some degree. In addition, the contact features and contact models are usually quite simple and conceptual compared to the actual complex contact behavior. The physical meaning of the contact parameters may be lost due to the use of conceptualized contact features and contact models. Lastly, as pointed out in 43 , the solution of contact parameters might not be unique since all contact parameters may affect the results of a DEM simulation in a complex and highly nonlinear manner. There is no guarantee that the contact parameters for a material calibrated for one experiment will be workable for another. In this regard, it would be necessary to perform the calibration with one experiment and validate the calibration results via another. DEM wiki \u250a Next","title":"Model calibration"},{"location":"documentation/dem_basics/#references","text":"C. Shi, D. Li, W. Xu, and R. Wang. Discrete element cluster modeling of complex mesoscopic particles for use with the particle flow code method. Granular Matter , 17(3):377\u2013387, 2015. \u21a9 \u21a9 P. A Cundall and O. D. L. Strack. A discrete numerical model for granular assemblies. geotechnique , 29(1):47\u201365, 1979. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 P.W. Cleary. Industrial particle flow modelling using discrete element method. Engineering Computations , 26(6):698\u2013743, 2009. \u21a9 E. Tijskens, H. Ramon, and J. De Baerdemaeker. Discrete element modelling for process simulation in agriculture. Journal of sound and vibration , 266(3):493\u2013514, 2003. \u21a9 C. O'Sullivan. Particle-based discrete element modeling: geomechanics perspective. International Journal of Geomechanics , 11(6):449\u2013464, 2011. \u21a9 J.E. Andrade and C.F. Avila. Granular element method (GEM): linking inter-particle forces with macroscopic loading. Granular Matter , 14(1):51\u201361, 2012. \u21a9 J.E. Andrade, Q. Chen, P.H. Le, C.F. Avila, and T.M. Evans. On the rheology of dilative granular media: bridging solid-and fluid-like behavior. Journal of the Mechanics and Physics of Solids , 60(6):1122\u20131136, 2012. \u21a9 N. Guo and J. Zhao. Multiscale insights into classical geomechanics problems. International Journal for Numerical and Analytical Methods in Geomechanics , 40(3):367\u2013390, 2016. \u21a9 Q. Chen. Multiscale Modeling of Failure in Granular Media: From Continuum Scales to Granular Scale . PhD thesis, Northwestern University, 2011. \u21a9 P. Liu and C.M. Hrenya. Challenges of DEM: I. Competing bottlenecks in parallelization of gas\u2013solid flows. Powder Technology , 264:620\u2013626, 2014. \u21a9 K.J. Berger and C.M. Hrenya. Challenges of DEM: II. Wide particle size distributions. Powder Technology , 264:627\u2013633, 2014. \u21a9 W. Zhong, A. Yu, X. Liu, Z. Tong, and H. Zhang. DEM/CFD-DEM modelling of non-spherical particulate systems: theoretical developments and applications. Powder Technology , 302:108\u2013152, 2016. \u21a9 \u21a9 M. Jiang, H. S. Yu, and D. Harris. A novel discrete model for granular material incorporating rolling resistance. Computers and Geotechnics , 32(5):340\u2013357, 2005. \u21a9 \u21a9 M. Jiang, Z. Shen, and J. Wang. A novel three-dimensional contact model for granulates incorporating rolling and twisting resistances. Computers and Geotechnics , 65:147\u2013163, 2015. \u21a9 H.R. Hertz. Uber die Beruhrung fester elastischer Korper und Uber die Harte. Verhandlung des Vereins zur Beforderung des GewerbefleiBes, Berlin , pages 449, 1882. \u21a9 \u21a9 R.D. Mindlin. Elastic spheres in contact under varying oblique forces. Journal of Applied Mechanics , 20:327\u2013344, 1953. \u21a9 \u21a9 A. Di Renzo and F.P. Di Maio. An improved integral non-linear model for the contact of particles in distinct element simulations. Chemical Engineering Science , 60(5):1303\u20131312, 2005. \u21a9 \u21a9 D. O. Potyondy and P. A. Cundall. A bonded-particle model for rock. International journal of rock mechanics and mining sciences , 41(8):1329\u20131364, 2004. \u21a9 \u21a9 Y.C. Chung. Discrete element modelling and experimental validation of a granular solid subject to different loading conditions . PhD thesis, University of Edinburgh, 2006. \u21a9 \u21a9 \u21a9 Itasca Consulting Group, Inc. PFC \u2013 Particle Flow Code, Ver. 5.0. 2014. Minneapolis: Itasca. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 M. Otsubo, C. O'Sullivan, and T. Shire. Empirical assessment of the critical time increment in explicit particulate discrete element method simulations. Computers and Geotechnics , 86:67\u201379, 2017. \u21a9 \u21a9 R. Hart, P.A. Cundall, and J. Lemos. Formulation of a three-dimensional distinct element model\u2013Part II. Mechanical calculations for motion and interaction of a system composed of many polyhedral blocks. International Journal of Rock Mechanics and Mining Sciences & Geomechanics Abstracts , 25(3):117\u2013125, 1988. \u21a9 C. Thornton. Numerical simulations of deviatoric shear deformation of granular media. G\u00e9otechnique , 50(1):43\u201353, 2000. \u21a9 Y. Li, Y. Xu, and C. Thornton. A comparison of discrete element simulations and experiments for `sandpiles' composed of spherical particles. Powder Technology , 160(3):219\u2013228, 2005. \u21a9 \u21a9 Y.T. Feng, K. Han, and D.R.J. Owen. A generic contact detection framework for cylindrical particles in discrete element modelling. Computer Methods in Applied Mechanics and Engineering , 315:632\u2013651, 2017. \u21a9 B. Nassauer, T. Liedke, and M. Kuna. Polyhedral particles for the discrete element method. Granular Matter , 15(1):85\u201393, 2013. \u21a9 G.A. D'Addetta, F. Kun, and E. Ramm. On the application of a discrete model to the fracture process of cohesive granular materials. Granular matter , 4(2):77\u201390, 2002. \u21a9 X. Lin and T.T. Ng. A three-dimensional discrete element model using arrays of ellipsoids. G\u00e9otechnique , 47(2):319\u2013329, 1997. \u21a9 J.M. Ting, M. Khwaja, L.R. Meachum, and J.D. Rowell. An ellipse-based discrete element model for granular materials. International Journal for Numerical and Analytical Methods in Geomechanics , 17(9):603\u2013623, 1993. \u21a9 J.R. Williams and A.P. Pentland. Superquadrics and modal dynamics for discrete elements in interactive design. Engineering Computations , 9(2):115\u2013127, 1992. \u21a9 A. Podlozhnyuk, S. Pirker, and C. Kloss. Efficient implementation of superquadric particles in discrete element method within an open-source framework. Computational Particle Mechanics , 4(1):101\u2013118, 2017. \u21a9 J. E. Andrade, K. W. Lim, C. F. Avila, and I. Vlahini\u0107. Granular element method for computational particle mechanics. Computer Methods in Applied Mechanics and Engineering , 241:262\u2013274, 2012. \u21a9 \u21a9 J.F. Peters, M.A. Hopkins, R. Kala, and R.E. Wahl. A poly-ellipsoid particle for non-spherical discrete element method. Engineering Computations , 26(6):645\u2013657, 2009. \u21a9 B. Zhang, R. Regueiro, A. Druckrey, and K. Alshibli. Construction of poly-ellipsoidal grain shapes from SMT imaging on sand, and the development of a new DEM contact detection algorithm. Engineering Computations , 35(2):733\u2013771, 2018. \u21a9 R. Kawamoto, E. And\u00f2, G. Viggiani, and J.E. Andrade. Level set discrete element method for three-dimensional computations with triaxial case study. Journal of the Mechanics and Physics of Solids , 91:1\u201313, 2016. \u21a9 N. Das. Modeling three-dimensional shape of sand grains using discrete element method . PhD thesis, University of South Florida, 2007. \u21a9 C. Kloss, C. Goniva, A. Hager, S. Amberger, and S. Pirker. Models, algorithms and validation for opensource DEM and CFD\u2013DEM. Progress in Computational Fluid Dynamics, an International Journal , 12(2):140\u2013152, 2012. \u21a9 K. Iwashita and M. Oda. Rolling resistance at contacts in simulation of shear band development by dem. Journal of engineering mechanics , 124(3):285\u2013292, 1998. \u21a9 S. Luding. Cohesive, frictional powders: contact models for tension. Granular matter , 10(4):235, 2008. \u21a9 Y. Wang, F. Alonso-Marroquin, S. Xue, and J. Xie. Revisiting rolling and sliding in two-dimensional discrete element models. Particuology , 18:35\u201341, 2015. \u21a9 J. P. Plassiard, N. Belheine, and F. V. Donz\u00e9. A spherical discrete element model: calibration procedure and incremental response. Granular Matter , 11(5):293\u2013306, 2009. \u21a9 S. Chehreghani, M. Noaparast, B. Rezai, and S. Z. Shafaei. Bonded-particle model calibration using response surface methodology. Particuology , 32:141\u2013152, 2017. \u21a9 C. J. Coetzee. Calibration of the discrete element method. Powder Technology , 310:104\u2013142, 2017. \u21a9 \u21a9 \u21a9 D. Schulze. Powders and bulk solids . Springer, Heidelberg, Germany, 2008. \u21a9","title":"References"},{"location":"documentation/dem_wiki/","text":"DEM basics DEM basics : presents a brief introduction and review of the discrete element method (DEM). DEM elements Discrete to continuum : derives the macroscopic continuum-sense stress, strain and tangent moduli from the particle contact geometries and contact forces at microscopic discrete level. Particle models : describes the formulations of various particle models, including sphere, ellipsoid, poly-super-ellipsoid, poly-super-quadrics, cylinder, spherical harmonics, polyhedron, level set, and etc.","title":"DEM wiki"},{"location":"documentation/dem_wiki/#_1","text":"","title":""},{"location":"documentation/dem_wiki/#dem-basics","text":"DEM basics : presents a brief introduction and review of the discrete element method (DEM).","title":"DEM basics"},{"location":"documentation/dem_wiki/#dem-elements","text":"Discrete to continuum : derives the macroscopic continuum-sense stress, strain and tangent moduli from the particle contact geometries and contact forces at microscopic discrete level. Particle models : describes the formulations of various particle models, including sphere, ellipsoid, poly-super-ellipsoid, poly-super-quadrics, cylinder, spherical harmonics, polyhedron, level set, and etc.","title":"DEM elements"},{"location":"documentation/developer_manual/","text":"Code design General framework The program currently contains 7 basic moduli: dem: ingradients of DEM, including DEM solver, contact solver, contact models, and etc. domain: defines the computational domain input: used to interpret the input file. It is planned to adopt the json format as the data exchange format. Each json object corresponds to a command, and the simulation is constructed or modified through the execution of the command. The commands in plan definition 6: create, get, set, fix, unfix, run. create: create objects such as shape, particle, wall, contact model, modifier, etc. get: get object properties set: set object properties fix: Bind the defined modifier to simulation to activate. unfix: Unbind the defined evalua to make it invalid. run: start discrete element calculation modifier: defines some personalized calculations of the discrete element model, such as adding external forces, exporting data, etc. Because these personalized calculations are not required for every calculation model, they can be added to the model freely through this subscription method. Generally, the modifier is defined first, and then attached to a simulation and activated. When the discrete element is calculated to a certain node, the subscribed modifier will be called uniformly. Currently, two modifiers are defined: pre_modifier and post_modifier. pre_modifier is called at the beginning of each calculation cycle, and post_modifier is called at the end of each calculation cycle. mpi: data interaction between different parallel computing cores scene: contains particle, wall, contact model, modifier, etc. shape: defines the shape tmplates, including sphere, ellipsoid, cylinder, spherical harmonics, polyhedron, level set, and etc. utils: other tool functions Other moduli (as of Dec. 26, 2021): mlpack: wrapper of mlpack for machine learning exploration peridigm: wrapper of peridigm for particle breakage analysis pybind: for python interfaces Basic elements Particles: Particles have variables or attributes such as shape, position, speed, and force The movement of particles obeys Newton's law of motion The particles are in contact with each other to generate contact force, which is calculated according to the corresponding contact model Wall or boundary: The boundary has variables or attributes such as shape, position, and force The boundary is generally assumed to be massless, so there is no need to calculate - Newtonian motion, just update its position according to the preset motion law Contact: particle-to-particle, or particle-to-boundary contact with contact geometric characteristics, contact force and other attributes The contact model describes the relationship between contact force and contact geometric characteristics Calculation procedures The basic calculation process of discrete element (DEMSolver calculation process): Traverse all the \"particles\" in this calculation domain, and clear the force and torque to zero. Perform pre_modifier, such as gravity. Traverse all the \"particles\" in this computational domain to determine whether its contours touch other computational domains: if so, use MPI to transfer its data to the computational domain, and create a new particle in the target computational domain based on the particle data, as The particle is a proxy in the target computing domain, and the proxy particle can come into contact with other particles. The particles in this computing domain are called \"particle agents to be sent\", and the particles in the target computing domain are called \"received particle agents\". Receive the \"particle agent\" data and create an instance of the particle agent: If this calculation domain already contains the id of the particle agent, find the particle pointer through particlem_map, and update the particle instance with the received particle agent data; If the id of the particle agent does not exist, create a new \"particle_ghost\" instance, and update the particle instance with the received particle agent data; Traverse the \"granular agent to be sent\" and send its corresponding \"contact data\" to the target computing domain. Receive contact data and create contact instances: Determine the pointer of the particle according to the particle id, and determine the pointer of the contact model according to the contact model id Determine whether the contact exists through the contact_pp_list of the particle If it exists, update the contact instance from the received contact data. If it does not exist, establish a contact first, and use the received particle agent data to update the particle instance, Traverse all contacts and set their updated to false. Divide the computational domain into grids, traverse all the \"particles\" and \"received particle agents\" in the computational domain, and classify them into each grid. The classification criteria are: If the circumscribed cube of the particle or particle agent contacts a certain grid, then the particle or particle agent is added to the grid. Traverse all grids: Traverse the particles and particle agents in this grid to determine whether they are in contact. If touched: Determine whether it was in contact at the previous time step If yes, find the contact instance, update its contact geometric features and contact force, and set the updated of the contact to true If not, create a new contact instance, initialize the contact geometric features and calculate the contact force, and set the updated of the contact to true Apply contact force to particles and boundaries Traverse the \"received particle agent\": Traverse the contact of the particle agent, if the updated state of the contact is true, use MPI to send the contact data back to the original computing domain Receive contacts returned from other computing domains and reconstruct contact instances If the contact already exists, use the returned data to update the original contact If the contact does not exist, create a new contact and rebuild the particle pointer in the contact If the particle exists in the computational domain, the particle pointer is found through particle_map and particle id. If the particle does not exist in the computational domain, create a new \"particle illusion\" and set the \"particle illusion\" pointer to the contact. Apply contact force to particles Traverse all contacts If its updated status is false, delete the contact; Traverse all particles - Update its speed, position and other attributes according to Newton's law of motion Add the partial_proxy_list to the particle_ghost_list and clear the partial_proxy_list According to the updated particle position, traverse each particle to determine whether it exceeds the calculation domain: If so, send its data to the new computational domain of the particle, and move the particle to particle_ghost_list. Receive the \"particle\" data and create an instance of the particle: If this calculation domain already contains the id of the particle, find the particle pointer through particlem_map, and update the particle instance with the received particle data; If the id of the particle does not exist, create a new particle instance and update the particle instance with the received particle data; Traverse particle_ghost_list If it is not in contact with any particles or boundaries, delete the \"particle phantom\" Perform post_modifier, such as data output and other functions. Coding style We generally follow Google C++ Style Guide . Naming Filenames: lowercase words connected by underscores, e.g. particle.hpp , contact_pp.cpp . Variable names: lowercase words connected by underscores, e.g. dir_n . Class and struct names: words with first letters capitalized, e.g. DataDumper . Word following abbreviations shoudl be capitalized accordingly, e.g., GJKsolver, DEMgjk, GJKdemGJK, etc. Macros: should be capital, such as PI . Comment Comment is not a requisite, but please add it if an attribute or method is not self-explainary or is ambigious. We use doxygen to generate the code documentation. We suggest the following comment format. Block documentation (e.g., for class description): /** descriptions */ Line documentation: /// descriptions Other commands if approperiate: @warning {warning message}, @todo {things to be done}, @bug , @brief, @var\u3001@enum\u3001@struct\u3001@class\u3001 Formatting Use clang-format . Programing rules Use auto for local variables when appropriate. Mark const when appropriate. Reference vs. pointer: If a variable will not be altered after calling the function, use reference with const mark, e.g., const double &[variable] . If a variable will be altered, use pointer. For int or double, as well as lists of int or double, mark with const (e.g., double *const [variable] ) to aboid mistakenly modifying the pointer. If a variable will not be altered but its value will be passed and stored the calling instance, use pointer. Following the previous item, if you are going to modify a variable, please declare it or passing it as an argument with with & . Prefer use c++ std library rather than c library, e.g., use <cmath> rather than <math.h> . Avoid using smart pointers, such as std::unique_ptr , std::shared_ptr . Never ever use \"using\" (e.g., using namespace std ) in headers . Performance evaluation Procedures Tool: linux perf To probe the performance\uff1a sudo perf stat build/bin/tmp_debug Example performance counter stats: 12,639.97 msec task-clock # 0.983 CPUs utilized 1,284 context-switches # 0.102 K/sec 42 cpu-migrations # 0.003 K/sec 13,356 page-faults # 0.001 M/sec 26,566,855,696 cycles # 2.102 GHz 56,713,820,846 instructions # 2.13 insn per cycle 10,275,875,523 branches # 812.967 M/sec 31,362,265 branch-misses # 0.31% of all branches 12.857522834 seconds time elapsed 11.472000000 seconds user 1.120000000 seconds sys To sample CPU usage: sudo perf record -e task-clock -g build/bin/tmp_debug sudo perf report -i perf.data To generate heat map and visual: git clone --depth 1 https://github.com/brendangregg/FlameGraph.git FlameGraph/stackcollapse-perf.pl out.perf > out.folded FlameGraph/flamegraph.pl out.folded > out.svg sudo perf script > out.perf # then upload out.perf to https://www.speedscope.app/ to visual","title":"Developer manual"},{"location":"documentation/developer_manual/#_1","text":"","title":""},{"location":"documentation/developer_manual/#code-design","text":"","title":"Code design"},{"location":"documentation/developer_manual/#general-framework","text":"The program currently contains 7 basic moduli: dem: ingradients of DEM, including DEM solver, contact solver, contact models, and etc. domain: defines the computational domain input: used to interpret the input file. It is planned to adopt the json format as the data exchange format. Each json object corresponds to a command, and the simulation is constructed or modified through the execution of the command. The commands in plan definition 6: create, get, set, fix, unfix, run. create: create objects such as shape, particle, wall, contact model, modifier, etc. get: get object properties set: set object properties fix: Bind the defined modifier to simulation to activate. unfix: Unbind the defined evalua to make it invalid. run: start discrete element calculation modifier: defines some personalized calculations of the discrete element model, such as adding external forces, exporting data, etc. Because these personalized calculations are not required for every calculation model, they can be added to the model freely through this subscription method. Generally, the modifier is defined first, and then attached to a simulation and activated. When the discrete element is calculated to a certain node, the subscribed modifier will be called uniformly. Currently, two modifiers are defined: pre_modifier and post_modifier. pre_modifier is called at the beginning of each calculation cycle, and post_modifier is called at the end of each calculation cycle. mpi: data interaction between different parallel computing cores scene: contains particle, wall, contact model, modifier, etc. shape: defines the shape tmplates, including sphere, ellipsoid, cylinder, spherical harmonics, polyhedron, level set, and etc. utils: other tool functions Other moduli (as of Dec. 26, 2021): mlpack: wrapper of mlpack for machine learning exploration peridigm: wrapper of peridigm for particle breakage analysis pybind: for python interfaces","title":"General framework"},{"location":"documentation/developer_manual/#basic-elements","text":"Particles: Particles have variables or attributes such as shape, position, speed, and force The movement of particles obeys Newton's law of motion The particles are in contact with each other to generate contact force, which is calculated according to the corresponding contact model Wall or boundary: The boundary has variables or attributes such as shape, position, and force The boundary is generally assumed to be massless, so there is no need to calculate - Newtonian motion, just update its position according to the preset motion law Contact: particle-to-particle, or particle-to-boundary contact with contact geometric characteristics, contact force and other attributes The contact model describes the relationship between contact force and contact geometric characteristics","title":"Basic elements"},{"location":"documentation/developer_manual/#calculation-procedures","text":"The basic calculation process of discrete element (DEMSolver calculation process): Traverse all the \"particles\" in this calculation domain, and clear the force and torque to zero. Perform pre_modifier, such as gravity. Traverse all the \"particles\" in this computational domain to determine whether its contours touch other computational domains: if so, use MPI to transfer its data to the computational domain, and create a new particle in the target computational domain based on the particle data, as The particle is a proxy in the target computing domain, and the proxy particle can come into contact with other particles. The particles in this computing domain are called \"particle agents to be sent\", and the particles in the target computing domain are called \"received particle agents\". Receive the \"particle agent\" data and create an instance of the particle agent: If this calculation domain already contains the id of the particle agent, find the particle pointer through particlem_map, and update the particle instance with the received particle agent data; If the id of the particle agent does not exist, create a new \"particle_ghost\" instance, and update the particle instance with the received particle agent data; Traverse the \"granular agent to be sent\" and send its corresponding \"contact data\" to the target computing domain. Receive contact data and create contact instances: Determine the pointer of the particle according to the particle id, and determine the pointer of the contact model according to the contact model id Determine whether the contact exists through the contact_pp_list of the particle If it exists, update the contact instance from the received contact data. If it does not exist, establish a contact first, and use the received particle agent data to update the particle instance, Traverse all contacts and set their updated to false. Divide the computational domain into grids, traverse all the \"particles\" and \"received particle agents\" in the computational domain, and classify them into each grid. The classification criteria are: If the circumscribed cube of the particle or particle agent contacts a certain grid, then the particle or particle agent is added to the grid. Traverse all grids: Traverse the particles and particle agents in this grid to determine whether they are in contact. If touched: Determine whether it was in contact at the previous time step If yes, find the contact instance, update its contact geometric features and contact force, and set the updated of the contact to true If not, create a new contact instance, initialize the contact geometric features and calculate the contact force, and set the updated of the contact to true Apply contact force to particles and boundaries Traverse the \"received particle agent\": Traverse the contact of the particle agent, if the updated state of the contact is true, use MPI to send the contact data back to the original computing domain Receive contacts returned from other computing domains and reconstruct contact instances If the contact already exists, use the returned data to update the original contact If the contact does not exist, create a new contact and rebuild the particle pointer in the contact If the particle exists in the computational domain, the particle pointer is found through particle_map and particle id. If the particle does not exist in the computational domain, create a new \"particle illusion\" and set the \"particle illusion\" pointer to the contact. Apply contact force to particles Traverse all contacts If its updated status is false, delete the contact; Traverse all particles - Update its speed, position and other attributes according to Newton's law of motion Add the partial_proxy_list to the particle_ghost_list and clear the partial_proxy_list According to the updated particle position, traverse each particle to determine whether it exceeds the calculation domain: If so, send its data to the new computational domain of the particle, and move the particle to particle_ghost_list. Receive the \"particle\" data and create an instance of the particle: If this calculation domain already contains the id of the particle, find the particle pointer through particlem_map, and update the particle instance with the received particle data; If the id of the particle does not exist, create a new particle instance and update the particle instance with the received particle data; Traverse particle_ghost_list If it is not in contact with any particles or boundaries, delete the \"particle phantom\" Perform post_modifier, such as data output and other functions.","title":"Calculation procedures"},{"location":"documentation/developer_manual/#coding-style","text":"We generally follow Google C++ Style Guide .","title":"Coding style"},{"location":"documentation/developer_manual/#naming","text":"Filenames: lowercase words connected by underscores, e.g. particle.hpp , contact_pp.cpp . Variable names: lowercase words connected by underscores, e.g. dir_n . Class and struct names: words with first letters capitalized, e.g. DataDumper . Word following abbreviations shoudl be capitalized accordingly, e.g., GJKsolver, DEMgjk, GJKdemGJK, etc. Macros: should be capital, such as PI .","title":"Naming"},{"location":"documentation/developer_manual/#comment","text":"Comment is not a requisite, but please add it if an attribute or method is not self-explainary or is ambigious. We use doxygen to generate the code documentation. We suggest the following comment format. Block documentation (e.g., for class description): /** descriptions */ Line documentation: /// descriptions Other commands if approperiate: @warning {warning message}, @todo {things to be done}, @bug , @brief, @var\u3001@enum\u3001@struct\u3001@class\u3001","title":"Comment"},{"location":"documentation/developer_manual/#formatting","text":"Use clang-format .","title":"Formatting"},{"location":"documentation/developer_manual/#programing-rules","text":"Use auto for local variables when appropriate. Mark const when appropriate. Reference vs. pointer: If a variable will not be altered after calling the function, use reference with const mark, e.g., const double &[variable] . If a variable will be altered, use pointer. For int or double, as well as lists of int or double, mark with const (e.g., double *const [variable] ) to aboid mistakenly modifying the pointer. If a variable will not be altered but its value will be passed and stored the calling instance, use pointer. Following the previous item, if you are going to modify a variable, please declare it or passing it as an argument with with & . Prefer use c++ std library rather than c library, e.g., use <cmath> rather than <math.h> . Avoid using smart pointers, such as std::unique_ptr , std::shared_ptr . Never ever use \"using\" (e.g., using namespace std ) in headers .","title":"Programing rules"},{"location":"documentation/developer_manual/#performance-evaluation","text":"","title":"Performance evaluation"},{"location":"documentation/developer_manual/#procedures","text":"Tool: linux perf To probe the performance\uff1a sudo perf stat build/bin/tmp_debug Example performance counter stats: 12,639.97 msec task-clock # 0.983 CPUs utilized 1,284 context-switches # 0.102 K/sec 42 cpu-migrations # 0.003 K/sec 13,356 page-faults # 0.001 M/sec 26,566,855,696 cycles # 2.102 GHz 56,713,820,846 instructions # 2.13 insn per cycle 10,275,875,523 branches # 812.967 M/sec 31,362,265 branch-misses # 0.31% of all branches 12.857522834 seconds time elapsed 11.472000000 seconds user 1.120000000 seconds sys To sample CPU usage: sudo perf record -e task-clock -g build/bin/tmp_debug sudo perf report -i perf.data To generate heat map and visual: git clone --depth 1 https://github.com/brendangregg/FlameGraph.git FlameGraph/stackcollapse-perf.pl out.perf > out.folded FlameGraph/flamegraph.pl out.folded > out.svg sudo perf script > out.perf # then upload out.perf to https://www.speedscope.app/ to visual","title":"Procedures"},{"location":"documentation/discrete_to_continuum/","text":"DEM wiki \u250a Previous [This page is prepared in Chinese, and will be part of a book aiming at beginners of DEM.] \u5e94\u529b (Stress) \u57fa\u4e8e\u8fde\u7eed\u6027\u4ecb\u8d28\u7406\u8bba\uff0c\u6750\u6599\u7684\u52a8\u91cf\u5b88\u6052\u65b9\u7a0b\u53ef\u8868\u793a\u4e3a\uff08\u5ffd\u7565\u4f53\u529b\u53ca\u52a0\u901f\u5ea6\u9879\uff09 \\begin{align} \\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} \\end{align} \\begin{align} \\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} \\end{align} \u91c7\u7528\u7231\u56e0\u65af\u5766\u6c42\u548c\u7ea6\u5b9a\uff0c\u4e0a\u5f0f\u53ef\u5199\u4f5c \\begin{align} \\nabla_i \\sigma_{ij} = 0_j \\end{align} \\begin{align} \\nabla_i \\sigma_{ij} = 0_j \\end{align} \u5229\u7528\u52a8\u91cf\u5b88\u6052\u65b9\u7a0b\u53ef\u5f97\u7b49\u5f0f \\begin{align} \\nabla_i (\\sigma_{ij} x_k) = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\nabla_i x_k = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\delta_{ik} = \\sigma_{jk} \\end{align} \\begin{align} \\nabla_i (\\sigma_{ij} x_k) = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\nabla_i x_k = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\delta_{ik} = \\sigma_{jk} \\end{align} \u9488\u5bf9\u67d0\u4e2a\u9897\u7c92 p p \uff0c\u5176\u5185\u90e8\u5e94\u529b\u7684\u79ef\u5206\u53ef\u8ba1\u7b97\u4e3a \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\int \\nabla_i (\\sigma_{ij} x_k) ~\\text{d} \\Omega = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int f_j x_k ~\\text{d} \\Gamma = \\sum^c f_j x_k \\end{align} \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\int \\nabla_i (\\sigma_{ij} x_k) ~\\text{d} \\Omega = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int f_j x_k ~\\text{d} \\Gamma = \\sum^c f_j x_k \\end{align} \u5176\u4e2d\uff0c c c \u8868\u793a\u8be5\u9897\u7c92\u7684\u6240\u6709\u63a5\u89e6\u3001 f_j f_j \u8868\u793a\u63a5\u89e6\u529b\u3001 x_k x_k \u8868\u793a\u63a5\u89e6\u4f4d\u7f6e\u3002\u8fdb\u800c\uff0c\u5229\u7528\u9897\u7c92\u5728\u63a5\u89e6\u529b\u4f5c\u7528\u4e0b\u7684\u9759\u529b\u5e73\u8861\u516c\u5f0f \\begin{align} \\sum^c f_j x_k^p = (\\sum^c f_j) x_k^p = 0 \\end{align} \\begin{align} \\sum^c f_j x_k^p = (\\sum^c f_j) x_k^p = 0 \\end{align} \u53ef\u5f97 \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c f_j x_k = \\sum^c f_j (x_k - x_k^p) = \\sum^c f_j b_k \\end{align} \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c f_j x_k = \\sum^c f_j (x_k - x_k^p) = \\sum^c f_j b_k \\end{align} \u5176\u4e2d\uff0c x_k^p x_k^p \u4e3a\u9897\u7c92\u8d28\u5fc3\u3001 b_k b_k \u4e3a\u7531\u63a5\u89e6\u70b9\u6307\u5411\u9897\u7c92\u8d28\u5fc3\u7684\u5411\u91cf\uff08branch vector\uff09\u3002 \u9488\u5bf9\u4ee3\u8868\u5355\u5143\u4f53\uff0c\u5176\u57df\u5185\u7684\u5e73\u5747\u5e94\u529b\u53ef\u7531\u5176\u5185\u90e8\u6240\u6709\u9897\u7c92\u5185\u90e8\u7684\u5e94\u529b\u79ef\u5206\uff0c\u518d\u9664\u4e8e\u4ee3\u8868\u5355\u5143\u4f53\u4f53\u79ef\u5f97\u5230\uff0c\u8868\u8fbe\u4e3a \\begin{align} \\bar{\\sigma}_{jk} = \\frac{1}{V} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c (f_j b_k^p - f_j b_k^q) = \\sum^c f_j d_k \\end{align} \\begin{align} \\bar{\\sigma}_{jk} = \\frac{1}{V} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c (f_j b_k^p - f_j b_k^q) = \\sum^c f_j d_k \\end{align} \u5176\u4e2d\uff0c c c \u4e3a\u4ee3\u8868\u5355\u5143\u4f53\u5185\u7684\u6240\u6709\u63a5\u89e6\u3001 d_k d_k \u8868\u793a\u9897\u7c92\u8d28\u5fc3\u76f8\u5bf9\u4f4d\u7f6e\u77e2\u91cf\u3002 \u5e94\u53d8 (Strain) \u5047\u8bbe\u5355\u5143\u53d8\u5f62\u68af\u5ea6\uff08deformation gradient\uff09\u4e3a \\boldsymbol{F} \\boldsymbol{F} \uff0c\u5219\u53d8\u5f62\u540e\uff0c\u9897\u7c92 p p \uff08\u521d\u59cb\u4f4d\u7f6e \\boldsymbol{X}^p \\boldsymbol{X}^p \uff09\u4e0e \u9897\u7c92 q q \uff08\u521d\u59cb\u4f4d\u7f6e (\\boldsymbol{X}^q (\\boldsymbol{X}^q \uff09\u8d28\u5fc3\u76f8\u5bf9\u4f4d\u7f6e\u77e2\u91cf \\boldsymbol{d} \\boldsymbol{d} \u53ef\u8ba1\u7b97\u4e3a \\begin{align} d_i = F_{ij} (X^p_j - X^q_j) \\end{align} \\begin{align} d_i = F_{ij} (X^p_j - X^q_j) \\end{align} \u672c\u6784\u5f20\u91cf (Constitutive tangent moduli) \\begin{align} \\text{d} f_i = k_n (\\text{d} F_{mn}) d_n n_n n_i + k_t (\\text{d} F_{mn}) d_n t_n t_i \\end{align} \\begin{align} \\text{d} f_i = k_n (\\text{d} F_{mn}) d_n n_n n_i + k_t (\\text{d} F_{mn}) d_n t_n t_i \\end{align} \\begin{align} C_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial F_{kl}} = \\sum^c k_n n_i d_j n_k d_l + k_t t_i d_j t_k d_l \\end{align} \\begin{align} C_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial F_{kl}} = \\sum^c k_n n_i d_j n_k d_l + k_t t_i d_j t_k d_l \\end{align} \u53c2\u8003\u6587\u732e 1 2 3 4 5 DEM wiki \u250a Previous \u53c2\u8003\u6587\u732e R. I. Borja and J. R. Wren. Micromechanics of granular media Part I: Generation of overall constitutive equation for assemblies of circular disks. Computer Methods in Applied Mechanics and Engineering , 127(1-4):13\u201336, November 1995. doi:10.1016/0045-7825(95)00846-2 . \u21a9 K. Bagi. Stress and strain in granular assemblies. Mechanics of Materials , 22(3):165\u2013177, March 1996. doi:10.1016/0167-6636(95)00044-5 . \u21a9 J. R. Wren and R. I. Borja. Micromechanics of granular media Part II: Overall tangential moduli and localization model for periodic assemblies of circular disks. Computer Methods in Applied Mechanics and Engineering , 141(3):221\u2013246, February 1997. doi:10.1016/S0045-7825(96)01110-3 . \u21a9 N. P. Kruyt and L. Rothenburg. Statistical theories for the elastic moduli of two-dimensional assemblies of granular materials. International Journal of Engineering Science , 36(10):1127\u20131142, August 1998. doi:10.1016/S0020-7225(98)00003-2 . \u21a9 S. Luding. Micro\u2013macro transition for anisotropic, frictional granular packings. International Journal of Solids and Structures , 41(21):5821\u20135836, October 2004. doi:10.1016/j.ijsolstr.2004.05.048 . \u21a9","title":"Discrete to continuum"},{"location":"documentation/discrete_to_continuum/#_1","text":"DEM wiki \u250a Previous [This page is prepared in Chinese, and will be part of a book aiming at beginners of DEM.]","title":""},{"location":"documentation/discrete_to_continuum/#stress","text":"\u57fa\u4e8e\u8fde\u7eed\u6027\u4ecb\u8d28\u7406\u8bba\uff0c\u6750\u6599\u7684\u52a8\u91cf\u5b88\u6052\u65b9\u7a0b\u53ef\u8868\u793a\u4e3a\uff08\u5ffd\u7565\u4f53\u529b\u53ca\u52a0\u901f\u5ea6\u9879\uff09 \\begin{align} \\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} \\end{align} \\begin{align} \\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} \\end{align} \u91c7\u7528\u7231\u56e0\u65af\u5766\u6c42\u548c\u7ea6\u5b9a\uff0c\u4e0a\u5f0f\u53ef\u5199\u4f5c \\begin{align} \\nabla_i \\sigma_{ij} = 0_j \\end{align} \\begin{align} \\nabla_i \\sigma_{ij} = 0_j \\end{align} \u5229\u7528\u52a8\u91cf\u5b88\u6052\u65b9\u7a0b\u53ef\u5f97\u7b49\u5f0f \\begin{align} \\nabla_i (\\sigma_{ij} x_k) = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\nabla_i x_k = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\delta_{ik} = \\sigma_{jk} \\end{align} \\begin{align} \\nabla_i (\\sigma_{ij} x_k) = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\nabla_i x_k = \\nabla_i \\sigma_{ij} x_k + \\sigma_{ij} \\delta_{ik} = \\sigma_{jk} \\end{align} \u9488\u5bf9\u67d0\u4e2a\u9897\u7c92 p p \uff0c\u5176\u5185\u90e8\u5e94\u529b\u7684\u79ef\u5206\u53ef\u8ba1\u7b97\u4e3a \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\int \\nabla_i (\\sigma_{ij} x_k) ~\\text{d} \\Omega = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int f_j x_k ~\\text{d} \\Gamma = \\sum^c f_j x_k \\end{align} \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\int \\nabla_i (\\sigma_{ij} x_k) ~\\text{d} \\Omega = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int n_i (\\sigma_{ij} x_k) ~\\text{d} \\Gamma = \\int f_j x_k ~\\text{d} \\Gamma = \\sum^c f_j x_k \\end{align} \u5176\u4e2d\uff0c c c \u8868\u793a\u8be5\u9897\u7c92\u7684\u6240\u6709\u63a5\u89e6\u3001 f_j f_j \u8868\u793a\u63a5\u89e6\u529b\u3001 x_k x_k \u8868\u793a\u63a5\u89e6\u4f4d\u7f6e\u3002\u8fdb\u800c\uff0c\u5229\u7528\u9897\u7c92\u5728\u63a5\u89e6\u529b\u4f5c\u7528\u4e0b\u7684\u9759\u529b\u5e73\u8861\u516c\u5f0f \\begin{align} \\sum^c f_j x_k^p = (\\sum^c f_j) x_k^p = 0 \\end{align} \\begin{align} \\sum^c f_j x_k^p = (\\sum^c f_j) x_k^p = 0 \\end{align} \u53ef\u5f97 \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c f_j x_k = \\sum^c f_j (x_k - x_k^p) = \\sum^c f_j b_k \\end{align} \\begin{align} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c f_j x_k = \\sum^c f_j (x_k - x_k^p) = \\sum^c f_j b_k \\end{align} \u5176\u4e2d\uff0c x_k^p x_k^p \u4e3a\u9897\u7c92\u8d28\u5fc3\u3001 b_k b_k \u4e3a\u7531\u63a5\u89e6\u70b9\u6307\u5411\u9897\u7c92\u8d28\u5fc3\u7684\u5411\u91cf\uff08branch vector\uff09\u3002 \u9488\u5bf9\u4ee3\u8868\u5355\u5143\u4f53\uff0c\u5176\u57df\u5185\u7684\u5e73\u5747\u5e94\u529b\u53ef\u7531\u5176\u5185\u90e8\u6240\u6709\u9897\u7c92\u5185\u90e8\u7684\u5e94\u529b\u79ef\u5206\uff0c\u518d\u9664\u4e8e\u4ee3\u8868\u5355\u5143\u4f53\u4f53\u79ef\u5f97\u5230\uff0c\u8868\u8fbe\u4e3a \\begin{align} \\bar{\\sigma}_{jk} = \\frac{1}{V} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c (f_j b_k^p - f_j b_k^q) = \\sum^c f_j d_k \\end{align} \\begin{align} \\bar{\\sigma}_{jk} = \\frac{1}{V} \\int \\sigma_{jk} ~\\text{d} \\Omega = \\sum^c (f_j b_k^p - f_j b_k^q) = \\sum^c f_j d_k \\end{align} \u5176\u4e2d\uff0c c c \u4e3a\u4ee3\u8868\u5355\u5143\u4f53\u5185\u7684\u6240\u6709\u63a5\u89e6\u3001 d_k d_k \u8868\u793a\u9897\u7c92\u8d28\u5fc3\u76f8\u5bf9\u4f4d\u7f6e\u77e2\u91cf\u3002","title":"\u5e94\u529b (Stress)"},{"location":"documentation/discrete_to_continuum/#strain","text":"\u5047\u8bbe\u5355\u5143\u53d8\u5f62\u68af\u5ea6\uff08deformation gradient\uff09\u4e3a \\boldsymbol{F} \\boldsymbol{F} \uff0c\u5219\u53d8\u5f62\u540e\uff0c\u9897\u7c92 p p \uff08\u521d\u59cb\u4f4d\u7f6e \\boldsymbol{X}^p \\boldsymbol{X}^p \uff09\u4e0e \u9897\u7c92 q q \uff08\u521d\u59cb\u4f4d\u7f6e (\\boldsymbol{X}^q (\\boldsymbol{X}^q \uff09\u8d28\u5fc3\u76f8\u5bf9\u4f4d\u7f6e\u77e2\u91cf \\boldsymbol{d} \\boldsymbol{d} \u53ef\u8ba1\u7b97\u4e3a \\begin{align} d_i = F_{ij} (X^p_j - X^q_j) \\end{align} \\begin{align} d_i = F_{ij} (X^p_j - X^q_j) \\end{align}","title":"\u5e94\u53d8 (Strain)"},{"location":"documentation/discrete_to_continuum/#constitutive-tangent-moduli","text":"\\begin{align} \\text{d} f_i = k_n (\\text{d} F_{mn}) d_n n_n n_i + k_t (\\text{d} F_{mn}) d_n t_n t_i \\end{align} \\begin{align} \\text{d} f_i = k_n (\\text{d} F_{mn}) d_n n_n n_i + k_t (\\text{d} F_{mn}) d_n t_n t_i \\end{align} \\begin{align} C_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial F_{kl}} = \\sum^c k_n n_i d_j n_k d_l + k_t t_i d_j t_k d_l \\end{align} \\begin{align} C_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial F_{kl}} = \\sum^c k_n n_i d_j n_k d_l + k_t t_i d_j t_k d_l \\end{align} \u53c2\u8003\u6587\u732e 1 2 3 4 5 DEM wiki \u250a Previous","title":"\u672c\u6784\u5f20\u91cf (Constitutive tangent moduli)"},{"location":"documentation/discrete_to_continuum/#_2","text":"R. I. Borja and J. R. Wren. Micromechanics of granular media Part I: Generation of overall constitutive equation for assemblies of circular disks. Computer Methods in Applied Mechanics and Engineering , 127(1-4):13\u201336, November 1995. doi:10.1016/0045-7825(95)00846-2 . \u21a9 K. Bagi. Stress and strain in granular assemblies. Mechanics of Materials , 22(3):165\u2013177, March 1996. doi:10.1016/0167-6636(95)00044-5 . \u21a9 J. R. Wren and R. I. Borja. Micromechanics of granular media Part II: Overall tangential moduli and localization model for periodic assemblies of circular disks. Computer Methods in Applied Mechanics and Engineering , 141(3):221\u2013246, February 1997. doi:10.1016/S0045-7825(96)01110-3 . \u21a9 N. P. Kruyt and L. Rothenburg. Statistical theories for the elastic moduli of two-dimensional assemblies of granular materials. International Journal of Engineering Science , 36(10):1127\u20131142, August 1998. doi:10.1016/S0020-7225(98)00003-2 . \u21a9 S. Luding. Micro\u2013macro transition for anisotropic, frictional granular packings. International Journal of Solids and Structures , 41(21):5821\u20135836, October 2004. doi:10.1016/j.ijsolstr.2004.05.048 . \u21a9","title":"\u53c2\u8003\u6587\u732e"},{"location":"documentation/installation/","text":"User manual \u250a Next Installation Prerequisites The compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt install build-essential sudo apt-get install -y autoconf-archive automake cmake texinfo sudo apt-get install openmpi-bin libopenmpi-dev libboost-all-dev Compile and build make sync_submodule make If some third-party libraries have not been or cannot be downloaded successfully, you can delete them and do a git checkout contrib and make sync_submodule again. Test the installation ./scripts/run_tests.sh Related to installation Installation on Apple M1 (As of Dec. 20 2021) OpenMP seems not compitible with Apple M1. To enforce an OpenMP installation, set USE_INTERNAL_OPENMP in netdem CMakeLists.txt to OFF , and use brew install libomp to install a pre-built copy of OpenMP. Add M1 support to fast_winding_number functional in igl via SIMDE (please see the discussion in https://github.com/sideeffects/WindingNumber/pull/3/files ): Install simde using brew install simde . Add -flax-vector-conversions to the gcc complier flag in netdem CMakeLists.txt . Add the following lines to the FastWindingNumberForSoups in igl and comment out the #include <emmintrin.h> line. #define SIMDE_ENABLE_NATIVE_ALIASES #include <simde/x86/sse.h> #include <simde/x86/sse4.1.h> // Recent GCC define the macro in x86intrin.h #ifndef _MM_MK_INSERTPS_NDX #define _MM_MK_INSERTPS_NDX(srcField, dstField, zeroMask) (((srcField)<<6) | ((dstField)<<4) | (zeroMask)) #endif Build netdem following the original procedures. Dependencies git , gcc , cmake : for code developing, configuring and compiling open mpi : for parallel computing json : for input data interchange cork : for mesh boolean operation gmp igl : another option of mesh boolean operation (robust but much slower than cork) cgal (requires boost , gmp , mpfr ), openmp , eigen googletest : for tests mlpack : for machine learning libraries armadillo (requires lapack , arpack , openblas ), ensmallen , cereal , boost , stb pybind : for python interface Using dependencies already in the system would save the time required by the compilation of the whole project. Some dependencies (e.g., mlpack) would take fairly long time to compile. One can check out the log files in contrib/[package]/ep/src/[package]-stamp/ for the compiling, building and installing progresses of the dependencies. Some packages (e.g., boost and mpi ) could take forever to compile. It is recommended that you install pre-build boost and mpi using tools such as brew install in mac os, or apt-get install in ubantu. User manual \u250a Next","title":"Installation"},{"location":"documentation/installation/#_1","text":"User manual \u250a Next","title":""},{"location":"documentation/installation/#installation","text":"","title":"Installation"},{"location":"documentation/installation/#prerequisites","text":"The compilation requires gcc , autoconf , automake , cmake , mpi , boost , which can be obtained using # For MacOS: use brew install, such as brew install gcc autoconf automake cmake openmpi boost # For Ubuntu: use apt-get install, such as sudo apt install build-essential sudo apt-get install -y autoconf-archive automake cmake texinfo sudo apt-get install openmpi-bin libopenmpi-dev libboost-all-dev","title":"Prerequisites"},{"location":"documentation/installation/#compile-and-build","text":"make sync_submodule make If some third-party libraries have not been or cannot be downloaded successfully, you can delete them and do a git checkout contrib and make sync_submodule again.","title":"Compile and build"},{"location":"documentation/installation/#test-the-installation","text":"./scripts/run_tests.sh","title":"Test the installation"},{"location":"documentation/installation/#related-to-installation","text":"","title":"Related to installation"},{"location":"documentation/installation/#installation-on-apple-m1","text":"(As of Dec. 20 2021) OpenMP seems not compitible with Apple M1. To enforce an OpenMP installation, set USE_INTERNAL_OPENMP in netdem CMakeLists.txt to OFF , and use brew install libomp to install a pre-built copy of OpenMP. Add M1 support to fast_winding_number functional in igl via SIMDE (please see the discussion in https://github.com/sideeffects/WindingNumber/pull/3/files ): Install simde using brew install simde . Add -flax-vector-conversions to the gcc complier flag in netdem CMakeLists.txt . Add the following lines to the FastWindingNumberForSoups in igl and comment out the #include <emmintrin.h> line. #define SIMDE_ENABLE_NATIVE_ALIASES #include <simde/x86/sse.h> #include <simde/x86/sse4.1.h> // Recent GCC define the macro in x86intrin.h #ifndef _MM_MK_INSERTPS_NDX #define _MM_MK_INSERTPS_NDX(srcField, dstField, zeroMask) (((srcField)<<6) | ((dstField)<<4) | (zeroMask)) #endif Build netdem following the original procedures.","title":"Installation on Apple M1"},{"location":"documentation/installation/#dependencies","text":"git , gcc , cmake : for code developing, configuring and compiling open mpi : for parallel computing json : for input data interchange cork : for mesh boolean operation gmp igl : another option of mesh boolean operation (robust but much slower than cork) cgal (requires boost , gmp , mpfr ), openmp , eigen googletest : for tests mlpack : for machine learning libraries armadillo (requires lapack , arpack , openblas ), ensmallen , cereal , boost , stb pybind : for python interface Using dependencies already in the system would save the time required by the compilation of the whole project. Some dependencies (e.g., mlpack) would take fairly long time to compile. One can check out the log files in contrib/[package]/ep/src/[package]-stamp/ for the compiling, building and installing progresses of the dependencies. Some packages (e.g., boost and mpi ) could take forever to compile. It is recommended that you install pre-build boost and mpi using tools such as brew install in mac os, or apt-get install in ubantu. User manual \u250a Next","title":"Dependencies"},{"location":"documentation/paraview_rendering/","text":"User manual \u250a Previous \u250a Next Client/Server Establish tunneling using: ssh -L 11111:localhost:11111 -p [port] [user]@[remote-ip] Start pvserver on remote pvserver Open paraview at local, add and connect to server with type Client/Server , host localhost and port 11111 User manual \u250a Previous \u250a Next","title":"Paraview rendering"},{"location":"documentation/paraview_rendering/#_1","text":"User manual \u250a Previous \u250a Next","title":""},{"location":"documentation/paraview_rendering/#clientserver","text":"Establish tunneling using: ssh -L 11111:localhost:11111 -p [port] [user]@[remote-ip] Start pvserver on remote pvserver Open paraview at local, add and connect to server with type Client/Server , host localhost and port 11111 User manual \u250a Previous \u250a Next","title":"Client/Server"},{"location":"documentation/particle_models/","text":"DEM wiki \u250a Previous \u250a Next [This page is prepared in Chinese, and will be part of a book aiming at beginners of DEM.] \u805a\u5408\u8d85\u692d\u7403\uff08Poly-super-ellipsoid\uff09 \u8868\u8fbe\u5f0f\uff08Formulation\uff09 \u8d85\u692d\u7403\u7684\u8868\u9762\u53ef\u8868\u793a\u4e3a 1 \\begin{align} f(x, y, z) = \\left( \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_{1}}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_{1}}} \\right)^{\\frac{\\epsilon_{1}}{\\epsilon_{2}}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_{2}}} - 1 = 0 \\label{eq:poly_super_ellipsoid} \\end{align} \\begin{align} f(x, y, z) = \\left( \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_{1}}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_{1}}} \\right)^{\\frac{\\epsilon_{1}}{\\epsilon_{2}}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_{2}}} - 1 = 0 \\label{eq:poly_super_ellipsoid} \\end{align} \u5176\u4e2d\uff0c r_{x} r_{x} \u3001 r_{y} r_{y} \u548c r_{z} r_{z} \u5206\u522b\u4e3a\u8d85\u692d\u7403\u5728 x x \u3001 y y \u548c z z \u65b9\u5411\u7684\u534a\u8f74\u957f\uff08semi-pricinpal axis length\uff09\uff1b \\epsilon_{1} \\epsilon_{1} \u548c \\epsilon_{2} \\epsilon_{2} \u662f\u8868\u5f81\u8d85\u692d\u7403\u7403\u5ea6\u6216\u5757\u5ea6\uff08blockness\uff09\u7684\u4e24\u4e2a\u5f62\u72b6\u53c2\u6570\u3002\u5f53\u53c2\u6570 \\epsilon_{1} \\epsilon_{1} \u548c \\epsilon_{2} \\epsilon_{2} \u5728 (0, 2) \u533a\u95f4\u5185\u65f6\uff0c\u8d85\u692d\u7403\u4e3a\u51f8\u578b\uff1b\u5426\u5219\u4e3a\u975e\u51f8\u578b\u3002\u5bf9\u4e8e\u805a\u5408\u8d85\u692d\u7403\uff0c\u534a\u8f74\u957f\u53c2\u6570 r_{x} r_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 r_{x^-} r_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 r_{x^+} r_{x^+} \uff1b r_{y} r_{y} \u548c r_{z} r_{z} \u4ea6\u7136\u3002 \u652f\u6491\u6620\u5c04\uff08Support mapping\uff09 \u53c2\u8003\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u548c\u7403\u5750\u6807\u7cfb\u4e4b\u95f4\u7684\u5750\u6807\u53d8\u6362\uff0c\u8d85\u692d\u7403\u7684\u7403\u5750\u6807\u53c2\u6570\u5316\u53ef\u8868\u793a\u4e3a\uff08\u6ce8\uff0c\u4ee5\u7b2c\u4e00\u8c61\u9650\u4e3a\u4f8b\u3001\u6b63\u8d1f\u53f7\u5df2\u7701\u7565\uff09 \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_2} \\end{align} \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_2} \\end{align} \u5176\u4e2d\uff0c \\theta \\theta \u548c \\varphi \\varphi \u5206\u522b\u4e3a\u6781\u89d2\uff08polar angle\uff09\u4e0e\u65b9\u4f4d\u89d2\uff08azimuth angle\uff09\u3002\u628a x x \u3001 y y \u548c z z \u5206\u522b\u5bf9 \\theta \\theta \u548c \\varphi \\varphi \u6c42\u504f\u5bfc\uff0c\u53ef\u5f97\u8d85\u692d\u7403\u8868\u9762\u7684\u65b9\u5411\u5411\u91cf\u4e3a \\begin{align} x_\\theta &= \\epsilon_2 r_x (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_1} \\\\ y_\\theta &= \\epsilon_2 r_y (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_1} \\\\ z_\\theta &= \\epsilon_2 r_z (\\cos\\theta)^{\\epsilon_2-1} (-\\sin\\theta) \\end{align} \\begin{align} x_\\theta &= \\epsilon_2 r_x (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_1} \\\\ y_\\theta &= \\epsilon_2 r_y (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_1} \\\\ z_\\theta &= \\epsilon_2 r_z (\\cos\\theta)^{\\epsilon_2-1} (-\\sin\\theta) \\end{align} \u4ee5\u53ca \\begin{align} x_\\varphi &= \\epsilon_1 r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_1 r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \\begin{align} x_\\varphi &= \\epsilon_1 r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_1 r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \u6c42\u4e24\u4e2a\u65b9\u5411\u5411\u91cf\u7684\u53c9\u4e58\u3001\u5e76\u5316\u7b80\uff0c\u53ef\u5f97\u5230\u8d85\u692d\u7403\u8868\u9762\u7684\u6cd5\u65b9\u5411\u4e3a\uff08\u6ce8\uff0c\u6cd5\u65b9\u5411\u5404\u5206\u91cf\u540c\u65f6\u9664\u4e8e\u4e86 \\epsilon_1 \\epsilon_2 r_x r_y r_z (\\sin\\theta)^{2\\epsilon_2-1} (\\cos\\theta)^{\\epsilon_2-1} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi)^{\\epsilon_1-1} \\epsilon_1 \\epsilon_2 r_x r_y r_z (\\sin\\theta)^{2\\epsilon_2-1} (\\cos\\theta)^{\\epsilon_2-1} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi)^{\\epsilon_1-1} \uff09 \\begin{align} n_x &= \\frac{k}{r_x} (\\sin\\theta)^{2-\\epsilon_2} (\\cos\\varphi)^{2-\\epsilon_1} \\\\ n_y &= \\frac{k}{r_y} (\\sin\\theta)^{2-\\epsilon_2} (\\sin\\varphi)^{2-\\epsilon_1} \\\\ n_z &= \\frac{k}{r_z} (\\cos\\theta)^{2-\\epsilon_2} \\end{align} \\begin{align} n_x &= \\frac{k}{r_x} (\\sin\\theta)^{2-\\epsilon_2} (\\cos\\varphi)^{2-\\epsilon_1} \\\\ n_y &= \\frac{k}{r_y} (\\sin\\theta)^{2-\\epsilon_2} (\\sin\\varphi)^{2-\\epsilon_1} \\\\ n_z &= \\frac{k}{r_z} (\\cos\\theta)^{2-\\epsilon_2} \\end{align} \u5176\u4e2d\uff0c n_x n_x \u3001 n_y n_y \u548c n_z n_z \u4e3a\u6cd5\u65b9\u5411\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5206\u91cf\uff1b k k \u4e3a\u4e00\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97( n_x n_x \u3001 n_y n_y \u548c n_z n_z )\u4e3a\u5355\u4f4d\u5411\u91cf\u3002\u82e5\u7ed9\u5b9a\u67d0\u70b9\u7684\u6cd5\u65b9\u5411\uff0c\u5219\u8be5\u70b9\u7684\u7403\u5750\u6807\u53c2\u6570 \\theta \\theta \u548c \\varphi \\varphi \u53ef\u7531\u4e0b\u5f0f\u8ba1\u7b97\uff1a \\begin{align} \\varphi &= \\text{atan2} \\left( (r_y n_y)^{\\frac{1}{2-\\epsilon_1}}, (r_x n_x)^{\\frac{1}{2-\\epsilon_1}} \\right) \\\\ \\theta &= \\text{atan2} \\left( \\left(r_x n_x / (\\cos\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\\\ \\text{or} \\quad \\theta &= \\text{atan2} \\left( \\left(r_y n_y / (\\sin\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\end{align} \\begin{align} \\varphi &= \\text{atan2} \\left( (r_y n_y)^{\\frac{1}{2-\\epsilon_1}}, (r_x n_x)^{\\frac{1}{2-\\epsilon_1}} \\right) \\\\ \\theta &= \\text{atan2} \\left( \\left(r_x n_x / (\\cos\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\\\ \\text{or} \\quad \\theta &= \\text{atan2} \\left( \\left(r_y n_y / (\\sin\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\end{align} \u6709\u5411\u8ddd\u79bb\u573a\uff08Signed distance field\uff09 \u7ed9\u5b9a\u67e5\u8be2\u8282\u70b9 P P \uff0c\u8be5\u70b9\u5728\u805a\u5408\u8d85\u692d\u7403\u8868\u9762\u7684\u6295\u5f71\u5b9a\u4e49\u4e3a \\begin{align} \\vec{x}_Q = (x_Q\u3001y_Q\u3001z_Q) = (c x_P\u3001c y_P\u3001c z_P) \\end{align} \\begin{align} \\vec{x}_Q = (x_Q\u3001y_Q\u3001z_Q) = (c x_P\u3001c y_P\u3001c z_P) \\end{align} \u5176\u4e2d\uff0c x x \u3001 y y \u548c z z \u8868\u793a\u70b9\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5750\u6807\uff1b\u4e0b\u6807 P P and Q Q \u8868\u793a\u70b9 P P \u548c Q Q \uff1b\u53c2\u6570 c c \u4e3a\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97\u70b9 Q Q \u5728\u805a\u5408\u8d85\u692d\u7403\u4e0a\uff0c\u5373\u6ee1\u8db3\u65b9\u7a0b \\eqref{eq:poly_super_ellipsoid}\u3002 \u5c06\u70b9 Q Q \u5e26\u5165\u65b9\u7a0b \\eqref{eq:poly_super_ellipsoid} \u53ef\u6c42\u5f97\u53c2\u6570 c c \uff0c\u4e3a \\begin{align} c = \\left( \\frac{1}{f(\\vec{x}_P)+1} \\right)^{\\frac{\\epsilon_2}{2}} \\end{align} \\begin{align} c = \\left( \\frac{1}{f(\\vec{x}_P)+1} \\right)^{\\frac{\\epsilon_2}{2}} \\end{align} \u6709\u5411\u8ddd\u79bb\u573a\u53ef\u5b9a\u4e49\u4e3a\u70b9 P P \u548c Q Q \u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u4e3a \\begin{align} \\Phi(\\vec{x}_P) = (c-1)||\\vec{x}_P|| \\end{align} \\begin{align} \\Phi(\\vec{x}_P) = (c-1)||\\vec{x}_P|| \\end{align} \u5176\u4e2d\uff0c ||\\vec{x}_P|| ||\\vec{x}_P|| \u8868\u793a\u5411\u91cf \\vec{x}_P \\vec{x}_P \u7684\u6b27\u62c9\u957f\u5ea6\uff0c\u5373\u4e8c\u9636\u8303\u6570\u3002 \u805a\u5408\u8d85\u4e8c\u6b21\u66f2\u9762\uff08Poly-super-quadrics) \u8868\u8fbe\u5f0f\uff08Formulation\uff09 \u8d85\u4e8c\u6b21\u66f2\u9762\u53ef\u8868\u793a\u4e3a \\begin{align} f(x, y, z) = \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_x}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_y}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_z}} - 1 = 0 \\label{eq:poly_super_quadrics} \\end{align} \\begin{align} f(x, y, z) = \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_x}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_y}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_z}} - 1 = 0 \\label{eq:poly_super_quadrics} \\end{align} \u5176\u4e2d\uff0c r_{x} r_{x} \u3001 r_{y} r_{y} \u548c r_{z} r_{z} \u5206\u522b\u4e3a\u8d85\u4e8c\u6b21\u66f2\u9762\u5728 x x \u3001 y y \u548c z z \u65b9\u5411\u7684\u534a\u8f74\u957f\uff08semi-pricinpal axis length\uff09\uff1b \\epsilon_{x} \\epsilon_{x} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u662f\u8868\u5f81\u8d85\u4e8c\u6b21\u66f2\u9762\u7403\u5ea6\u6216\u5757\u5ea6\uff08blockness\uff09\u7684\u4e09\u4e2a\u5f62\u72b6\u53c2\u6570\u3002\u5f53\u53c2\u6570 \\epsilon_{x} \\epsilon_{x} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u5728 (0, 2) \u533a\u95f4\u5185\u65f6\uff0c\u8d85\u4e8c\u6b21\u66f2\u9762\u4e3a\u51f8\u578b\uff1b\u5426\u5219\u4e3a\u975e\u51f8\u578b\u3002\u5bf9\u4e8e\u805a\u5408\u8d85\u4e8c\u6b21\u66f2\u9762\uff0c\u534a\u8f74\u957f\u53c2\u6570 r_{x} r_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 r_{x^-} r_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 r_{x^+} r_{x^+} \uff1b\u5f62\u72b6\u53c2\u6570 \\epsilon_{x} \\epsilon_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 \\epsilon_{x^-} \\epsilon_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 \\epsilon_{x^+} \\epsilon_{x^+} \uff1b r_{y} r_{y} \u3001 r_{z} r_{z} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u4ea6\u7136\u3002 \u652f\u6491\u6620\u5c04\uff08Support mapping\uff09 \u53c2\u8003\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u548c\u7403\u5750\u6807\u7cfb\u4e4b\u95f4\u7684\u5750\u6807\u53d8\u6362\uff0c\u8d85\u692d\u7403\u7684\u7403\u5750\u6807\u53c2\u6570\u5316\u53ef\u8868\u793a\u4e3a \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_z} \\end{align} \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_z} \\end{align} \u5176\u4e2d\uff0c \\theta \\theta \u548c \\varphi \\varphi \u5206\u522b\u4e3a\u6781\u89d2\uff08polar angle\uff09\u4e0e\u65b9\u4f4d\u89d2\uff08azimuth angle\uff09\u3002\u628a x x \u3001 y y \u548c z z \u5206\u522b\u5bf9 \\theta \\theta \u548c \\varphi \\varphi \u6c42\u504f\u5bfc\uff0c\u53ef\u5f97\u8d85\u692d\u7403\u8868\u9762\u7684\u65b9\u5411\u5411\u91cf\u4e3a \\begin{align} x_\\theta &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_x} \\\\ y_\\theta &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_y} \\\\ z_\\theta &= \\epsilon_z r_z (\\cos\\theta)^{\\epsilon_z-1} (-\\sin\\theta) \\end{align} \\begin{align} x_\\theta &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_x} \\\\ y_\\theta &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_y} \\\\ z_\\theta &= \\epsilon_z r_z (\\cos\\theta)^{\\epsilon_z-1} (-\\sin\\theta) \\end{align} \u4ee5\u53ca \\begin{align} x_\\varphi &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \\begin{align} x_\\varphi &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \u6c42\u4e24\u4e2a\u65b9\u5411\u5411\u91cf\u7684\u53c9\u4e58\u3001\u5e76\u5316\u7b80\uff0c\u53ef\u5f97\u5230\u8d85\u692d\u7403\u8868\u9762\u7684\u6cd5\u65b9\u5411\u4e3a\uff08\u6ce8\uff0c\u6cd5\u65b9\u5411\u5404\u5206\u91cf\u540c\u65f6\u9664\u4e8e\u4e86 \\epsilon_x \\epsilon_y \\epsilon_z r_x r_y r_z (\\sin\\theta)^{\\epsilon_x+\\epsilon_y-1} (\\cos\\theta)^{\\epsilon_z-1} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi)^{\\epsilon_x-1} \\epsilon_x \\epsilon_y \\epsilon_z r_x r_y r_z (\\sin\\theta)^{\\epsilon_x+\\epsilon_y-1} (\\cos\\theta)^{\\epsilon_z-1} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi)^{\\epsilon_x-1} \uff09 \\begin{align} n_x &= \\frac{k}{\\epsilon_x r_x} (\\sin\\theta)^{2-\\epsilon_x} (\\cos\\varphi)^{2-\\epsilon_x} \\\\ n_y &= \\frac{k}{\\epsilon_y r_y} (\\sin\\theta)^{2-\\epsilon_y} (\\sin\\varphi)^{2-\\epsilon_y} \\\\ n_z &= \\frac{k}{\\epsilon_z r_z} (\\cos\\theta)^{2-\\epsilon_z} \\end{align} \\begin{align} n_x &= \\frac{k}{\\epsilon_x r_x} (\\sin\\theta)^{2-\\epsilon_x} (\\cos\\varphi)^{2-\\epsilon_x} \\\\ n_y &= \\frac{k}{\\epsilon_y r_y} (\\sin\\theta)^{2-\\epsilon_y} (\\sin\\varphi)^{2-\\epsilon_y} \\\\ n_z &= \\frac{k}{\\epsilon_z r_z} (\\cos\\theta)^{2-\\epsilon_z} \\end{align} \u5176\u4e2d\uff0c n_x n_x \u3001 n_y n_y \u548c n_z n_z \u4e3a\u6cd5\u65b9\u5411\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5206\u91cf\uff1b k k \u4e3a\u4e00\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97( n_x n_x \u3001 n_y n_y \u548c n_z n_z )\u4e3a\u5355\u4f4d\u5411\u91cf\u3002\u82e5\u7ed9\u5b9a\u67d0\u70b9\u7684\u6cd5\u65b9\u5411\uff0c\u5219\u8be5\u70b9\u7684\u7b1b\u5361\u5c14\u5750\u6807\u53ef\u7531\u4e0b\u5f0f\u8ba1\u7b97\uff1a \\begin{align} x &= r_x \\left( \\frac{\\epsilon_x r_x n_x}{k} \\right)^{\\frac{\\epsilon_x}{2-\\epsilon_x}} \\\\ y &= r_y \\left( \\frac{\\epsilon_y r_y n_y}{k} \\right)^{\\frac{\\epsilon_y}{2-\\epsilon_y}} \\\\ z &= r_z \\left( \\frac{\\epsilon_z r_z n_z}{k} \\right)^{\\frac{\\epsilon_z}{2-\\epsilon_z}} \\\\ \\end{align} \\begin{align} x &= r_x \\left( \\frac{\\epsilon_x r_x n_x}{k} \\right)^{\\frac{\\epsilon_x}{2-\\epsilon_x}} \\\\ y &= r_y \\left( \\frac{\\epsilon_y r_y n_y}{k} \\right)^{\\frac{\\epsilon_y}{2-\\epsilon_y}} \\\\ z &= r_z \\left( \\frac{\\epsilon_z r_z n_z}{k} \\right)^{\\frac{\\epsilon_z}{2-\\epsilon_z}} \\\\ \\end{align} \u5c06\u4e0a\u5f0f\u5e26\u5165\u516c\u5f0f\\eqref{eq:poly_super_quadrics}\u53ef\u6c42\u5f97\u7cfb\u6570 k k \uff0c\u8fdb\u800c\u5f97\u5230\u8be5\u70b9\u7684\u5750\u6807 x x \u3001 y y \u548c z z \u3002 DEM wiki \u250a Previous \u250a Next \u53c2\u8003\u6587\u732e S. Zhao and J. Zhao. A poly-superellipsoid-based approach on particle morphology for DEM modeling of granular media. International Journal for Numerical and Analytical Methods in Geomechanics , 43(13):2147\u20132169, 2019. \u21a9","title":"Particle models"},{"location":"documentation/particle_models/#_1","text":"DEM wiki \u250a Previous \u250a Next [This page is prepared in Chinese, and will be part of a book aiming at beginners of DEM.]","title":""},{"location":"documentation/particle_models/#poly-super-ellipsoid","text":"","title":"\u805a\u5408\u8d85\u692d\u7403\uff08Poly-super-ellipsoid\uff09"},{"location":"documentation/particle_models/#formulation","text":"\u8d85\u692d\u7403\u7684\u8868\u9762\u53ef\u8868\u793a\u4e3a 1 \\begin{align} f(x, y, z) = \\left( \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_{1}}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_{1}}} \\right)^{\\frac{\\epsilon_{1}}{\\epsilon_{2}}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_{2}}} - 1 = 0 \\label{eq:poly_super_ellipsoid} \\end{align} \\begin{align} f(x, y, z) = \\left( \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_{1}}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_{1}}} \\right)^{\\frac{\\epsilon_{1}}{\\epsilon_{2}}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_{2}}} - 1 = 0 \\label{eq:poly_super_ellipsoid} \\end{align} \u5176\u4e2d\uff0c r_{x} r_{x} \u3001 r_{y} r_{y} \u548c r_{z} r_{z} \u5206\u522b\u4e3a\u8d85\u692d\u7403\u5728 x x \u3001 y y \u548c z z \u65b9\u5411\u7684\u534a\u8f74\u957f\uff08semi-pricinpal axis length\uff09\uff1b \\epsilon_{1} \\epsilon_{1} \u548c \\epsilon_{2} \\epsilon_{2} \u662f\u8868\u5f81\u8d85\u692d\u7403\u7403\u5ea6\u6216\u5757\u5ea6\uff08blockness\uff09\u7684\u4e24\u4e2a\u5f62\u72b6\u53c2\u6570\u3002\u5f53\u53c2\u6570 \\epsilon_{1} \\epsilon_{1} \u548c \\epsilon_{2} \\epsilon_{2} \u5728 (0, 2) \u533a\u95f4\u5185\u65f6\uff0c\u8d85\u692d\u7403\u4e3a\u51f8\u578b\uff1b\u5426\u5219\u4e3a\u975e\u51f8\u578b\u3002\u5bf9\u4e8e\u805a\u5408\u8d85\u692d\u7403\uff0c\u534a\u8f74\u957f\u53c2\u6570 r_{x} r_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 r_{x^-} r_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 r_{x^+} r_{x^+} \uff1b r_{y} r_{y} \u548c r_{z} r_{z} \u4ea6\u7136\u3002","title":"\u8868\u8fbe\u5f0f\uff08Formulation\uff09"},{"location":"documentation/particle_models/#support-mapping","text":"\u53c2\u8003\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u548c\u7403\u5750\u6807\u7cfb\u4e4b\u95f4\u7684\u5750\u6807\u53d8\u6362\uff0c\u8d85\u692d\u7403\u7684\u7403\u5750\u6807\u53c2\u6570\u5316\u53ef\u8868\u793a\u4e3a\uff08\u6ce8\uff0c\u4ee5\u7b2c\u4e00\u8c61\u9650\u4e3a\u4f8b\u3001\u6b63\u8d1f\u53f7\u5df2\u7701\u7565\uff09 \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_2} \\end{align} \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_2} \\end{align} \u5176\u4e2d\uff0c \\theta \\theta \u548c \\varphi \\varphi \u5206\u522b\u4e3a\u6781\u89d2\uff08polar angle\uff09\u4e0e\u65b9\u4f4d\u89d2\uff08azimuth angle\uff09\u3002\u628a x x \u3001 y y \u548c z z \u5206\u522b\u5bf9 \\theta \\theta \u548c \\varphi \\varphi \u6c42\u504f\u5bfc\uff0c\u53ef\u5f97\u8d85\u692d\u7403\u8868\u9762\u7684\u65b9\u5411\u5411\u91cf\u4e3a \\begin{align} x_\\theta &= \\epsilon_2 r_x (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_1} \\\\ y_\\theta &= \\epsilon_2 r_y (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_1} \\\\ z_\\theta &= \\epsilon_2 r_z (\\cos\\theta)^{\\epsilon_2-1} (-\\sin\\theta) \\end{align} \\begin{align} x_\\theta &= \\epsilon_2 r_x (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_1} \\\\ y_\\theta &= \\epsilon_2 r_y (\\sin\\theta)^{\\epsilon_2-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_1} \\\\ z_\\theta &= \\epsilon_2 r_z (\\cos\\theta)^{\\epsilon_2-1} (-\\sin\\theta) \\end{align} \u4ee5\u53ca \\begin{align} x_\\varphi &= \\epsilon_1 r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_1 r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \\begin{align} x_\\varphi &= \\epsilon_1 r_x (\\sin\\theta)^{\\epsilon_2} (\\cos\\varphi)^{\\epsilon_1-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_1 r_y (\\sin\\theta)^{\\epsilon_2} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \u6c42\u4e24\u4e2a\u65b9\u5411\u5411\u91cf\u7684\u53c9\u4e58\u3001\u5e76\u5316\u7b80\uff0c\u53ef\u5f97\u5230\u8d85\u692d\u7403\u8868\u9762\u7684\u6cd5\u65b9\u5411\u4e3a\uff08\u6ce8\uff0c\u6cd5\u65b9\u5411\u5404\u5206\u91cf\u540c\u65f6\u9664\u4e8e\u4e86 \\epsilon_1 \\epsilon_2 r_x r_y r_z (\\sin\\theta)^{2\\epsilon_2-1} (\\cos\\theta)^{\\epsilon_2-1} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi)^{\\epsilon_1-1} \\epsilon_1 \\epsilon_2 r_x r_y r_z (\\sin\\theta)^{2\\epsilon_2-1} (\\cos\\theta)^{\\epsilon_2-1} (\\sin\\varphi)^{\\epsilon_1-1} (\\cos\\varphi)^{\\epsilon_1-1} \uff09 \\begin{align} n_x &= \\frac{k}{r_x} (\\sin\\theta)^{2-\\epsilon_2} (\\cos\\varphi)^{2-\\epsilon_1} \\\\ n_y &= \\frac{k}{r_y} (\\sin\\theta)^{2-\\epsilon_2} (\\sin\\varphi)^{2-\\epsilon_1} \\\\ n_z &= \\frac{k}{r_z} (\\cos\\theta)^{2-\\epsilon_2} \\end{align} \\begin{align} n_x &= \\frac{k}{r_x} (\\sin\\theta)^{2-\\epsilon_2} (\\cos\\varphi)^{2-\\epsilon_1} \\\\ n_y &= \\frac{k}{r_y} (\\sin\\theta)^{2-\\epsilon_2} (\\sin\\varphi)^{2-\\epsilon_1} \\\\ n_z &= \\frac{k}{r_z} (\\cos\\theta)^{2-\\epsilon_2} \\end{align} \u5176\u4e2d\uff0c n_x n_x \u3001 n_y n_y \u548c n_z n_z \u4e3a\u6cd5\u65b9\u5411\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5206\u91cf\uff1b k k \u4e3a\u4e00\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97( n_x n_x \u3001 n_y n_y \u548c n_z n_z )\u4e3a\u5355\u4f4d\u5411\u91cf\u3002\u82e5\u7ed9\u5b9a\u67d0\u70b9\u7684\u6cd5\u65b9\u5411\uff0c\u5219\u8be5\u70b9\u7684\u7403\u5750\u6807\u53c2\u6570 \\theta \\theta \u548c \\varphi \\varphi \u53ef\u7531\u4e0b\u5f0f\u8ba1\u7b97\uff1a \\begin{align} \\varphi &= \\text{atan2} \\left( (r_y n_y)^{\\frac{1}{2-\\epsilon_1}}, (r_x n_x)^{\\frac{1}{2-\\epsilon_1}} \\right) \\\\ \\theta &= \\text{atan2} \\left( \\left(r_x n_x / (\\cos\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\\\ \\text{or} \\quad \\theta &= \\text{atan2} \\left( \\left(r_y n_y / (\\sin\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\end{align} \\begin{align} \\varphi &= \\text{atan2} \\left( (r_y n_y)^{\\frac{1}{2-\\epsilon_1}}, (r_x n_x)^{\\frac{1}{2-\\epsilon_1}} \\right) \\\\ \\theta &= \\text{atan2} \\left( \\left(r_x n_x / (\\cos\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\\\ \\text{or} \\quad \\theta &= \\text{atan2} \\left( \\left(r_y n_y / (\\sin\\varphi)^{2-\\epsilon_1} \\right)^{\\frac{1}{2-\\epsilon_2}}, (r_z n_z)^{\\frac{1}{2-\\epsilon_2}} \\right) \\end{align}","title":"\u652f\u6491\u6620\u5c04\uff08Support mapping\uff09"},{"location":"documentation/particle_models/#signed-distance-field","text":"\u7ed9\u5b9a\u67e5\u8be2\u8282\u70b9 P P \uff0c\u8be5\u70b9\u5728\u805a\u5408\u8d85\u692d\u7403\u8868\u9762\u7684\u6295\u5f71\u5b9a\u4e49\u4e3a \\begin{align} \\vec{x}_Q = (x_Q\u3001y_Q\u3001z_Q) = (c x_P\u3001c y_P\u3001c z_P) \\end{align} \\begin{align} \\vec{x}_Q = (x_Q\u3001y_Q\u3001z_Q) = (c x_P\u3001c y_P\u3001c z_P) \\end{align} \u5176\u4e2d\uff0c x x \u3001 y y \u548c z z \u8868\u793a\u70b9\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5750\u6807\uff1b\u4e0b\u6807 P P and Q Q \u8868\u793a\u70b9 P P \u548c Q Q \uff1b\u53c2\u6570 c c \u4e3a\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97\u70b9 Q Q \u5728\u805a\u5408\u8d85\u692d\u7403\u4e0a\uff0c\u5373\u6ee1\u8db3\u65b9\u7a0b \\eqref{eq:poly_super_ellipsoid}\u3002 \u5c06\u70b9 Q Q \u5e26\u5165\u65b9\u7a0b \\eqref{eq:poly_super_ellipsoid} \u53ef\u6c42\u5f97\u53c2\u6570 c c \uff0c\u4e3a \\begin{align} c = \\left( \\frac{1}{f(\\vec{x}_P)+1} \\right)^{\\frac{\\epsilon_2}{2}} \\end{align} \\begin{align} c = \\left( \\frac{1}{f(\\vec{x}_P)+1} \\right)^{\\frac{\\epsilon_2}{2}} \\end{align} \u6709\u5411\u8ddd\u79bb\u573a\u53ef\u5b9a\u4e49\u4e3a\u70b9 P P \u548c Q Q \u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u4e3a \\begin{align} \\Phi(\\vec{x}_P) = (c-1)||\\vec{x}_P|| \\end{align} \\begin{align} \\Phi(\\vec{x}_P) = (c-1)||\\vec{x}_P|| \\end{align} \u5176\u4e2d\uff0c ||\\vec{x}_P|| ||\\vec{x}_P|| \u8868\u793a\u5411\u91cf \\vec{x}_P \\vec{x}_P \u7684\u6b27\u62c9\u957f\u5ea6\uff0c\u5373\u4e8c\u9636\u8303\u6570\u3002","title":"\u6709\u5411\u8ddd\u79bb\u573a\uff08Signed distance field\uff09"},{"location":"documentation/particle_models/#poly-super-quadrics","text":"","title":"\u805a\u5408\u8d85\u4e8c\u6b21\u66f2\u9762\uff08Poly-super-quadrics)"},{"location":"documentation/particle_models/#formulation_1","text":"\u8d85\u4e8c\u6b21\u66f2\u9762\u53ef\u8868\u793a\u4e3a \\begin{align} f(x, y, z) = \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_x}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_y}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_z}} - 1 = 0 \\label{eq:poly_super_quadrics} \\end{align} \\begin{align} f(x, y, z) = \\left| \\frac{x}{r_{x}} \\right|^{\\frac{2}{\\epsilon_x}} + \\left| \\frac{y}{r_{y}} \\right|^{\\frac{2}{\\epsilon_y}} + \\left| \\frac{z}{r_{z}} \\right|^{\\frac{2}{\\epsilon_z}} - 1 = 0 \\label{eq:poly_super_quadrics} \\end{align} \u5176\u4e2d\uff0c r_{x} r_{x} \u3001 r_{y} r_{y} \u548c r_{z} r_{z} \u5206\u522b\u4e3a\u8d85\u4e8c\u6b21\u66f2\u9762\u5728 x x \u3001 y y \u548c z z \u65b9\u5411\u7684\u534a\u8f74\u957f\uff08semi-pricinpal axis length\uff09\uff1b \\epsilon_{x} \\epsilon_{x} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u662f\u8868\u5f81\u8d85\u4e8c\u6b21\u66f2\u9762\u7403\u5ea6\u6216\u5757\u5ea6\uff08blockness\uff09\u7684\u4e09\u4e2a\u5f62\u72b6\u53c2\u6570\u3002\u5f53\u53c2\u6570 \\epsilon_{x} \\epsilon_{x} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u5728 (0, 2) \u533a\u95f4\u5185\u65f6\uff0c\u8d85\u4e8c\u6b21\u66f2\u9762\u4e3a\u51f8\u578b\uff1b\u5426\u5219\u4e3a\u975e\u51f8\u578b\u3002\u5bf9\u4e8e\u805a\u5408\u8d85\u4e8c\u6b21\u66f2\u9762\uff0c\u534a\u8f74\u957f\u53c2\u6570 r_{x} r_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 r_{x^-} r_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 r_{x^+} r_{x^+} \uff1b\u5f62\u72b6\u53c2\u6570 \\epsilon_{x} \\epsilon_{x} \u5728\u8d1fX\u8f74\u8c61\u9650\u53d6 \\epsilon_{x^-} \\epsilon_{x^-} \uff0c\u5728\u6b63X\u8f74\u8c61\u9650\u53d6 \\epsilon_{x^+} \\epsilon_{x^+} \uff1b r_{y} r_{y} \u3001 r_{z} r_{z} \u3001 \\epsilon_{y} \\epsilon_{y} \u548c \\epsilon_{z} \\epsilon_{z} \u4ea6\u7136\u3002","title":"\u8868\u8fbe\u5f0f\uff08Formulation\uff09"},{"location":"documentation/particle_models/#support-mapping_1","text":"\u53c2\u8003\u7b1b\u5361\u5c14\u5750\u6807\u7cfb\u548c\u7403\u5750\u6807\u7cfb\u4e4b\u95f4\u7684\u5750\u6807\u53d8\u6362\uff0c\u8d85\u692d\u7403\u7684\u7403\u5750\u6807\u53c2\u6570\u5316\u53ef\u8868\u793a\u4e3a \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_z} \\end{align} \\begin{align} x &= r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x} \\\\ y &= r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y} \\\\ z &= r_z (\\cos\\theta)^{\\epsilon_z} \\end{align} \u5176\u4e2d\uff0c \\theta \\theta \u548c \\varphi \\varphi \u5206\u522b\u4e3a\u6781\u89d2\uff08polar angle\uff09\u4e0e\u65b9\u4f4d\u89d2\uff08azimuth angle\uff09\u3002\u628a x x \u3001 y y \u548c z z \u5206\u522b\u5bf9 \\theta \\theta \u548c \\varphi \\varphi \u6c42\u504f\u5bfc\uff0c\u53ef\u5f97\u8d85\u692d\u7403\u8868\u9762\u7684\u65b9\u5411\u5411\u91cf\u4e3a \\begin{align} x_\\theta &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_x} \\\\ y_\\theta &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_y} \\\\ z_\\theta &= \\epsilon_z r_z (\\cos\\theta)^{\\epsilon_z-1} (-\\sin\\theta) \\end{align} \\begin{align} x_\\theta &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x-1} (\\cos\\theta) (\\cos\\varphi)^{\\epsilon_x} \\\\ y_\\theta &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y-1} (\\cos\\theta) (\\sin\\varphi)^{\\epsilon_y} \\\\ z_\\theta &= \\epsilon_z r_z (\\cos\\theta)^{\\epsilon_z-1} (-\\sin\\theta) \\end{align} \u4ee5\u53ca \\begin{align} x_\\varphi &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \\begin{align} x_\\varphi &= \\epsilon_x r_x (\\sin\\theta)^{\\epsilon_x} (\\cos\\varphi)^{\\epsilon_x-1} (-\\sin\\varphi) \\\\ y_\\varphi &= \\epsilon_y r_y (\\sin\\theta)^{\\epsilon_y} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi) \\\\ z_\\varphi &= 0 \\end{align} \u6c42\u4e24\u4e2a\u65b9\u5411\u5411\u91cf\u7684\u53c9\u4e58\u3001\u5e76\u5316\u7b80\uff0c\u53ef\u5f97\u5230\u8d85\u692d\u7403\u8868\u9762\u7684\u6cd5\u65b9\u5411\u4e3a\uff08\u6ce8\uff0c\u6cd5\u65b9\u5411\u5404\u5206\u91cf\u540c\u65f6\u9664\u4e8e\u4e86 \\epsilon_x \\epsilon_y \\epsilon_z r_x r_y r_z (\\sin\\theta)^{\\epsilon_x+\\epsilon_y-1} (\\cos\\theta)^{\\epsilon_z-1} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi)^{\\epsilon_x-1} \\epsilon_x \\epsilon_y \\epsilon_z r_x r_y r_z (\\sin\\theta)^{\\epsilon_x+\\epsilon_y-1} (\\cos\\theta)^{\\epsilon_z-1} (\\sin\\varphi)^{\\epsilon_y-1} (\\cos\\varphi)^{\\epsilon_x-1} \uff09 \\begin{align} n_x &= \\frac{k}{\\epsilon_x r_x} (\\sin\\theta)^{2-\\epsilon_x} (\\cos\\varphi)^{2-\\epsilon_x} \\\\ n_y &= \\frac{k}{\\epsilon_y r_y} (\\sin\\theta)^{2-\\epsilon_y} (\\sin\\varphi)^{2-\\epsilon_y} \\\\ n_z &= \\frac{k}{\\epsilon_z r_z} (\\cos\\theta)^{2-\\epsilon_z} \\end{align} \\begin{align} n_x &= \\frac{k}{\\epsilon_x r_x} (\\sin\\theta)^{2-\\epsilon_x} (\\cos\\varphi)^{2-\\epsilon_x} \\\\ n_y &= \\frac{k}{\\epsilon_y r_y} (\\sin\\theta)^{2-\\epsilon_y} (\\sin\\varphi)^{2-\\epsilon_y} \\\\ n_z &= \\frac{k}{\\epsilon_z r_z} (\\cos\\theta)^{2-\\epsilon_z} \\end{align} \u5176\u4e2d\uff0c n_x n_x \u3001 n_y n_y \u548c n_z n_z \u4e3a\u6cd5\u65b9\u5411\u5728X\u3001Y\u3001Z\u4e09\u4e2a\u65b9\u5411\u7684\u5206\u91cf\uff1b k k \u4e3a\u4e00\u7f29\u653e\u7cfb\u6570\u4f7f\u5f97( n_x n_x \u3001 n_y n_y \u548c n_z n_z )\u4e3a\u5355\u4f4d\u5411\u91cf\u3002\u82e5\u7ed9\u5b9a\u67d0\u70b9\u7684\u6cd5\u65b9\u5411\uff0c\u5219\u8be5\u70b9\u7684\u7b1b\u5361\u5c14\u5750\u6807\u53ef\u7531\u4e0b\u5f0f\u8ba1\u7b97\uff1a \\begin{align} x &= r_x \\left( \\frac{\\epsilon_x r_x n_x}{k} \\right)^{\\frac{\\epsilon_x}{2-\\epsilon_x}} \\\\ y &= r_y \\left( \\frac{\\epsilon_y r_y n_y}{k} \\right)^{\\frac{\\epsilon_y}{2-\\epsilon_y}} \\\\ z &= r_z \\left( \\frac{\\epsilon_z r_z n_z}{k} \\right)^{\\frac{\\epsilon_z}{2-\\epsilon_z}} \\\\ \\end{align} \\begin{align} x &= r_x \\left( \\frac{\\epsilon_x r_x n_x}{k} \\right)^{\\frac{\\epsilon_x}{2-\\epsilon_x}} \\\\ y &= r_y \\left( \\frac{\\epsilon_y r_y n_y}{k} \\right)^{\\frac{\\epsilon_y}{2-\\epsilon_y}} \\\\ z &= r_z \\left( \\frac{\\epsilon_z r_z n_z}{k} \\right)^{\\frac{\\epsilon_z}{2-\\epsilon_z}} \\\\ \\end{align} \u5c06\u4e0a\u5f0f\u5e26\u5165\u516c\u5f0f\\eqref{eq:poly_super_quadrics}\u53ef\u6c42\u5f97\u7cfb\u6570 k k \uff0c\u8fdb\u800c\u5f97\u5230\u8be5\u70b9\u7684\u5750\u6807 x x \u3001 y y \u548c z z \u3002 DEM wiki \u250a Previous \u250a Next","title":"\u652f\u6491\u6620\u5c04\uff08Support mapping\uff09"},{"location":"documentation/particle_models/#_2","text":"S. Zhao and J. Zhao. A poly-superellipsoid-based approach on particle morphology for DEM modeling of granular media. International Journal for Numerical and Analytical Methods in Geomechanics , 43(13):2147\u20132169, 2019. \u21a9","title":"\u53c2\u8003\u6587\u732e"},{"location":"documentation/user_manual/","text":"User manual Installation : installation, test, and dependencies, etc. Basic usage : running simulation, particle shape reconstruction, post-processing, etc. Paraview rendering : hints and procedures in paraview visualization. Blender rendering : hints and procedures in blender visualization. CFD-DEM simulation : coupled CFD-DEM simulation using OpenFOAM NetDEM.","title":"User manual"},{"location":"documentation/user_manual/#_1","text":"","title":""},{"location":"documentation/user_manual/#user-manual","text":"Installation : installation, test, and dependencies, etc. Basic usage : running simulation, particle shape reconstruction, post-processing, etc. Paraview rendering : hints and procedures in paraview visualization. Blender rendering : hints and procedures in blender visualization. CFD-DEM simulation : coupled CFD-DEM simulation using OpenFOAM NetDEM.","title":"User manual"},{"location":"download/","text":"NetDEM Source code: https://github.com/apaam/netdem Website: https://github.com/apaam/netdem_docs Post-processing scripts Matlab: https://github.com/apaam/postprocess_scripts Other relevant softwares Easybuild : a software environment for easing the configuration, building and installation computational packages. Now support: deal.II : a C++ program library targeted at the computational solution of partial differential equations using adaptive finite elements. liggghts : an open source discrete element method particle simulation software that is improved from LAMMPS for general granular and granular heat transfer simulations. This project used a modified version that includes granular bond formulations. netdem : a neural network machine learning enabled DEM framework for computational particle mechanics. [to be open-source soon] openfoam : a free, open source computational fluid dynamics (CFD) software package released by the OpenFOAM Foundation. peridigm : an open-source computational peridynamics code developed, originally at Sandia National Laboratories and open-sourced in 2011, for massively-parallel multi-physics simulations.","title":"Download"},{"location":"download/#_1","text":"","title":""},{"location":"download/#netdem","text":"Source code: https://github.com/apaam/netdem Website: https://github.com/apaam/netdem_docs","title":"NetDEM"},{"location":"download/#post-processing-scripts","text":"Matlab: https://github.com/apaam/postprocess_scripts","title":"Post-processing scripts"},{"location":"download/#other-relevant-softwares","text":"Easybuild : a software environment for easing the configuration, building and installation computational packages. Now support: deal.II : a C++ program library targeted at the computational solution of partial differential equations using adaptive finite elements. liggghts : an open source discrete element method particle simulation software that is improved from LAMMPS for general granular and granular heat transfer simulations. This project used a modified version that includes granular bond formulations. netdem : a neural network machine learning enabled DEM framework for computational particle mechanics. [to be open-source soon] openfoam : a free, open source computational fluid dynamics (CFD) software package released by the OpenFOAM Foundation. peridigm : an open-source computational peridynamics code developed, originally at Sandia National Laboratories and open-sourced in 2011, for massively-parallel multi-physics simulations.","title":"Other relevant softwares"},{"location":"examples/","text":"Under construction.","title":"Examples"},{"location":"examples/angle_of_repose/","text":"","title":"Angle of repose"},{"location":"examples/granular_mixing/","text":"","title":"Granular mixing"},{"location":"examples/random_packing/","text":"[WIP] Random packing Problem description Setup and implementation Results and discussions","title":"Random packing"},{"location":"examples/random_packing/#random-packing","text":"","title":"Random packing"},{"location":"examples/random_packing/#problem-description","text":"","title":"Problem description"},{"location":"examples/random_packing/#setup-and-implementation","text":"","title":"Setup and implementation"},{"location":"examples/random_packing/#results-and-discussions","text":"","title":"Results and discussions"},{"location":"examples/triaxial_compression/","text":"","title":"Triaxial compression"},{"location":"gallery/animations/","text":"This page collects animations from various simulations based on NetDEM. Granular mixing of spheres. Random packing of mixed types of particles, including poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, level set, polyhedron, etc. Nut sliding on bolt without frition and damping, where the nut and bolt is modeled with polyhdral particles in DEM. Packing and compression of deformable particles, with particle deformation solved by finite element method and particle contacts solved by signed distance field approach. Triaxial compression of irregular-shaped particles that are represented by spherical harmonics. Random packing of generaly irregular-shaped particles, where the contacts are handled by neurual networks. Debris flow simulation with spheres and triangles (using contact-area-weighted contact forces). Note this example is intended to demonstrate the capability of NetDEM but have not been calibrated to reassemble a real debris flow. Dam break and waves strike onto irregular-shaped particle assembly, a demonstrative example of integrating with OpenFOAM for coupled CFD-DEM simulation. Column collapsing of irregular-shaped particles that are represented by spherical harmonics. Particle curshing simuated with coupled DEM-peridigm, where level set-based domain splitting appraoch is employed for fragments reconstruction. Membrane tensiling and twisting, simulated with finite element and neo-hookean model.","title":"Animations"},{"location":"gallery/animations/#_1","text":"This page collects animations from various simulations based on NetDEM. Granular mixing of spheres. Random packing of mixed types of particles, including poly-super-ellipsoid, poly-super-quadrics, spherical harmonics, level set, polyhedron, etc. Nut sliding on bolt without frition and damping, where the nut and bolt is modeled with polyhdral particles in DEM. Packing and compression of deformable particles, with particle deformation solved by finite element method and particle contacts solved by signed distance field approach. Triaxial compression of irregular-shaped particles that are represented by spherical harmonics. Random packing of generaly irregular-shaped particles, where the contacts are handled by neurual networks. Debris flow simulation with spheres and triangles (using contact-area-weighted contact forces). Note this example is intended to demonstrate the capability of NetDEM but have not been calibrated to reassemble a real debris flow. Dam break and waves strike onto irregular-shaped particle assembly, a demonstrative example of integrating with OpenFOAM for coupled CFD-DEM simulation. Column collapsing of irregular-shaped particles that are represented by spherical harmonics. Particle curshing simuated with coupled DEM-peridigm, where level set-based domain splitting appraoch is employed for fragments reconstruction. Membrane tensiling and twisting, simulated with finite element and neo-hookean model.","title":""},{"location":"gallery/snapshots/","text":"Under construction.","title":"Snapshots"}]}